<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>A Mandelbrot halmaz</title>
        
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/mandelcomplex">https://github.com/Savitar97/Prog1/tree/master/mandelcomplex</link>              
        </para>
        <para> 
            A program elején definiáljuk a kép méretét és az iterációs határt mivel végtelen számra nem tudjuk megnézni ezért kell valamilyen korlát.      
        </para>
        <para>
            A mainben most használjuk az argc és argv-t, ez csak azért kell,hogy megadhassuk hogy milyen néven mentse el a kimenetet. Ha nem adunk meg fájl nevet az első if fog hibaüzenetet dobni nekünk.
        </para>
        <para>
            Ezután létrehozunk egy 2 dimenziós tömböt a kép méreteivel. Ezután a mandel függvénynek átadjuk ezt a tömböt. Itt vannak a futási időhöz való számítást segítő változók. De ami lényeg az a számoláshoz tartozó változók és, hogy az adott komplex szám a halmaznak eleme -e, ez akkor lehetséges ha a z kisebb mint 2 vagy elértük a 255. iterációt. Majd feltöltjük a tömböt. Majd létrehozunk egy új képet kép néven és pixelenként bejárjuk és ami benne van a halmazba elem azon a helyen a képkocka színét átszínezzük. Majd a write(argv[1])-el a megadott fájlnévvel készítünk egy képet. Az így kapott ábra a mandelbrot halmaz grafikus megjelenítése, amely egy fraktál az az egy végtelenül komplex alakzat lesz. Vagyis minél jobban rá nagyítunk ismétlődésként megfog jelenni ez az ábra.
        </para>
    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
                
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/mandelcomplex">https://github.com/Savitar97/Prog1/tree/master/mandelcomplex</link>              
        </para>
        <para>
            Ez a program ugyan az mint az előző csak most a complex osztályt fogjuk használni. Elsőként felvesszük a kezdetleges változókat vagyis, hogy mekkora legyen majd a kép mérete, hányszor fogunk iterálni és az intervallumot amin ábrázolni szeretnénk. Ezeket majd konzolról kérjük be de inicializáljuk, majd az if megvizsgálja megvan -e a kellő bemeneti adat, ha nincs akkor hibaüzenetet dob a program hasznáaltára.
        </para>
        <para>
            Ezután létrehozunk egy üres képet a mérettel és a szélességgel. Ezután a dx és dy al megadjuk, hogy minden egyes lépéssel mennyit megyünk előre azaz a lépésközöket. A következő for ciklussal végig megyünk a képnek a képpontjain. Ezután kiszámoljuk C-nek a valós és imaginárius részét és ezeket átadjuk a komplex C számnak.Majd létrehozunk egy z_n komplex számot és inicializáljuk. Ezután jön egy while ciklus ami addig megy amíg a z_n abszolút értékben kisebb mint 4 vagy pedig elértük az iterációs határt. Majd a while ciklus törzsében kiszámoljuk a z_n értékék és növeljük az iterációs határt. Majd ha kilép a while ciklusból a képnek az adott sorában és oszlopában lévő pixel színét átállítjuk. Az int százalékkal a feldolgozás állását közvetítjük a consolra. Végén kiiratjuk a képet a megadott fájlba.
        </para>
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            A biomorfos program abban különbözik az előzőtől, hogy most több argumentumot tudunk megadni tehát adhatunk kezdőértéket egy komplexszámnak cc-nek, amelyet majd z-hez mindig hozzáadunk. A bekért karakterket az atoi intté alakítja míg az atof lebegőpontos számmá. Az előzőhöz képest ahol egy while-t futtattam, hogy eldöntsem mely elemeket tartoznak a halmazba és ez a feltétel az volt hogy abszolút értékbe a z komplex szám kisebb mint négy, vagy elértük -e az iterációs határt. Ez a feltétel most annyiban változott, hogy R ben megadhatjuk hogy mekkora érték felett kell legyen a z valós vagy z imaginárius részének és csak akkor növeljük az iterációk számát(ez egy küszöbérték), vagyis az iteráció azt az értéket fogja megkapni a 0-és az iterációs határ között,amelyre még teljesül a feltétel. Emellett még lényeges változtatás, hogy eddig csak az iterációt osztottuk maradékosan a kép színeihez, de mostmár konstansokkal szorozzuk meg a különböző színeket előállító képletet. Ez színesebb képet fog eredményezni és a több argumentum nagyobb szabadságot nyújt a felhasználónak,hogy különböző képeket alkosson.
            A biomorfos képek az egysejtűekre hasonlítanak, elég érdekes formákat lehet alkotni a program segítségével.
        </para>
        <para>
            Az általam létrehozott biomorf amely szerintem egész jól néz ki:
        </para>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/bmorf.png" scale="30" />
                </imageobject>
        </mediaobject>                      
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/Savitar97/bhax/tree/master/attention_raising/CUDA">https://gitlab.com/Savitar97/bhax/tree/master/attention_raising/CUDA</link> 
        </para>
        <para>
            Lényegében itt azt kell megfigyelnünk, hogy mennyivel gyorsabban dolgoznak a cuda magok a processzornál. A processzornál ugyebár a képpontokat szekvenciálisan számljuk tehát a processzor egyessével számolja a képpontokat.Ez a cudanál egyszerre történik most az az minden egyes képpontot egy szál fog számolni a számolás egyszerre történik mint a párhuzamos programoknál. Ez hatalmas sebességbeli növekedést eredményez konkrétan egy pillanat alatt végez a program ha elég erős a videókártyánk, mivel itt már a gpu számol nem a cpu.
        </para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <caution>
            <title>
                Tutor
            </title>
            <para>Ebben a feladatban tutoráltam Kun-Limberger Anettet.</para>
        </caution>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
            
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/Nagyito">https://github.com/Savitar97/Prog1/tree/master/Nagyito</link> 
        </para>

        <para>
            Megoldás videó: 
        </para>
        <para>
            Újra a mandelbrot halmazzal fogunk foglalkozni, de most felhasználjuk a qt-t hogy létrehozzunk egy grafikus interfacet. A programban a tartományt ugyan úgy az a, b , c és d változó határozza meg A képlet most is ugyan az mint a legelsőnél, amivel számoljuk az iterációt: z_(n+1) = z_n * z_n + c, ez a számolás a frakszal.cpp-ben van. A számításokat soronként küldjük vissza a frakablaknak, amely majd elvégzi a színezést. A változó deklarációja és inicializálása a számításokhoz a frakablak.h-ban található.A frakablak.cpp-ben definiáljuk, hogy mit csináljon a program az egérmozgására és, hogyha kijelölünk egy területet az egérrel akkor arra a területre nagyítson rá. Tehát a mousepressevent letárolja a kattintásunk koordinátáit, míg a mousemove a szélességet és a magasságot tehát, hogy az adott pontból mekkora területet jelöltünk ki. Majd a felengedéskor újra számol és rá zoomol a területre.Az N gomb lenyomásával változtathatjuk az iterációs határt amivel változik a kép részletessége is, ugyanis az N gomb lenyomására az iterációs határ kétszereződik emiatt nagyobb lesz a részletessége a képnek,így amikor jobban rá zoomolunk akkor nem csak olyan mintha egy sima képre nagyítanánk mivel ha az iterációs határ megnő akkor a mandelbrothalmaznak egyre több eleme lesz emiatt változik a kép is.Persze minden számolás után update-eljük az osztáyban lévő értékeket. Az újra számoláshoz készítünk mindig egy új FrakSzal-t, a régi mandelbrot halmazt töröljük és a frissített iterációshatárral számolunk.  
        </para>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelzoom.png" scale="20" />
                </imageobject>
        </mediaobject> 
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
            
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
