<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <caution>
            <title>
                Felhasznált irodalom:
             </title>
             <para>
                <link xlink:href=" http://www.cs.ubbcluj.ro/~csatol/mestint/pdfs/BME_SpecialisUtkeresoAlgoritmusok.pdf">http://www.cs.ubbcluj.ro/~csatol/mestint/pdfs/BME_SpecialisUtkeresoAlgoritmusok.pdf</link>
             </para>
             <para>
                 Az ábra a <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link> származik.
             </para>
        </caution>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            A hangyaszimuláció a hangyák mozgását és nyomvonalát szimulálja, minden hangya feromon nyomot hagy, és ha feromon nyomra lép akkor elkezdi követni az előző hangya által hagyott feromont,a feromon kezdetben sötétzöld de egyre halványodik ha nem kezdi el követni egy újabb hangya.Minél erősebb egy feromon nyom annál nagyobb az esélye, hogy elkezdi követni egy közelben járó hangya. Elsőként is létrehozzuk a hangya osztályt,amelyben a hangyák koordinátáit és mozgásukat adjuk meg. A mozgásuk irányát maradékos osztással számoljuk.Majd típusdefiniáljuk a hangya osztályt, ez a multiplicitás miatt, ugyanis több hangyát akarunk majd létrehozni és kezelni.
            Az AntWinbe adjuk meg az ablak tulajdonságait(A hangyák megjelenítését, amely zöld négyzetekkel történik,a rácsvonalak méreteit és a megfelelő key eventeket ez itt most csak a pause a P vel és a Q-val vagy ESC-el való kilépés. Ha nem adunk meg semmit kapcsolóval akkor az alapértelmezett értékeket veszi fel viszont mi is megadhatjuk neki az ablak tulajdonságait és a hangyák tulajdonságait. Emellett a kirajzolás event is itt történik meg.
        </para>
        <para>
            A parancssorban itt az érték megadaást a qcommandlineoptionnal érjük el. Amit módosítani tudunk a w kapcsolóval a szélességet cellákban mérve. Az m-el a magasságot cellákban mérve. Ezen kívül megadhatjuk a hangyák számát(-n), sebességüket(-t két lépés közötti időt nézi), és a párolgási időt(-p), hogy hány mp után pusztítsuk el az objektumot.Majd a nyomvonalukat a hangyáknak ezek a feromonok(-f) és a cellák méretét(-c), hogy hány hangya fér rá egy cellára.
        </para>   
        <para>
            Az antthread.h ban vannak a program eventjei, hogy éppen fut -e a program vagy szünetel.Ha nem adunk meg kapcsolókkal értékeket akkor az antwin.h-ban lévő alap beállításokkal fog futni a program.
            A program futtatásához a Qt-nak legalább 5.2 es verziója szükséges.
        </para>
        <figure>
             <title>Hangyaszimuláció</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Ant.png" scale="30" />
                </imageobject>
        </mediaobject>
        </figure>
        <figure>
             <title>UML osztálydiagramm</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/antabra.png" scale="40" />
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            Az ábra elején lévő + jelzi hogy globálisan hozzáférhető -e az adott program részhez a - a helyi hozzáférésű részek.
        </para>    
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apb.html#conway"></link>               
        </para>
        <para>
            A java életjáték lényege, hogy vannak élő és halott sejtek. Tehát a sejtnek ez a két állapota van. Egy élő sejt addig él tovább, amíg 2 vagy 3 szomszédja élő. Ha ez nem teljesül akkor elpusztul. Egyik véglet a túlnépesedés amikor 3-tól több a másik véglet amikor 2 nél kevesebb akkor pedig túl kevés az életben maradáshoz.Ha halott állapotban van egy sejt, akkor mindaddig halott marad, amíg 3 szomszédja élő. Két ráccsal dolgozunk egy jelenlegi állapottal és a megváltozott állapottal. Ezt az időfejlődés eljárás befolyásolja, itt figyeljük a sejtek állapotát, azt hogy hogyan változnak. A rácsok közötti váltakozást egy indexxel figyeljük. Külön definiáljuk a cella méreteit és azt, hogy mekkora a sejttér azaz, hogy hány cella magas és széles.
            Emellett definiáljuk, hogy mennyi idő múlva váltson a jelenlegi sejttér a következőre. A programban készíthetünk pillanatfelvételt az S gombbal ezeket számoljuk, hogy hányat készítünk. Magát a felvétel készítését egy bool típúsú változóval érjük el. Majd a konstruktorban definiáljuk a sejtterünket, kezdetben minden sejt állapota halott. Majd létrehozzuk az első élőlényeket a siklókilövőket. Magát a sejtteret úgy hozzuk létre, hogy ami kiúszik az egyik oldalon az térjen vissza a másikon. A funkció gombok a program futása során a már tárgyalt 'S', ezen kívül van lehetőségünk felezni a cella méreteit a 'K'-val vagy esetleg duplázni az 'N'-el. Emellett a 'G'-vel gyorsíthatjuk a rácsok közötti váltást vagy pedig az 'L'-el lassíthatjuk. Az egérmutatóval változtathatjuk a sejtek állapotát. Tehát ha húzzuk az egeret a cellákon akkor a halott cellákból élőket tudunk csinálni. A kezdeti cellaméret 10x10 es.
            A sejttér kirajzolásáért a paint eljárás a felelős. Ha egy sejt élő akkor feketével rajzoljuk ki ellenkező esetben fehérre színezzük a cellát. A rácsokat szürkével rajzoljuk ki. A létrehozott siklók a sejttérben automatikusan másolják magukat és megadott irányba haladnak. És végülis a legjobban az egérrel tudunk beavatkozni az egész sejttér fejlődésbe. A mainben már csak példányosítjuk magát a sejtautomatát a konstruktora segítségével. A következő feladatban majd láthatjuk ennek a feladatnak a c++ és qt segítségével elkészített megoldását.
        </para>
        <para>
            Élet a sejttérben:
            </para>
            <figure>
             <title>Sejtautomata</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/sejtautomata1.png" scale="30" />
                </imageobject>
        </mediaobject>
            </figure>         
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://sourceforge.net/p/udprog/code/ci/master/tree/source/kozepes/Qt/sejtautomata/">https://sourceforge.net/p/udprog/code/ci/master/tree/source/kozepes/Qt/sejtautomata/</link>               
        </para>
        <para>
            A programban a sejt ablakban van definiálva, hogy mekkora legyen az ablak lényegében, hogy hány cella van. A cellák méretét külön adjuk meg itt, 6x6 os kocka.A sejtnek két állapota van élő vagy halott, élő marad mindaddig amíg kettő vagy három szomszédja van ellenkező esetben halott lesz.A sejt ablakban az élőlények a siklók, amelyek másolják magukat és adott irányba haladnak. A siklókat sikló ágyúkból lőjük ki.A sikló ágyúknak fix pozíciója van. A painteventben rajzoljuk ki magát a táblát és a skiló kilövőket.Minden egyes kockának 8 szomszédja van az az egy sejt 9 kockát befolyásol.
            A lényeg, hogy teremthetünk egy világot ahol eldönthetjük a létrehozott sejtek számát az az megadhatjuk mikor lehet élő a sejt vagy mikor halott.Így végülis a populációt tudjuk befolyásolni. És ez egy olyan játék ahol a személy csak megfigyelője az eseményeknek nem pedig részese ugyanis miután beállítottuk a szabályait a világnak onnantól magától fut és teremtődnek az élőlények.
        </para>
        <figure>
             <title>Életjáték</title>
             <mediaobject>
                <imageobject>
                    <imagedata fileref="img/eletjatek.png" scale="30" />
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            Káoszba fordult világ a halálozási arány csökkentésével.
        </para>     
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <caution>
            <title>
                Tutor
            </title>
            <para>Ebben a feladatban tutoráltam Egyed Annát.</para>
        </caution>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/BrainBbench">https://github.com/Savitar97/Prog1/tree/master/BrainBbench</link>               
        </para>
        <para>
            A BrainB benchmark egy felmérés. Amely főleg az mmorpgvel játszó játékosokat képes mérni. Mégpedig azt, hogy mennyire képesek követni a karakterüket a tömegbe. A lényeg,hogy az egérmutatót a karakterünkön samun tartsuk a játék pedig egyre több hőst generál a karakterünk köré és 10 percen keresztül nem szabad elveszteni a karakterünk nyomát.Majd a benchmark ad egy eredményt, amely számosítja a teljesítményét a játékosnak. Ez alapján készíthetünk esetleg egy táblázatot, hogy meghatározzuk sávokban is a pontszámokat, így megtudjuk ki a jobb képességű.A moba területen is hasznos lehet a játék ugyanis a teamfightokban a sok effekt között könnyen eveszíthetjük a karakterünket vagy épp a focusolandó enemy játékosét.
            Ezzel a programmal lehetséges, mérni az egyén teljesítőképességét és kiválogatni azokat akik sokkal jobbak az átlagtól és akár a csapatok meghatározhatnának egy minimális pontszámot, amit elkell érni a jelentkezéshez.Viszont a 10 perc szerintem elég sok idő. Mármint jó a koncentráció képességet próbára tesszük. De akkor is elég unalmas végig ülni, amíg a teszt lefut.
        </para>            
        <para>
            És most beszéljünk kicsit a programról a BrainBThread.cpp-ben hozzuk létre a hős osztályunkat és itt hozzuk létre(deklaráljuk) a hősünket Samut.A hős osztály konstruktorában. A mozgását az ablakban randommal számoljuk. A Qthread-ban határozzuk meg az eventeket.Ilyen  a pause. És magát, hogy a hőst hogyan jelnítse meg, hogy írja ki a nevét stb.A BrainBWin-ben vannak meghatározva a presd eventek vagyis, hogy az egérgomb levan -e nyomva vagy nincs és hogy az S el mentse el az eredményt a P-vel pause-oljon az ESC-el vagy Q-val pedig lépjen ki.Ha az egérgombot lenyomjuk akkor kezdődik a mérés.Az ifben vizsgáljuk, hogy az egér a hősünkön van -e ha igen akkor létrehozunk egy new entropyt ez a incCompban van a BrainBThread.h-ban és növeljük a hősünk agilityjét 2 vel ha nincs rajta akkor kiszedünk a vektorból egy entropyt és csökkentjük a hősünk agilityjét.
        </para>
        <figure>
             <title>BrainB benchmark</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/BrainB.png" scale="30" />
                </imageobject>
        </mediaobject>
        </figure>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
