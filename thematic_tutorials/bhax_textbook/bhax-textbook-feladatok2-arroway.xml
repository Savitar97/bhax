<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>
            A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá,
            hogy a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elő, kell egy
            példánytag, amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell
            az algot.) és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
            https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf (16-22 fólia)
            Ugyanezt írjuk meg C++ nyelven is! (lásd még UDPROG repó: source/labor/polargen)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/polar">https://github.com/Savitar97/Prog1/tree/master/polar</link>              
        </para>
        <para>
            A polargenünk két előállított normálisa a v1 és v2 változó. A példánytagunk, amely a nem visszaadottat tárolja az a tarolt nevű változó.
            A logikai tagunk a nincsTarolt változó ezt igazról indítjuk, mivel az elején még nincs érték a tarolt nevű változónkban.Tehát elsőnek az if águnknak a true ága fog lefutni elsőként.
            Itt addig fut a do while ciklusunk, amíg a w változó értéke nem lesz 1-nél nagyobb. Majd számolunk egy r-t. A tarolt változónkba letároljuk az r*v2-t. Majd a nincsTarolt-at false-ra állítjuk és kiiratjuk a nem tárolt normálist az r*v1-et.
            Következő futtatásnál az ifnek a hamis ága fog lefutni. Tehát a letárolt értéket fogja kiiratni a program és a nincsTaroltat újra true-ra állítjuk, hogy új két normálist számoljon a programunk. A konstruktorban inicializáljuk a nincsTaroltat, hogy minden egyes objektum példányosításnál true értéket vegyen fel a nincsTarolt változó.    
        </para>
        <figure>
             <title>Polargen random</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/sourcejava.png" scale="30" />
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            A C++-os verziónál a header file-ban írjuk meg a PolarGen osztályunkat. Az osztálynak itt nem csak a konstruktorát kell megírni, de a destruktorát is. Javaval ellentétben, ugyanis ott a garbage collector elvégzi a munkát, tehát nekünk nem szükséges definiálnunk.
            Az osztály kovetkezo nevű függvényét mivel kívülről hívtuk meg, ezért a ::-t kell használnunk, amely mutatja melyik osztály hatáskörébe tartozik. A felépítés a Java-s hoz képest nem sokat változott. A különbség annyiban szenbetűnő, hogy a java erősen objektum orientált, míg a C++-ban lehetőségünk van ettől eltérni.
            A példányosításnál is látunk minimális különbséget ugyanis a javaban mindig a new kulcsszót kell használnunk, míg C++-ban elég az osztály nevét és az objektum nevét megadni.
            
        </para>
    </section>        

    <section>
        <title>Homokozó</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <figure>
             <title>Binfa Servlet indexpage</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/servlet.png" scale="30" />
                </imageobject>
        </mediaobject>
        </figure>
        <figure>
             <title>Binfa Servlet after run</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/servlet2.png" scale="30" />
                </imageobject>
        </mediaobject>
        </figure>
    </section>        
    <section>
        <title>"Gagyi"</title>
        <para>
            Az ismert formális 2 tesztkérdéstípusra adj a szokásosnál
            (miszerint x, t az egyik esetben az objektum által hordozott érték, a másikban meg az objektum
            referenciája) „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x, t
            értékekkel meg nem! A példát építsd a JDK Integer.java forrására 3 , hogy a 128-nál inkluzív objektum
            példányokat poolozza!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <programlisting language="java"><![CDATA[
 90:   // This caches some Integer values, and is used by boxing
 91:   // conversions via valueOf().  We must cache at least -128..127;
 92:   // these constants control how much we actually cache.
  93:   private static final int MIN_CACHE = -128;
  94:   private static final int MAX_CACHE = 127;
  95:   private static Integer[] intCache = new Integer[MAX_CACHE - MIN_CACHE + 1];
 305:   public static Integer valueOf(int val)
 306:   {
 307:     if (val < MIN_CACHE || val > MAX_CACHE)
 308:       return new Integer(val);
 309:     synchronized (intCache)
 310:       {
 311:     if (intCache[val - MIN_CACHE] == null)
 312:       intCache[val - MIN_CACHE] = new Integer(val);
 313:     return intCache[val - MIN_CACHE];
 314:       }
 315:   }
          ]]>
        </programlisting> 
        <para>
            Mivel a cache-nek a mérete -128 és 127 közé esik,így ha az objektumunk ebből a tartományból vesz fel értéket akkor az Integer osztály valueof(int val) függvénye fog lefutni.
            Tehát az előltesztelős ciklusunknak a feltétele egyből teljesül és kilép. Viszont, ha ezen a tartományon kívül veszünk fel értéket akkor false eredményt kapunk és végtelen ciklusunk lesz.
            Ez egy memória megtakarító és teljesítmény növelő funkció, amit autoboxingnak neveznek.
        </para>
    </section>
    <section>
        <title>Yoda</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A Yoda condition a nevét a Starwars karakteréről kapta, aki elég egyedi angolnyelvi szintaxisával is kitűnt a sorozatból ez az egyedi szintaxis az volt, hogy az alany->ige->tárgyat felcserélte tárgy->alany->igére.
            A Yoda condition lényege az, hogy egy ekvivalenciánál a konstanst nem a megszokott jobb oldalára írjuk az ekvivalenciának, hanem a bal oldalra.
            Ezt általában stringeknél használjuk. Tehát nem az objektumunkat hasonlítsuk össze a stringgel, hanem a stringet az objektumunkkal.
            Az előnye a feltétel betartásának az, hogy elkerüljük a NullPointerExceptions-t.Viszont a hátránya az, hogy a kód olvasását nehezebbé teszi.
            Ugyanis ilyenkor jobbról balra érdemesebb olvasnunk a feltételeket. Viszont ezen kívül még, megkímélhetjük magunkat az == helyett = operátor hibától.
            
        </para>
    </section>
    <section>
        <title>Kódolás from scratch</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
