<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>
            A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá,
            hogy a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elő, kell egy
            példánytag, amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell
            az algot.) és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
            https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf (16-22 fólia)
            Ugyanezt írjuk meg C++ nyelven is! (lásd még UDPROG repó: source/labor/polargen)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/polar">https://github.com/Savitar97/Prog1/tree/master/polar</link>              
        </para>
        <para>
            A polargenünk két előállított normálisa a v1 és v2 változó. A példánytagunk, amely a nem visszaadottat tárolja az a tarolt nevű változó.
            A logikai tagunk a nincsTarolt változó ezt igazról indítjuk, mivel az elején még nincs érték a tarolt nevű változónkban.
            </para>
            <programlisting language="java"><![CDATA[
            boolean nincsTarolt = true;
            double tarolt;

            public PolarGen () {

            nincsTarolt = true;

            }
            ]]>
        </programlisting>
            <para>
            Tehát elsőnek az if águnknak a true ága fog lefutni elsőként.
            Itt addig fut a do while ciklusunk, amíg a w változó értéke nem lesz 1-nél nagyobb. Majd számolunk egy r-t. A tarolt változónkba letároljuk az r*v2-t. Majd a nincsTarolt-at negáljuk és kiiratjuk a nem tárolt normálist az r*v1-et.
            Következő futtatásnál az ifnek a hamis ága fog lefutni. Tehát a letárolt értéket fogja kiiratni a program és a nincsTaroltat újra negáljuk ezzel true-ra állítjuk, hogy új két normálist számoljon a programunk. A konstruktorban inicializáljuk a nincsTaroltat, hogy minden egyes objektum példányosításnál true értéket vegyen fel a nincsTarolt változó.    
        </para>
        <programlisting language="java"><![CDATA[
            public double kovetkezo () {

            if (nincsTarolt) {

            double u1, u2, v1, v2, w;
            do
            {
                u1 = Math.random();
                u2 = Math.random();
                v1 = 2 * u1 - 1;
                v2 = 2 * u2 - 1;
                w = v1 * v1 + v2 * v2;
            }
            while (w > 1);

            double r = Math.sqrt ((-2 * Math.log (w)) / w);

            tarolt = r * v2;
            nincsTarolt = !nincsTarolt;

            return r * v1;
            }
            else
            {
                nincsTarolt = !nincsTarolt;
                return tarolt;
            }

            }

          ]]>
        </programlisting>
        <figure>
             <title>Polargen random</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/polargen.png" scale="200" />
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            A C++-os verziónál a header file-ban írjuk meg a <classname>PolarGen</classname> osztályunkat. Az osztálynak itt nem csak a konstruktorát kell megírni, de a destruktorát is. Javaval ellentétben, ugyanis ott a garbage collector elvégzi a munkát, tehát nekünk nem szükséges definiálnunk.
            Az osztály kovetkezo nevű függvényét mivel kívülről hívtuk meg, ezért a ::-t kell használnunk, amely mutatja melyik osztály hatáskörébe tartozik. A felépítés a Java-s hoz képest nem sokat változott. A különbség annyiban szenbetűnő, hogy a java erősen objektum orientált, míg a C++-ban lehetőségünk van ettől eltérni.
            A példányosításnál is látunk minimális különbséget ugyanis a javaban mindig a new kulcsszót kell használnunk, míg C++-ban elég az osztály nevét és az objektum nevét megadni.A polargen lényegében két randomot állít elő (-1,1) intervallumban a függvény segítségével.
            A java jdk könyvtárában hasonlóképp megtalálható a jdk/src/share/classes/java/util Random.java fájlában, de nem teljesen ugyan az a kettő.A jdkban szereplő kód a következőképpen néz ki:
        </para>
        <programlisting language="java"><![CDATA[
            synchronized public double nextGaussian() {
        // See Knuth, ACP, Section 3.4.1 Algorithm C.
        if (haveNextNextGaussian) {
            haveNextNextGaussian = false;
            return nextNextGaussian;
        } else {
            double v1, v2, s;
            do {
                v1 = 2 * nextDouble() - 1; // between -1 and 1
                v2 = 2 * nextDouble() - 1; // between -1 and 1
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s == 0);
            double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);
            nextNextGaussian = v2 * multiplier;
            haveNextNextGaussian = true;
            return v1 * multiplier;
        }
        }
          ]]>
        </programlisting>
    </section>        

    <section>
        <title>Homokozó</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Binfa">https://github.com/Savitar97/Prog2/tree/master/Binfa</link>              
        </para>
        <para>
            Servlet megoldása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/WebApplication1">https://github.com/Savitar97/Prog2/tree/master/WebApplication1</link>
        </para>
        <caution>
            <title>
                Tutoráltás
            </title>
            <para>Ebben a feladatban tutoráltam Molnár Antal Albertet,Ádám Petrát.</para>
        </caution>
        <para>
            A binfa java a c++-hoz képest nem sokat változik. A különbség annyi, hogy itt nem választhatunk, hogy tagként,referenciaként vagy esetleg pointerként adjuk át a csomópontot.
            Ugyanis a javaban nincsenek pointerek. A létrehozott <classname>Node</classname> osztály azaz a csomópont osztály tartalmaz egy érték változót és egy jobb és egy bal oldali objektumát a csomópontnak.
            Ezen kívül tartalmazza a jobb és baloldali csomópontok értékének lekérdezéséhez szükséges get függvényeket és az értékek beállításához szükséges set függvényeket, ezen kívül a csomópont értékének lekérdezéséhez szükséges get függvény.
        </para>
        <programlisting language="java"><![CDATA[
        class Node {
        private char value;
        private Node left;
        private Node right;
        
        public Node(char rhs){
            value = rhs;
            left = null;
            right = null;
        }
	
	
        public char getNode(){
            return value;
        } 
        
        public void setLeft(Node rhs){
            left = rhs;
        }
        
        public void setRight(Node rhs){
            right = rhs;
        }
        
        public Node getLeft(){
            return left;
        }
        
        public Node getRight(){
            return right;
        }
        
        }
          ]]>
        </programlisting>
            <para>
            Most nézzük a <classname>binfa</classname> osztályt. Először is létrehozunk egy final kulcsszóval ellátott Node objektumot a root-ot, ez lesz a fánknak a gyökere. Tehát ennek az értéke nem változik fix marad az egész program futása során. Ezen kívül létrehozzuk a csomópontnak a jelenlegi objektumát amibe, majd az értéket pakoljuk, ami éppen jön a bemenetről.
            Emellett itt definiáljuk az átlaghoz,mélységhez,magassághoz és szóráshoz szükséges változókat private kulcsszóval. Javaban látszik, hogy nem private blokk van, hanem mindig jelezni kell, hogy az a változó,metódus,függvény stb éppen milyen láthatósági körben szerepel.
            Az osztály konstruktorában inicializáljuk a csomópontot és a fa magasságát és a fa kezdetét ráállítsuk a csomópontra. Ugyanis innen fogunk indulni.
            Emellett csinálunk egy olyan Node típúsú függvényt, amely mindig a root-ot fogja visszaadni. Az épp bemenő értékeket a metódusokban és a Node konstruktorában is jelzett Node típúsú rhs objektumba adjuk át. A write függvénnyel írjuk be a bemenő értékeket a fába. Ha a bemenő karakter 0, akkor megnézzük van -e érték a bal oldalon, ha nincs akkor létrehozunk egyet azaz beírjuk a 0-ást a fába.
            Egyébként ha van akkor rálépünk arra a csomópontra és nézzük a következő karaktert. Ugyan ez fut le akkor is ha 1-es érték megy be a fába csak logikusan ott a jobb oldalt vizsgáljuk. A writeout metódussal fogjuk kiiratni a fánkat.Ezen kívül még vannak a mélység,átlag,szórás számoló függvényeink.
            Legutolsó sorban nézzük meg a <classname>main</classname> osztályunkat. Itt láthatjuk, hogy String args-t vizsgálunk. Ugyanis a binfának megkell adni egy bemenetet és egy kimenetet. Ha tehát az argumentumaink száma kisebb mint 2 akkor hibát iratunk ki. Majd létrehozunk egy filereadert és példányosítjuk a Binfánkat bt néven.Majd a while függvénnyel olvassuk ki a bemenő file-ból az adatokat kihagyva pár karaktert például a spaceeket. Végül a 2. megadott argumentumunkba beírjuk a kimenetet.
        </para>
        <programlisting language="java"><![CDATA[
            class BinTree{
            private final Node root;
            private Node current;
            private int treeHeight;
            private int melyseg, maxMelyseg, atlagosszeg, atlagdb;
            private double atlag,szorasosszeg, szoras;
            
            
            public BinTree(){
                root = new Node('/');
                current = root;
                treeHeight = -1;
            }

            public Node getRoot(){
                return root;
            }
            public void setCurrent(Node rhs){
                current = rhs;
            }
            
            public void write(char b){
                if(b == '0'){
                    if(current.getLeft() == null){
                        current.setLeft(new Node('0'));
                        setCurrent(root);
                    }
                    else{
                        setCurrent(current.getLeft());
                    }
                }
                
                if(b == '1'){
                    if(current.getRight() == null){
                        current.setRight(new Node('1'));
                        setCurrent(root);
                    }
                    else{
                        setCurrent(current.getRight());
                    }
                }	
            }
            
            
            public void writeOut(Node n, PrintWriter pw){
                if(n != null)
                {
                    ++treeHeight;
                    
                    writeOut(n.getLeft(),pw);
                    
                    for(int i = 0; i < treeHeight; i++){
                        pw.print('-');
                    }
                    
                    pw.println(n.getNode() + " (" + treeHeight + ")");
                    
                    writeOut(n.getRight(),pw);
                    --treeHeight;
                }
            }	
        }
          ]]>
        </programlisting>
        <figure>
             <title>Binfa Servlet indexpage</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/servlet.png" scale="30" />
                </imageobject>
        </mediaobject>
        </figure>
        <programlisting language="html"><![CDATA[
        <!DOCTYPE html>

        <html>
            <body>
                <h2>BinfaInput</h2>
        <form action="nemesis" method="get">
            <input type="text" name="text"/>
            <input type="submit" value="Submit"/>
        </form>
            </body>
        </html>

          ]]>
        </programlisting>
        <figure>
             <title>Binfa Servlet after run</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/servlet2.png" scale="30" />
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            A binfa szervlet megvalósításához a netbeans ide-t használtam. A servlethez a binfa <classname>main</classname> osztályát kellett áthelyezni. Ehhez az osztálynak örökölnie kellett a HttpServlet tulajdonságait és Override-olni a doGet függvényt, amelynek a két paramétere a request és a response, na meg persze importolni a servlet könyvtárakat. A request el kapom meg az értéket a címsorból és a response-val tudok majd válaszolni tehát kiiratni majd.
        </para>
        <programlisting language="java"><![CDATA[
            @WebServlet(name = "nemesis", urlPatterns = {"/nemesis"})
            public class nemesis extends HttpServlet {

            @Override
            public void doGet(HttpServletRequest request, HttpServletResponse response)
          ]]>
        </programlisting>
        <para>
            Lényegében a böngésző címsorából adom meg a bemenetet a binfának. A request.getParameter el és ennek a zárójelben megadott paramétere hivatkozik az indexben megadott inputra.Tehát a textboxra.
        </para>
        <programlisting language="java"><![CDATA[
        response.setContentType("text/html");    
    
        String bemenet = request.getParameter("text");
          ]]>
        </programlisting>
    <para>
            És a kimenetnél történt változásnál a setContentType-nál állítjuk be, hogy milyen típúsú választ akarunk küldeni a kliensnek itt most jelenleg text/html.Majd a response.getWriterrel küldjük át a kliensnek a választ és a out.println-al építjük fel a html lapot, amit a kliens fog megkapni.
            A szerverhez Tomcatet használtam. Amit az IDE-ben nagyon könnyű behúzni a projektbe. De ha maven projektet csinálunk akkor a pom.xml-ben is tudjuk pluginként behúzni.
        </para>
        <programlisting language="xml"><![CDATA[
            <plugin>
                <groupId>org.apache.tomcat.maven</groupId>
                <artifactId>tomcat7-maven-plugin</artifactId>
                <version>2.2</version>
                <configuration>
                    <path>/binfa</path>
                </configuration>
            </plugin>
            A futtatás ilyenkor mvn clean package tomcat7:run- al történik.
          ]]>
        </programlisting>
    </section>        
    <section>
        <title>"Gagyi"</title>
        <para>
            Az ismert formális 2 tesztkérdéstípusra adj a szokásosnál
            (miszerint x, t az egyik esetben az objektum által hordozott érték, a másikban meg az objektum
            referenciája) „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x, t
            értékekkel meg nem! A példát építsd a JDK Integer.java forrására 3 , hogy a 128-nál inkluzív objektum
            példányokat poolozza!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Gagyi">https://github.com/Savitar97/Prog2/tree/master/Gagyi</link>                
        </para>
        <programlisting language="java"><![CDATA[
        90:   // This caches some Integer values, and is used by boxing
        91:   // conversions via valueOf().  We must cache at least -128..127;
        92:   // these constants control how much we actually cache.
        93:   private static final int MIN_CACHE = -128;
        94:   private static final int MAX_CACHE = 127;
        95:   private static Integer[] intCache = new Integer[MAX_CACHE - MIN_CACHE + 1];
        305:   public static Integer valueOf(int val)
        306:   {
        307:     if (val < MIN_CACHE || val > MAX_CACHE)
        308:       return new Integer(val);
        309:     synchronized (intCache)
        310:       {
        311:     if (intCache[val - MIN_CACHE] == null)
        312:       intCache[val - MIN_CACHE] = new Integer(val);
        313:     return intCache[val - MIN_CACHE];
        314:       }
        315:   }

        private static class IntegerCache {
        private IntegerCache(){}

        static final Integer cache[] = new Integer[-(-128) + 127 + 1];

        static {
            for(int i = 0; i < cache.length; i++)
                cache[i] = new Integer(i - 128);
        }
        }

        public static Integer valueOf(int i) {
        final int offset = 128;
        if (i >= -128 && i <= 127) { // must cache
            return IntegerCache.cache[i + offset];
        }
        return new Integer(i);
        }
        jdk/src/share/classes/java/lang
          ]]>
        </programlisting> 
        <para>
            Mivel a cache-nek a mérete -128 és 127 közé esik,így ha az objektumunk ebből a tartományból vesz fel értéket akkor az <classname>Integer</classname> osztály valueof(int val) függvénye fog lefutni,tehát a cache-en belül poolozza az Integer objektumokat(azaz nem hoz létre új objektumot, hanem ugyan azt használja fel, referenciára hivatkozik).
            Tehát az előltesztelős ciklusunknak a feltétele egyből teljesül és kilép. Viszont, ha ezen a tartományon kívül veszünk fel értéket akkor a valueof új Integer objektumot hoz létre, ezért false eredményt kapunk és végtelen ciklusunk lesz.
            Ez egy memória megtakarító és teljesítmény növelő funkció, amit autoboxingnak neveznek. Tehát a poolozás miatt a két objektumnak ugyan az lesz a referenciája,ezt megkerülhetjük ha new-al hozzuk létre.
        </para>
        <programlisting language="java"><![CDATA[
        Integer x = 128;
        Integer t = 128;
        while (x <= t && x >= t && t != x)
            { System.out.println("Gagyi");  }
        System.out.println("Gagyi vége"); 
            
            ]]>
        </programlisting>
        <programlisting language="java"><![CDATA[
        De akkor is végtelen ciklust kapunk ha a new kulcsszóval hozzuk létre az objektumokat mert akkor nem a valueof true ága fut végig.
        Integer x = new Integer(127);
        Integer t = new Integer(127);
        while (x <= t && x >= t && t != x)
            { System.out.println("Gagyi");  }
        System.out.println("Gagyi vége"); 
          ]]>
        </programlisting>
        <figure>
             <title>Végtelen ciklus 128-nál</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Gagyi.png" scale="200" />
                </imageobject>
        </mediaobject>
        </figure>
        <programlisting language="java"><![CDATA[
        Integer x = 127;
        Integer t = 127;
        while (x <= t && x >= t && t != x)
            { System.out.println("Gagyi");  }
        System.out.println("Gagyi vége"); 
          ]]>
        </programlisting>
        <figure>
             <title>Leállás 127-nél</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Gagyi1.png" scale="200" />
                </imageobject>
        </mediaobject>
        </figure>
    </section>
    <section>
        <title>Yoda</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Yoda">https://github.com/Savitar97/Prog2/tree/master/Yoda</link>               
        </para>
        <para>
            A Yoda condition a nevét a Starwars karakteréről kapta, aki elég egyedi angolnyelvi szintaxisával is kitűnt a sorozatból ez az egyedi szintaxis az volt, hogy az alany->ige->tárgyat felcserélte tárgy->alany->igére.
            A Yoda condition lényege az, hogy egy ekvivalenciánál a konstanst nem a megszokott jobb oldalára írjuk az ekvivalenciának, hanem a bal oldalra.
            Ezt általában stringeknél használjuk,de nem feltétlenül. Tehát nem az objektumunkat hasonlítsuk össze a stringgel, hanem a stringet az objektumunkkal.
            Az előnye a feltétel betartásának az, hogy elkerüljük a NullPointerExceptions-t.Viszont a hátránya az, hogy a kód olvasását nehezebbé teszi.
            Ugyanis ilyenkor jobbról balra érdemesebb olvasnunk a feltételeket. Viszont ezen kívül még, megkímélhetjük magunkat az == helyett = operátor hibától. A yoda conditiont még az equal el szoktuk használni.
            
        </para>
        <programlisting language="java"><![CDATA[
            String rand= null;
		    if(rand.equals("foo")){
			System.out.println(rand);
		}

          ]]>
        </programlisting>
        <figure>
             <title>NullPointExeption</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Yoda.png" scale="200" />
                </imageobject>
        </mediaobject>
        </figure>
        
        <figure>
             <title>Yoda Condition nem kap errort</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Yoda2.png" scale="200" />
                </imageobject>
        </mediaobject>
        </figure>
        <programlisting language="java"><![CDATA[
            String rand= null;
		    if("foo".equals(rand)){
			System.out.println(rand);
		}

          ]]>
        </programlisting>
    </section>
    <section>
        <title>Kódolás from scratch</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Scratch">https://github.com/Savitar97/Prog2/tree/master/Scratch</link>               
        </para>
        <para>
            A BBP algoritmus a 20. század egyik legfontosabb felfedezése volt. Segítségével kiszámolhatjuk a pi-nek a d+1-dik jegyének a hexadecimális értéket úgy, hogy a megelőző jegyek nem kell kiszámolni.
            Kezdetben létrehozunk egy osztályt a <classname>PiBBP</classname> algoritmusnak. A BBP algoritmus alapján:
        </para>
        <programlisting language="java"><![CDATA[
        {16^d Pi} = {4*{16^d S1} - 2*{16^d S4} - {16^d S5} - {16^d S6}}
          ]]>
        </programlisting>
        <para>
            Természetesen a {}- a törtrészét jelöli. Tehát  a konstruktorunknak van egy paramétere a d. Majd létrehozzuk a változókat. Kezdetben a d16pi-t.Kezdőértékül a 0.0d-vel jelöljük, hogy double lesz az értéke. Az S1,S4,S5,S6-nak metódussal(függvénnyel) számoljuk az értékét.
            d16Pi-értékét a fenti képlet alapján számoljuk. Majd a kiszámított értékből kivonjuk a lefelé kerekített értékét a d16Pi-nek ezzel elérve, hogy 0 és 1 közé essen d16Pi értéke. A végeredmény építéséhez a StringBuffert használjuk. A hexajegyek tömböt használjuk, hogy a 10 feletetti értéket helyettesítsük.
            Mivel a 16-os számrendszerben a 10-es számjegy az A például és egészen F-ig megy. Majd létrehozunk egy while ciklust, ami addig megy ameddig a d16pi értéke nem lesz 0-val egyenlő.Itt elvégzünk egy típuskényszerítést és egy lefelé kerekítést a d16Pi-n és letároljuk a jegy-be.Ugyebár ha a jegy 10-nél kisebb nem kell vele semmit csinálnunk.
            Viszont ha 10 vagy ettől nagyobb, akkor a visszaadott értéket a hexajegyekből választjuk. Ugyebár ha 10 et kapunk például eredményül akkor abból kivonva 10-et megkapjuk a 0. indexű elemet a tömbben. Ezt használjuk itt ki.
            Majd a végén a toString metódussal létrehozzuk a stringet, amit mi hoztunk létre a biztonság kedvéért, pedig minden osztálynak van toString metódusa javaban.
        </para>
        <programlisting language="java"><![CDATA[
        public PiBBP(int d) {
        
        double d16Pi = 0.0d;
        
        double d16S1t = d16Sj(d, 1);
        double d16S4t = d16Sj(d, 4);
        double d16S5t = d16Sj(d, 5);
        double d16S6t = d16Sj(d, 6);
        
        d16Pi = 4.0d*d16S1t - 2.0d*d16S4t - d16S5t - d16S6t;
        
        d16Pi = d16Pi - StrictMath.floor(d16Pi);
        
        StringBuffer sb = new StringBuffer();
        
        Character hexaJegyek[] = {'A', 'B', 'C', 'D', 'E', 'F'};
        
        while(d16Pi != 0.0d) {
            
            int jegy = (int)StrictMath.floor(16.0d*d16Pi);
            System.out.println(jegy);
            if(jegy<10)
                sb.append(jegy);
            else
                sb.append(hexaJegyek[jegy-10]);
            
            d16Pi = (16.0d*d16Pi) - StrictMath.floor(16.0d*d16Pi);
        }
        
        d16PiHexaJegyek = sb.toString();
        System.out.println("S1:"+d16S1t+" "+"S2:"+d16S4t+" "+"S3:"+d16S5t+" "+"S4:"+d16S6t);
    }
          ]]>
        </programlisting>
        <para>
            Mint az elején már mondtam az S1,S4,S5,S6-ot függvénnyel számoljuk ez a következő függvény,2 argumentuma van, a d szám ismét azaz amit megadunk és a j, ami (1,4,5,6):
        </para>
        <programlisting language="java"><![CDATA[
            public double d16Sj(int d, int j) {
        
            double d16Sj = 0.0d;
            
            for(int k=0; k<=d; ++k)
                d16Sj += (double)n16modk(d-k, 8*k + j) / (double)(8*k + j);
                return d16Sj - StrictMath.floor(d16Sj);
            }
          ]]>
        </programlisting>
        <para>
            A d16Sj-nél még egy függvényt használunk,amely szintén 2 paraméteres ezzel számoljuk a 16^n mod k-t.Ugyebár n a kitevő és k a modulus.
        </para>
        <programlisting language="java"><![CDATA[
            public long n16modk(int n, int k) {
        
                int t = 1;
                while(t <= n)
                    t *= 2;
                
                long r = 1;
                
                while(true) {
                    
                    if(n >= t) {
                        r = (16*r) % k;
                        n = n - t;
                    }
                    
                    t = t/2;
                    
                    if(t < 1)
                        break;
                    
                    r = (r*r) % k;
                    
                }
                
                return r;
            }
          ]]>
        </programlisting>
        <para>
            A végeredmény nem lett teljesen jó sajnos.6C65E52CB459350050E4BB1 helyett 6C65E5308 jött ki. A d=1000001 értéknél.
        </para>
        <figure>
             <title>Scratch</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Scratch.png" scale="200" />
                </imageobject>
        </mediaobject>
        </figure>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
