<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>
            A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá,
            hogy a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elő, kell egy
            példánytag, amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell
            az algot.) és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
            https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf (16-22 fólia)
            Ugyanezt írjuk meg C++ nyelven is! (lásd még UDPROG repó: source/labor/polargen)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/polar">https://github.com/Savitar97/Prog1/tree/master/polar</link>              
        </para>
        <para>
            A polargenünk két előállított normálisa a v1 és v2 változó. A példánytagunk, amely a nem visszaadottat tárolja az a tarolt nevű változó.
            A logikai tagunk a nincsTarolt változó ezt igazról indítjuk, mivel az elején még nincs érték a tarolt nevű változónkban.
            </para>
            <programlisting language="java"><![CDATA[
            boolean nincsTarolt = true;
    double tarolt;

    public PolarGen () {

        nincsTarolt = true;

    }
          ]]>
        </programlisting>
            <para>
            Tehát elsőnek az if águnknak a true ága fog lefutni elsőként.
            Itt addig fut a do while ciklusunk, amíg a w változó értéke nem lesz 1-nél nagyobb. Majd számolunk egy r-t. A tarolt változónkba letároljuk az r*v2-t. Majd a nincsTarolt-at false-ra állítjuk és kiiratjuk a nem tárolt normálist az r*v1-et.
            Következő futtatásnál az ifnek a hamis ága fog lefutni. Tehát a letárolt értéket fogja kiiratni a program és a nincsTaroltat újra true-ra állítjuk, hogy új két normálist számoljon a programunk. A konstruktorban inicializáljuk a nincsTaroltat, hogy minden egyes objektum példányosításnál true értéket vegyen fel a nincsTarolt változó.    
        </para>
        <programlisting language="java"><![CDATA[
            public double kovetkezo () {

        if (nincsTarolt) {

            double u1, u2, v1, v2, w;
            do
            {
                u1 = Math.random();
                u2 = Math.random();
                v1 = 2 * u1 - 1;
                v2 = 2 * u2 - 1;
                w = v1 * v1 + v2 * v2;
            }
            while (w > 1);

            double r = Math.sqrt ((-2 * Math.log (w)) / w);

            tarolt = r * v2;
            nincsTarolt = !nincsTarolt;

            return r * v1;
        }
        else
        {
            nincsTarolt = !nincsTarolt;
            return tarolt;
        }

    }

          ]]>
        </programlisting>
        <figure>
             <title>Polargen random</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/polargen.png" scale="30" />
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            A C++-os verziónál a header file-ban írjuk meg a PolarGen osztályunkat. Az osztálynak itt nem csak a konstruktorát kell megírni, de a destruktorát is. Javaval ellentétben, ugyanis ott a garbage collector elvégzi a munkát, tehát nekünk nem szükséges definiálnunk.
            Az osztály kovetkezo nevű függvényét mivel kívülről hívtuk meg, ezért a ::-t kell használnunk, amely mutatja melyik osztály hatáskörébe tartozik. A felépítés a Java-s hoz képest nem sokat változott. A különbség annyiban szenbetűnő, hogy a java erősen objektum orientált, míg a C++-ban lehetőségünk van ettől eltérni.
            A példányosításnál is látunk minimális különbséget ugyanis a javaban mindig a new kulcsszót kell használnunk, míg C++-ban elég az osztály nevét és az objektum nevét megadni.
            
        </para>
    </section>        

    <section>
        <title>Homokozó</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Binfa">https://github.com/Savitar97/Prog2/tree/master/Binfa</link>              
        </para>
        <para>
            Servlet megoldása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/WebApplication1">https://github.com/Savitar97/Prog2/tree/master/WebApplication1</link>
        </para>
        <para>
            A binfa java a c++-hoz képest nem sokat változik. A különbség annyi, hogy itt nem választhatunk, hogy tagként,referenciaként vagy esetleg pointerként adjuk át a csomópontot.
            Ugyanis a javaban nincsenek pointerek. A létrehozott Node osztály azaz a csomópont osztály tartalmaz egy érték változót és egy jobb és egy bal oldali objektumát a csomópontnak.
            Ezen kívül tartalmazza a jobb és baloldali csomópontok értékének lekérdezéséhez szükséges get függvényeket és az értékek beállításához szükséges set függvényeket, ezen kívül a csomópont értékének lekérdezéséhez szükséges get függvény.
            </para>
        <programlisting language="java"><![CDATA[
        class Node {
	private char value;
	private Node left;
	private Node right;
	
	public Node(char rhs){
		value = rhs;
		left = null;
		right = null;
	}
	
	
	public char getNode(){
		return value;
	} 
	
	public void setLeft(Node rhs){
		left = rhs;
	}
	
	public void setRight(Node rhs){
		right = rhs;
	}
	
	public Node getLeft(){
		return left;
	}
	
	public Node getRight(){
		return right;
	}
	
}
          ]]>
        </programlisting>
            <para>
            Most nézzük a binfa osztályt. Először is létrehozunk egy final kulcsszóval ellátott Node objektumot a root-ot, ez lesz a fánknak a gyökere. Tehát ennek az értéke nem változik fix marad az egész program futása során. Ezen kívül létrehozzuk a csomópontnak a jelenlegi objektumát amibe, majd az értéket pakoljuk, ami éppen jön a bemenetről.
            Emellett itt definiáljuk az átlaghoz,mélységhez,magassághoz és szóráshoz szükséges változókat private kulcsszóval. Javaban látszik, hogy nem private blokk van, hanem mindig jelezni kell, hogy az a változó,metódus,függvény stb éppen milyen láthatósági körben szerepel.
            Az osztály konstruktorában inicializáljuk a csomópontot és a fa magasságát és a fa kezdetét ráállítsuk a csomópontra. Ugyanis innen fogunk indulni.
            Emellett csinálunk egy olyan Node típúsú függvényt, amely mindig a root-ot fogja vissza adni. Az épp bemenő értékeket a metódusokban és a Node konstruktorában is jelzett Node típúsú rhs objektumba adjuk át. A write függvénnyel írjuk be a bemenő értékeket a fába. Ha a bemenő karakter 0, akkor megnézzük van -e érték a bal oldalon, ha nincs akkor létrehozunk egyet azaz beírjuk a 0-ást a fába.
            Egyébként ha van akkor rálépünk arra a csomópontra és nézzük a következő karaktert. Ugyan ez fut le akkor is ha 1-es érték megy be a fába csak logikusan ott a jobb oldalt vizsgáljuk. A writeout metódussal fogjuk kiiratni a fánkat.Ezen kívül még vannak a mélység,átlag,szórás számoló függvényeink.
            Legutolsó sorban nézzük meg a main osztályunkat. Itt láthatjuk, hogy String args-t vizsgálunk. Ugyanis a binfának megkell adni egy bemenetet és egy kimenetet. Ha tehát az argumentumaink száma kisebb mint 2 akkor hibát iratunk ki. Majd létrehozunk egy filereadert és példányosítjuk a Binfánkat bt néven.Majd a while függvénnyel olvassuk ki a bemenő file-ból az adatokat kihagyva pár karaktert például a spaceeket. Végül a 2. megadott argumentumunkba beírjuk a kimenetet.
        </para>
        <programlisting language="java"><![CDATA[
            class BinTree{
	private final Node root;
	private Node current;
	private int treeHeight;
	private int melyseg, maxMelyseg, atlagosszeg, atlagdb;
	private double atlag,szorasosszeg, szoras;
	
	
	public BinTree(){
		root = new Node('/');
		current = root;
		treeHeight = -1;
	}

	public Node getRoot(){
		return root;
	}
	public void setCurrent(Node rhs){
		current = rhs;
	}
	
	public void write(char b){
		if(b == '0'){
			if(current.getLeft() == null){
				current.setLeft(new Node('0'));
				setCurrent(root);
			}
			else{
				setCurrent(current.getLeft());
			}
		}
		
		if(b == '1'){
			if(current.getRight() == null){
				current.setRight(new Node('1'));
				setCurrent(root);
			}
			else{
				setCurrent(current.getRight());
			}
		}	
	}
	
	
	public void writeOut(Node n, PrintWriter pw){
		if(n != null)
		{
			++treeHeight;
			
			writeOut(n.getLeft(),pw);
			
			for(int i = 0; i < treeHeight; i++){
				pw.print('-');
			}
			
			pw.println(n.getNode() + " (" + treeHeight + ")");
			
			writeOut(n.getRight(),pw);
			--treeHeight;
		}
	}	
}
          ]]>
        </programlisting>
        <figure>
             <title>Binfa Servlet indexpage</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/servlet.png" scale="30" />
                </imageobject>
        </mediaobject>
        </figure>
        <programlisting language="html"><![CDATA[
        <!DOCTYPE html>

<html>
    <body>
        <h2>BinfaInput</h2>
<form action="nemesis" method="get">
    <input type="text" name="text"/>
    <input type="submit" value="Submit"/>
</form>
    </body>
</html>

          ]]>
        </programlisting>
        <figure>
             <title>Binfa Servlet after run</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/servlet2.png" scale="30" />
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            A binfa szervlet megvalósításához a netbeans ide-t használtam. A servlethez a binfa main osztályát kellett áthelyezni. Ehhez az osztálynak örökölnie kellett a HttpServlet tulajdonságait és Override-olni a doGet függvényt, amelynek a két paramétere a request és a response, na meg persze importolni a servlet könyvtárakat.
        </para>
        <programlisting language="java"><![CDATA[
            @WebServlet(name = "nemesis", urlPatterns = {"/nemesis"})
public class nemesis extends HttpServlet {

   @Override
public void doGet(HttpServletRequest request, HttpServletResponse response)
          ]]>
        </programlisting>
        <para>
            Lényegében a böngésző címsorából adom meg a bemenetet a binfának. A request.getParameter el és ennek a zárójelben megadott paramétere hivatkozik az indexben megadott inputra.Tehát a textboxra.
        </para>
        <programlisting language="java"><![CDATA[
        response.setContentType("text/html");    
    
        String bemenet = request.getParameter("text");
          ]]>
        </programlisting>
    <para>
            És a kimenetnél történt változásnál a setContentType-nál állítjuk be, hogy milyen típúsú választ akarunk küldeni a kliensnek itt most jelenleg text/html.Majd a response.getWriterrel küldjük át a kliensnek a választ és a out.println-al építjük fel a html lapot, amit a kliens fog megkapni.
            A szerverhez Tomcatet használtam. Amit az IDE-ben nagyon könnyű behúzni a projektbe.
        </para>
    </section>        
    <section>
        <title>"Gagyi"</title>
        <para>
            Az ismert formális 2 tesztkérdéstípusra adj a szokásosnál
            (miszerint x, t az egyik esetben az objektum által hordozott érték, a másikban meg az objektum
            referenciája) „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x, t
            értékekkel meg nem! A példát építsd a JDK Integer.java forrására 3 , hogy a 128-nál inkluzív objektum
            példányokat poolozza!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Gagyi">https://github.com/Savitar97/Prog2/tree/master/Gagyi</link>                
        </para>
        <programlisting language="java"><![CDATA[
 90:   // This caches some Integer values, and is used by boxing
 91:   // conversions via valueOf().  We must cache at least -128..127;
 92:   // these constants control how much we actually cache.
  93:   private static final int MIN_CACHE = -128;
  94:   private static final int MAX_CACHE = 127;
  95:   private static Integer[] intCache = new Integer[MAX_CACHE - MIN_CACHE + 1];
 305:   public static Integer valueOf(int val)
 306:   {
 307:     if (val < MIN_CACHE || val > MAX_CACHE)
 308:       return new Integer(val);
 309:     synchronized (intCache)
 310:       {
 311:     if (intCache[val - MIN_CACHE] == null)
 312:       intCache[val - MIN_CACHE] = new Integer(val);
 313:     return intCache[val - MIN_CACHE];
 314:       }
 315:   }
          ]]>
        </programlisting> 
        <para>
            Mivel a cache-nek a mérete -128 és 127 közé esik,így ha az objektumunk ebből a tartományból vesz fel értéket akkor az Integer osztály valueof(int val) függvénye fog lefutni,tehát a cache-en belül poolozza az Integer objektumokat.
            Tehát az előltesztelős ciklusunknak a feltétele egyből teljesül és kilép. Viszont, ha ezen a tartományon kívül veszünk fel értéket akkor a valueof új Integer objektumot hoz létre, ezért false eredményt kapunk és végtelen ciklusunk lesz.
            Ez egy memória megtakarító és teljesítmény növelő funkció, amit autoboxingnak neveznek. Tehát a poolozás miatt a két objektumnak ugyan az lesz a referenciája,ezt megkerülhetjük ha new-al hozzuk létre.
        </para>
        <programlisting language="java"><![CDATA[
        Integer x = 128;
	Integer t = 128;
	while (x <= t && x >= t && t != x)
		{ System.out.println("Gagyi");  }
	System.out.println("Gagyi vége"); 
        
          ]]>
        </programlisting>
        <programlisting language="java"><![CDATA[
        De akkor is végtelen ciklust kapunk ha a new kulcsszóval hozzuk létre az objektumokat mert akkor nem a valueof true ága fut végig.
        Integer x = new Integer(127);
	Integer t = new Integer(127);
	while (x <= t && x >= t && t != x)
		{ System.out.println("Gagyi");  }
	System.out.println("Gagyi vége"); 
          ]]>
        </programlisting>
        <figure>
             <title>Végtelen ciklus 128-nál</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Gagyi.png" scale="200" />
                </imageobject>
        </mediaobject>
        </figure>
        <programlisting language="java"><![CDATA[
        Integer x = 127;
	Integer t = 127;
	while (x <= t && x >= t && t != x)
		{ System.out.println("Gagyi");  }
	System.out.println("Gagyi vége"); 
          ]]>
        </programlisting>
        <figure>
             <title>Leállás 127-nél</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Gagyi1.png" scale="200" />
                </imageobject>
        </mediaobject>
        </figure>
    </section>
    <section>
        <title>Yoda</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A Yoda condition a nevét a Starwars karakteréről kapta, aki elég egyedi angolnyelvi szintaxisával is kitűnt a sorozatból ez az egyedi szintaxis az volt, hogy az alany->ige->tárgyat felcserélte tárgy->alany->igére.
            A Yoda condition lényege az, hogy egy ekvivalenciánál a konstanst nem a megszokott jobb oldalára írjuk az ekvivalenciának, hanem a bal oldalra.
            Ezt általában stringeknél használjuk,de nem feltétlenül. Tehát nem az objektumunkat hasonlítsuk össze a stringgel, hanem a stringet az objektumunkkal.
            Az előnye a feltétel betartásának az, hogy elkerüljük a NullPointerExceptions-t.Viszont a hátránya az, hogy a kód olvasását nehezebbé teszi.
            Ugyanis ilyenkor jobbról balra érdemesebb olvasnunk a feltételeket. Viszont ezen kívül még, megkímélhetjük magunkat az == helyett = operátor hibától. A yoda conditiont még az equal el szoktuk használni.
            
        </para>
        <programlisting language="java"><![CDATA[
            String rand= null;
		if(rand.equals("foo")){
			System.out.println(rand);
		}

          ]]>
        </programlisting>
        <figure>
             <title>NullPointExeption</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Yoda.png" scale="200" />
                </imageobject>
        </mediaobject>
        </figure>
        
        <figure>
             <title>Yoda Condition nem kap errort</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Yoda2.png" scale="200" />
                </imageobject>
        </mediaobject>
        </figure>
        <programlisting language="java"><![CDATA[
            String rand= null;
		if("foo".equals(rand)){
			System.out.println(rand);
		}

          ]]>
        </programlisting>
    </section>
    <section>
        <title>Kódolás from scratch</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
