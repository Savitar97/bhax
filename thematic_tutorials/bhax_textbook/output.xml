<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">    
    
    <info xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">

    <title xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Univerzális programozás</title>               

    <subtitle xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Írd meg a saját programozás tankönyvedet!</subtitle>               

    <titleabbrev xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX KÖNYV</titleabbrev>               

    <authorgroup xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <author>
        <personname>
            <honorific>Dr.</honorific>
            <surname>Bátfai</surname>
            <firstname>Norbert</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>E. adjunktus, DE.</shortaffil>
            <jobtitle>Egyetemi adjunktus</jobtitle>
            <orgname>Debreceni Egyetem</orgname>
            <orgdiv>Információtechnológiai Tanszék</orgdiv>
            <address>
                <email>batfai.norbert@inf.unideb.hu</email>
                <email>nbatfai@gmail.com</email>
            </address>
        </affiliation>
        <address>
            <street>Kassai út 26.</street>
            <city>Debrecen</city>
            <postcode>4028</postcode>
            <country>Magyarország</country>
            <email>batfai.norbert@inf.unideb.hu</email>
            <otheraddr>
                <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/">https://arato.inf.unideb.hu/batfai.norbert/</link>
            </otheraddr>
        </address>
    </author>
	<author>
        <personname>
            <surname>Tóth</surname>
            <firstname>Attila</firstname>        
        </personname>    
        <affiliation>
            <jobtitle>Hallgató</jobtitle>
            <orgname>Debreceni Egyetem</orgname>
            <orgdiv>Informatikai kar</orgdiv>
            <address>
                <email>atoth1571@gmail.com</email>
            </address>
        </affiliation>
        <address>
            <city>Tarpa</city>
            <postcode>4931</postcode>
            <country>Magyarország</country>
            <email>atoth1571@gmail.com</email>
        </address>
        </author>  
</authorgroup>               

    <edition xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX, DEBRECEN, 2019. május 8, v. 0.0.6</edition>               

    <pubdate>2019</pubdate>
    <copyright>
        <year>2019</year>
        <holder>Dr. Bátfai Norbert,Tóth Attila</holder>
    </copyright>
    <legalnotice>           
        <para>                
            Copyright (C) 2019, Norbert Bátfai Ph.D., batfai.norbert@inf.unideb.hu, nbatfai@gmail.com,Attila Tóth, atoth1571@gmail.com
        </para>
        <para>
            Permission is granted to copy, distribute and/or modify this document
            under the terms of the GNU Free Documentation License, Version 1.3
            or any later version published by the Free Software Foundation;
            with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
            A copy of the license is included in the section entitled "GNU
            Free Documentation License".                
        </para>
        <para>
            <link xlink:href="https://www.gnu.org/licenses/fdl.html">https://www.gnu.org/licenses/fdl.html</link>                
        </para>
            
        <para>
            Engedélyt adunk Önnek a jelen dokumentum sokszorosítására, terjesztésére és/vagy módosítására 
            a Free Software Foundation által kiadott GNU FDL 1.3-as, vagy bármely azt követő verziójának 
            feltételei alapján. Nincs Nem Változtatható szakasz, nincs Címlapszöveg, nincs Hátlapszöveg.                
        </para>
        <para>
            <link xlink:href="http://gnu.hu/fdl.html">http://gnu.hu/fdl.html</link>                
        </para>
    </legalnotice>   
    
    <revhistory xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <revision>
        <revnumber>0.0.1</revnumber>
        <date>2019-02-12</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Az iniciális dokumentum szerkezetének kialakítása.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.2</revnumber>
        <date>2019-02-14</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Inciális feladatlisták összeállítása.
        </revremark>
    </revision>    
    <revision>
        <revnumber>0.0.3</revnumber>
        <date>2019-02-16</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Feladatlisták folytatása.
            Feltöltés a BHAX csatorna 
            <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
            repójába.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.4</revnumber>
        <date>2019-02-19</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Aktualizálás, javítások.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.5</revnumber>
        <date>2019-05-02</date>
        <authorinitials>T.Attila</authorinitials>
        <revremark>
            Feladatok kész.Utómunkállatok szükségesek még,bővítés és ellenőrzés.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.6</revnumber>
        <date>2019-05-08</date>
        <authorinitials>T.Attila</authorinitials>
        <revremark>
            Ábrák felcímzése, ábrajegyzék kész.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.7</revnumber>
        <date>2019-09-18</date>
        <authorinitials>T.Attila</authorinitials>
        <revremark>
            Olvasónapló leadva.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.8</revnumber>
        <date>2019-09-25</date>
        <authorinitials>T.Attila</authorinitials>
        <revremark>
            Első csokor leadva.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.9</revnumber>
        <date>2019-10-2</date>
        <authorinitials>T.Attila</authorinitials>
        <revremark>
            Második csokor leadva.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.0</revnumber>
        <date>2019-10-9</date>
        <authorinitials>T.Attila</authorinitials>
        <revremark>
            Harmadik csokor leadva.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.1</revnumber>
        <date>2019-10-16</date>
        <authorinitials>T.Attila</authorinitials>
        <revremark>
            Negyedik csokor leadva.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.2</revnumber>
        <date>2019-10-23</date>
        <authorinitials>T.Attila</authorinitials>
        <revremark>
            Ötödik csokor leadva.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.1.3</revnumber>
        <date>2019-11-6</date>
        <authorinitials>T.Attila</authorinitials>
        <revremark>
            Hatodik csokor leadva.
        </revremark>
    </revision>
</revhistory>               
                               
</info>     
        
    <dedication xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>

    </para>
<blockquote>
    <attribution>Gregory Chaitin, <citetitle>META MATH! The Quest for Omega</citetitle>, <citation>METAMATH</citation></attribution>
    <para>
        „To me, you understand something only if you can program it.  
        (You, not someone else!)  Otherwise you don’t really understand it, 
        you only think you understand it.”
    </para>
</blockquote>
</dedication>     
    
    <preface xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Előszó</title>
    <para xml:id="bhax-textbook-pre.Eloszo">
        Amikor programozónak terveztem állni, ellenezték a környezetemben, mondván, hogy kell  
        szövegszerkesztő meg táblázatkezelő, de az már van... nem lesz programozói munka.
    </para>                 
    <para>
        Tévedtek. Hogy egy generáció múlva kell-e még tömegesen hús-vér programozó vagy
        olcsóbb lesz allokálni igény szerint pár robot programozót a felhőből?
        A programozók dolgozók lesznek vagy papok?
        Ki tudhatná ma. 
    </para>
    <para>
        Mindenesetre a programozás a teoretikus kultúra csúcsa. A GNU mozgalomban látom annak 
        garanciáját, hogy ebben a szellemi kalandban a gyerekeim is részt vehessenek majd. Ezért programozunk.
    </para>          
    <section>
        <title>Hogyan forgasd</title>
        <para>
            A könyv célja egy stabil programozási szemlélet kialakítása az olvasóban. Módszere, hogy hetekre 
            bontva ad egy tematikus feladatcsokrot. Minden feladathoz megadja a megoldás forráskódját és forrásokat
            feldolgozó videókat.
            Az olvasó feladata, hogy ezek tanulmányozása után maga adja meg a feladat megoldásának lényegi
            magyarázatát, avagy írja meg a könyvet.
        </para>
        <para>
            Miért univerzális? Mert az olvasótól (kvázi az írótól) függ, hogy kinek szól a könyv. 
            Alapértelmezésben gyerekeknek, mert velük készítem az iniciális változatot. 
            Ám tervezem felhasználását az egyetemi programozás oktatásban is. Ahogy szélesedni tudna a 
            felhasználók köre, akkor lehetne kiadása különböző korosztályú gyerekeknek, családoknak, 
            szakköröknek, programozás kurzusoknak, felnőtt és továbbképzési műhelyeknek és sorolhatnánk... 
        </para>
        <section>
            <title>Milyen nyelven nyomjuk?</title>
            <para>
                C (mutatók), C++ (másoló és mozgató szemantika) és Java (lebutított C++) nyelvekből kell egy jó alap, 
                ezt kell kiegészíteni pár R (vektoros szemlélet), Python (gépi tanulás bevezető), Lisp és Prolog (hogy lássuk
                mást is) példával.
            </para>
        </section>
        <section>
            <title>Hogyan nyomjuk?</title>
            <para>
                Rántsd le a <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
                git repót, vagy méginkább forkolj belőle magadnak egy sajátot a GitLabon, ha már saját könyvön dolgozol!
            
                <screen><![CDATA[]]></screen> 
            
            </para>
            <para>
                Ha megvannak a könyv DocBook XML forrásai, 
                akkor az alább látható <command>make</command> parancs ellenőrzi, hogy „jól formázottak” és 
                „érvényesek-e” ezek az XML források, majd 
                elkészíti a <application>dblatex</application> programmal a könyved pdf változatát, íme:
                <screen><![CDATA[batfai@entropy:~$ cd glrepos/bhax/thematic_tutorials/bhax_textbook/
batfai@entropy:~/glrepos/bhax/thematic_tutorials/bhax_textbook$ make
rm -f bhax-textbook-fdl.pdf
xmllint --xinclude bhax-textbook-fdl.xml --output output.xml
xmllint --relaxng http://docbook.org/xml/5.0/rng/docbookxi.rng output.xml --noout
output.xml validates
rm -f output.xml	
dblatex bhax-textbook-fdl.xml -p bhax-textbook.xls
Build the book set list...
Build the listings...
XSLT stylesheets DocBook - LaTeX 2e (0.3.10)
===================================================
Stripping NS from DocBook 5/NG document.
Processing stripped document.
Image 'dblatex' not found
Build bhax-textbook-fdl.pdf
'bhax-textbook-fdl.pdf' successfully built]]></screen>             

            Ha minden igaz, akkor most éppen ezt a legenerált <filename>bhax-textbook-fdl.pdf</filename> fájlt olvasod.
            </para>
<tip>
              <title>A DocBook XML 5.1 új neked?</title>
              <para>
                  Ez esetben forgasd a <link xlink:href="https://tdg.docbook.org/tdg/5.1/">https://tdg.docbook.org/tdg/5.1/</link>
                  könyvet, a végén találod az informatikai szövegek jelölésére használható gazdag „API” elemenkénti
                  bemutatását.                  
              </para>            
            </tip>            
        </section>
        
    </section>            

</preface> 

    <!-- 
        <xi:include href="bhax-textbook-glossary.xml">
            <xi:fallback>
                <para>
                    <emphasis>XInclude: bhax-textbook-glossary.xml file not found</emphasis>
                </para>
            </xi:fallback>
        </xi:include> 
    -->

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Bevezetés</title>
    <partintro>
        <para> 
        </para>
    </partintro>
    <chapter>
        <info>
            <title>Vízió</title>
            <keywordset>
                <keyword/>
            </keywordset>
        </info>
        <section>
            <title>Mi a programozás?</title>
            <para>                  
                          
            </para>
        </section>
        <section>
            <title>Milyen doksikat olvassak el?</title>
            <itemizedlist>
                <listitem>
                    <para>Olvasgasd a kézikönyv lapjait, kezd a <command>man man</command> parancs kiadásával. A C programozásban
                    a 3-as szintű lapokat fogod nézegetni, például az első feladat kapcsán ezt a 
                    <command>man 3 sleep</command> lapot</para>                        
                </listitem>
                <listitem>
                    <para><citation>KERNIGHANRITCHIE</citation></para>                        
                </listitem>
                <listitem>
                    <para><citation>BMECPP</citation></para>                        
                </listitem>
                <listitem>
                    <para>Az igazi kockák persze csemegéznek a C nyelvi szabvány 
                        <link xlink:href="https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf">ISO/IEC 9899:2017</link> kódcsipeteiből is.
                    </para>                        
                </listitem>
            </itemizedlist>            
        </section>
        <section>
            <title>Milyen filmeket nézzek meg?</title>
            <itemizedlist>
                <listitem>
                    <para>21 - Las Vegas ostroma, 
                        <link xlink:href="https://www.imdb.com/title/tt0478087/">https://www.imdb.com/title/tt0478087/</link>,
                        benne a <link xlink:href="#bhax-textbook-feladatok-turing.MontyHall">Monty Hall probléma</link> bemutatása.
                    </para>                        
                </listitem>
            </itemizedlist> 
        </section>
    </chapter>                
</part> 

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Tematikus feladatok</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/vegtelen">https://github.com/Savitar97/Prog1/tree/master/vegtelen</link>                
        </para>
        <para>
         Végtelen ciklust a legkönnyebben 3 féle képpen tudunk írni(ezek a standard formák):
        </para>
        <programlisting language="c"><![CDATA[
        #include <stdio.h>
        int main(){
        while(1);//végtelen ciklus while-al
        for(;;);//végtelen ciklus for-al
        do{}
        while(1);//végtelen ciklus do while segítségével
        return 0;
        }       ]]>
        </programlisting>
        <para>
            A végtelen ciklus következhet hibából, de van úgy, hogy szándékosan használunk végtelen ciklusokat például a programok menüjénél, de a program futása is egy végtelen ciklus, amelyet az X gombra kattintás szakít meg.Ha simán írunk egy végtelen ciklust az egy szálat fog kihasználni 100%-on, mindaddig amíg nem párhuzamosítjuk, ezt a:
        </para>
        <programlisting language="c"><![CDATA[
        #pragma omp parallel]]>
        </programlisting> 
        <para>
            segítségével érjük el.Ekkor a program már minden szálat képes kihasználni 100%-on. Fordítani pedig a következőképpen tudjuk:
        </para>
        <para>
            <command>gcc vegtelen3.c -o vegtelen3 -fopenmp</command>
        </para>
        <para>
            Végtelen ciklus 1 mag 100%-os használattal:
         </para>
         <figure>
             <title>Végtelen ciklus 100%-os használattal</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/vegtelen1mag.png" scale="30"/>
                </imageobject>
        </mediaobject>
         </figure>
        <para>Végtelen ciklus az összes mag kihasználásával:</para>
        <figure>
             <title>Végtelen ciklus az összes mag 100%-os használattal</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/vegtelenosszesmag.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure>
        <para>  
            Ha azt akarjuk, hogy 0%-ot használjon a processzorból akkor azt a:
         </para>
         <programlisting language="c"><![CDATA[
        sleep();]]>
        </programlisting> 
        <para>
        használatával tudjuk elérni, amely lehetővé teszi, hogy a meghívott szálat egy meghatározott ideig "sleepeltesse". Az időt a () között adhatjuk meg másodpercben, ha 0-t adunk meg, akkor végtelen időre sleepeltethetünk. A sleep függvényt az:    
        </para>
        <programlisting language="c"><![CDATA[
        #include <unistd.h>]]>
        </programlisting>
        <para>
          könyvtár tartalmazza. Tehát a használatához megkell hívnunk.
</para>
<figure>
             <title>Végtelen ciklus 0%-os használattal</title>
<mediaobject>
                <imageobject>
                    <imagedata fileref="img/vegtelen0mag.png" scale="30"/>
                </imageobject>
        </mediaobject>
</figure>      
    </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            Ha a T100 as függvény létezne és megkapná a P-t paraméternek akkor igazat ad vissza. De ha a T100 asnak a T100 ast adjuk meg tehát rekurzívan hívjuk meg a T100 ast akkor azt írná ki, hogy a T100 asban nincs végtelen ciklus, pedig a bemenő argumentuma egy végtelen ciklus.Ha létezne ilyen program nem lenne szükség a teszterekre. Mellesleg ez ellentmondást ad vissza.
        </para>
        <para>
            Tanulság nem lehet jelenleg olyan programot írni, amely normálisan eldönti egy másik programról, hogy kifog -e fagyni avagy sem.
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog1/blob/master/valtcser/valtcser.c">https://github.com/Savitar97/Prog1/blob/master/valtcser/valtcser.c</link> 
        </para>
        
        <para>
            Két változó értékének felcserélése többféle módon is történhet a legalapvetőbb a segédváltozó használata.Ekkor a 2 változóhoz behozunk egy ideiglenes segédváltozót, amiben valamelyik változó értékét letároljuk, majd az első változó értékét egyenlővé tesszük a másodikkal, majd a második értékét egyenlővé tesszük az ideiglenesben letárolt első változó értékével. Ez itt látható:
        </para>
        <programlisting language="c"><![CDATA[
        #include <stdio.h>
        int main(){
        int elso=5,masodik=3,temp;
            temp=elso;
            elso=masodik;
            masodik=temp;
        }       ]]></programlisting>
        <para>
            De ezen a módszeren kívül, lehetséges összeadás-kivonással,szorzás-osztással,vagy logikai kizáró vagy művelet segítségével felcserélni két változó értékét.    
        </para>
        <para>
            Legyen két változónk a és b. Összeadással az a-ba összeadjuk a-t és b-t. Majd az a-ból kivonjuk a b-t és ezt letároljuk b-be.Ekkor b értéke egyenlő lesz az a változó kezdeti értékével,majd az a-ból kivonjuk a b változót ekkor a értéke egyenlő lesz b kezdeti értékével, tehát felcserélődtek az értékek.Szorzás-osztással, ugyan így működik.
        </para>
        <para>
            Két változó értékét logikai operátorral a kizáró vaggyal is megcserélhetjük.
        </para>
        <programlisting language="c"><![CDATA[
        #include <stdio.h>
        int main(){
        int elso=5,masodik=3;
            elso=elso^masodik;
            masodik=elso^masodik;
            elso=elso^masodik;
        }       ]]></programlisting>
        <para>
        A kizáróvagy(xor) lényege, hogy csak akkor igaz ha az egyik igaz.Ez binárisan azt jelenti,hogy akkor 1 es ha ugyan azon a biten lévő érték az egyik változónál 1 es a másikban 0 ás.Az elso változó binárisan 0101 a masodik 0011 kizáró vagyot végre hajtva az elso értéke 0110 lesz, aminek az értéke 6. Majd újra kizáró vagyot végrehajtva a masodik értéke 0101 lesz, ami 5 tehát megkapta az elso ertékét. Ezután még egyszer kizáróvagy-ot használunk ekkor az elso értéke 0011 lesz, ami 10 es számrendszerbe 3. Tehát a két változó értéke felcserélődött.   
        </para>
        <figure>
             <title>Változócsere</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/valtcser.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure> 
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <caution>
            <title>
                Tutor
            </title>
            <para>Ebben a feladatban tutoráltam Ádám Petrát.</para>
        </caution>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog1/tree/master/labda">https://github.com/Savitar97/Prog1/tree/master/labda</link>
        </para>
        <para>
         Labdapattogtatás if-el: c-ben megadtam egy maximális méretet a pályának ez az x és y változó. A labda kezdetleges koordinátáit a labdax és labday-ban tárolom. Ezen kívül kell még 2 változó, amely a labda mozgásáért felelős ez a tempx és tempy. Magát a labdát karakterként a labda változóban tárolom.
        </para>
        <programlisting language="c"><![CDATA[
        #include <stdio.h>
        int main(){
        char labda='o';
	int x=80,y=15,labdax=1,labday=1,tempx=1,tempy=1;
        }       ]]></programlisting>
        <para>
            A labdapattogtatást a for(;;) végtelen ciklus és egy rajzol eljárás folytonos meghívása szolgálja. A labda mozgását a koordináták temp-el való növelése szolgálja. Az if-ek segítségével érem el, hogy ha a labda eléri a pálya szélét, akkor a temp előjele változzon, így az érték csökkeni kezd, majd csökkenés után ha újra eléri a pálya szélét a -1-szeres szorzással újra pozitívba vált. A késleltetett kiírást az usleep éri el, az értéket microsec-be kell megadni és az unistd.h könyvtár tartalmazza ezt a függvényt.  
        </para>
        <programlisting language="c"><![CDATA[
        #include <stdio.h>
        #include <unistd.h>
        int main(){
        for(;;)
	{
		labdax+=tempx;
		labday+=tempy;
		if(x-1<=labdax)
		{
			tempx*=-1;
		}
		else if(y-1<=labday)
		{
			tempy*=-1;
		}
		else if(labdax<0)
		{
			tempx*=-1;
		}
		else if(labday<0)
		{
			tempy*=-1;
		}
		rajzol(labdax,labday,labda);
		usleep(100000);
	}
        }       ]]></programlisting>
        <para>
            If nélkül azt, hogy a labda vissza pattanjon a maradékos osztás végzi el és az abszolút érték.
        </para>
            <screen><![CDATA[
                    x=abs(szelesseg-lepteto%(2*szelesseg));
                    y=abs(tmagassag-lepteto%(2*tmagassag));
                    lepteto++;
                    ]]>
        </screen>
        <para>
            És persze szükséges mellette egy változó aminek az értékét folyamatosan növeljük és a pálya méretének 2x esével osztjuk el maradékosan, majd kivonjuk a pálya méretéből és ez határozza meg a labda koordinátáját.Tehát mondjuk egy 50 es pálya méretnél 50-1%100=49 ... így csökken egészen 0-ig majd mikor a léptető eléri az 51 et 50-51=-1 el, de ennek az abszolút értéke 1, tehát újra növekedni fog.
        </para>
        <para>
            Tapasztalat:C-ben van egy kis hiba mivel, amikor eléri a pálya tetejét a labda nem egyből pattan vissza, ez csak if-nél jelentkezik. If nélkül a két abszolút értékes függvénnyel nem jelentkezik ez a hiba.
        </para>
        <para>
            A program futás közben:
        </para>
        <figure>
             <title>Labdapattogtatás</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/labda.png" scale="150"/>
                </imageobject>
        </mediaobject>
        </figure>
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/blob/master/szohossz/bitshift.cpp">https://github.com/Savitar97/Prog1/blob/master/szohossz/bitshift.cpp</link>
        </para>
        
        <para>
            A szóhossz megnézéséhez a bitenkénti léptetés operátort használjuk:
        <screen>
        <![CDATA[while (szam <<=1){
			cout<<szam<<'\n';
			counter++;		
        }]]>
        </screen>
            Ez annyit jelent hogy az egyest egyre jobban balra toljuk és jobbról 0-ákkal pótoljuk.
        </para>
        <para>
          Ez azt eredményezi, hogy 2-nek hatványait kapjuk és amikor eléri az int maximális méretét utána 0-t kap eredményül, mivel a bitsorozat teljesen ki 0-ázódik.Tehát a 32. lépésre, nem lesz olyan bit, amin képesek leszünk ábrázolni az 1 est.   
        </para>
        <figure>
             <title>Szóhossz</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/bitshift.png" scale="50"/>
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            Igazából 32 bites a szóhossz csak az elsőt nem számolja szóval 31+1.
        </para>
        <para>
            De ezen könnyen javíthatunk ha, a while helyett do while-t használunk:
        </para>
        <screen>
        <![CDATA[do{
			cout<<szam<<'\n';
			counter++;
        }while (szam <<=1);
]]>
        </screen>
        <figure>
             <title>Szóhossz jó megoldás</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/bitshiftjav.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <caution>
            <title>
                Tutor
            </title>
            <para>Ebben a feladatban tutoráltam Ádám Petrát és Duszka Ákos Attilát.</para>
        </caution>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/blob/master/pagerank/pagerank.c">https://github.com/Savitar97/Prog1/blob/master/pagerank/pagerank.c</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            A pagerank algoritmust a google találta ki azért, hogy megkönnyítsék a weben való keresést. Maga a pagerank egy számba sűríti a weblap értékét. A lényege, hogy minél több oldal mutat a weblapunkra annál értékesebb. Ez azért van mert, úgy gondolták a google alapítói, hogy a weboldal készítői, azért linkelnek be oldalakat mert hasznosnak találják.
        </para>
        <para>
            Ez felfogható úgy is, mint egy választás. És minden oldal képes szavazni és az, hogy valaki a mi linkünket használja olyan mintha ránk voksolna és akinek több a szavazata az van előrébb a rangsorban.
        </para>
        <para>
            Első lépésként megadjuk a kapcsolati gráfot. Tehát, hogy melyik oldal melyik oldalra mutat. Ezt egy mátrixban tároljuk le, mivel 4 honlappal dolgozunk, ezért egy 4x4 es mátrix lesz:
        </para>
        <programlisting language="c"><![CDATA[
        #include <stdio.h>
        #include <unistd.h>
        int main(){
        double graf[4][4] = {
                                {0.0, 0.0, 1.0 / 3.0, 0.0},
                                {1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
                                {0.0, 1.0 / 2.0, 0.0, 0.0},
                                {0.0, 0.0, 1.0 / 3.0, 0.0}
                            };
	}
        }       ]]></programlisting>
        <para>Azért double mivel a pagerank nem feltétlenül csak egész szám lehet.</para>
        <para>Ezután létrehozunk még 2 db egydimenziós tömböt. Az egyikben a végleges pagerankot tároljuk míg a másikban az ideiglenest. Az ideiglenes vektorban minden oldal pagerankját 1/4-re állítjuk mivel 4 oldal van.</para>
        <para>Majd indítunk egy végleges ciklust,amely addig fut, amíg a pagerank kisebb nem lesz, mint a dumping factort az az a csillapító értéket, most ez 0.00001-ben lett meghatározva</para>
        <para>A végtelen ciklus elején áttöltjük az ideiglenes pagerankból az értékeket a végleges pagerank tömbünkbe.</para>
        <para>Ezt követően indítunk egy egybeágyazott for ciklust, amely a letárolt kapcsolati gráfos tömb(a szétosztott szavazatokat tárolja) sorait megszorozza a jelenlegi pagerankkal és a sorok összegét, mármint egyessével egy értékbe tömöríti és azt betölti az ideiglenes pagerankba és ez addig folytatódik, amíg kinem lép a végtelen ciklusból.</para>
        <programlisting language="c"><![CDATA[
        #include <stdio.h>
        #include <unistd.h>
        #define dumping_factor 0.0001
            
        int main(){
        while(1)
            {
                for(i=0;i<4;i++)
		{
			PR[i] = PRt[i];
		}
                for (i=0;i<4;i++)
		{
			double temp=0;
			for (j=0;j<4;j++)
				temp+=graf[i][j]*PR[j];
			PRt[i]=temp;
		}

                if ( dif(PR,PRt, 4) < dumping_factor)
		break;
            }
	}
        }       ]]></programlisting>
        <para>A távolság függvény paraméterként megkapja a végleges pagerankot és az ideiglenest és, hogy hány db oldal van. Majd kivonja a pagerank i-edik eleméből az ideiglenes pagerank i-edik elemének értékét és ezek abszolút értékét összeadja a tav nevű változóban, amely a függvény visszatérési értéke lesz.</para>
        <programlisting language="c"><![CDATA[
        #include <stdio.h>
        #include <unistd.h>
        
        double dif(double pagerank[],double pagerank_temp[],int db)
{
	double  dif= 0.0;
	int i;
	for(i=0;i<db;i++)
		{
			dif +=fabs(pagerank[i] - pagerank_temp[i]);
		}
	return dif;
}
       ]]></programlisting>
       <para>Érdekesség ha az egyik oldal nem mutat semmire.Tehát ha az utolsó oszlopot mondjuk teljesen ki 0-ázzuk akkor a pagerank is kinullázódna ha 2 tizedes jegyik néznénk az értéket.</para>
       <figure>
             <title>Pagerank hibásmegoldás</title>
       <mediaobject>
                <imageobject>
                    <imagedata fileref="img/nulla.png" scale="100"/>
                </imageobject>
        </mediaobject>
       </figure>
        <para>A helyes megoldás:</para>
        <figure>
             <title>Pagerank helyes megoldás</title>
           <mediaobject>
                <imageobject>
                    <imagedata fileref="img/elso.png" scale="100"/>
                </imageobject>
            </mediaobject>
        </figure>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <caution>
            <title>
                Tutorált
            </title>
            <para>Ebben a feladatban tutorált Duszka Ákos Attilát.</para>
        </caution>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
        <para>
            Prímnek nevezzük azokat a számokat, amelyek csak 1-el és önmagukkal oszthatók.Ikerprímek azok a prímszámok, amelyek különbsége 2.
        </para>
        <para>
            A program egy megadott x értékig kikeresi a prímeket. Majd megnézi a köztük lévő diferenciát (diff),ahol ez a diferencia 2, annak az indexét egy tömbben(idx) tárolja(de csak az ikerprímpár első tagjának indexét, ezért kell a t2primes-nál a +2) tehát a prímek közül kiszűri, hogy melyek ikerprímek.
        </para>
        <programlisting language="R"><![CDATA[
         primes = primes(x)
        diff = primes[2:length(primes)]-primes[1:length(primes)-1]
        idx = which(diff==2)
        t1primes = primes[idx]
        t2primes = primes[idx]+2
       ]]></programlisting>
        <para>
            Majd az rt1plust2-ben összeadjuk ezeknek a reciprokát végül a függvényünk visszatérési értéke az rt1plust2-nek az összege.
        </para>
        <para>
            A seq függvény hasonló a for ciklushoz seq(from, to, by= ), from,hogy mettől(13) to, hogy meddig(1000000) és a by, hogy milyen lépésszámmal(10000). Ez határozza meg az x tengely beosztását.
        </para>
        <para>
            A sapply függvény az x ekhez rendeli egyessével az stp függvényben kapott értékeket y-ként.
        </para>
        <para>
            Végül a plot kirajzolja a függvényt.
         </para>
         <figure>
             <title>A konstans közelítése</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Rplot.png" scale="100"/>
                </imageobject>
        </mediaobject>
         </figure>
        <para>
            A képen látható, hogy a párosprímek reciprokának összege egyre jobban tart a 2 felé,tehát egy véges értékhez konvergál, amely a Brun konstans azaz a Brun tétel teljesül.
        </para>
        <para>
            De ezzel még mindig nem tudjuk eldönteni, hogy végtelen vagy véges számú prímszám van mert úgysem lépik át ezt a határt csak megközelítik.
        </para>
    </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <caution>
            <title>
                Tutorált
            </title>
            <para>Ebben a feladatban tutorál Duszka Ákos Attilát.</para>
        </caution>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            A Monty Hall probléma lényegében 3 ajtó közül kell kiválasztanunk a nyerteset viszont ha nem találjuk el akkor újra kezdhetjük.
        </para>
        <para>
            Annak a valószínűsége, hogy egyből a jó ajtót találjuk el 1/3 és az, hogy rosszat 2/3. Viszont a választás után a 3 ajtó közül a műsorvezető kinyit egyet, amelyik mögött nem a nyeremény van.(A játékvezető tudja melyik ajtó mögött van a nyeremény) Majd ezután megkérdi a játékost, hogy szeretne -e változtatni a választásán. Elvileg az ajtó nyitása után a nyerési arányunk redukálódik 1/2-re, hogy nyerünk és 1/2-re, hogy vesztünk. A nagy kérdés itt az, hogy megéri -e váltanunk.Ez a program pont ezt szimulálja.
        </para>
        <para>
            A kísérletek száma változóban definiáljuk, hogy hányszor fusson le a kísérlet.Azaz a minták száma.
        </para>
        <para>
            A kiserlet és a jatekos tömbök, amelyeket 1 és 3 közé eső számokkal tölt fel a sample. A műsorvezető egy vektor amelyet ugyan olyan méretűre deklarálunk mint a kísérletek száma.
        </para>
        <para>
            Egy for ciklussal bejárjuk a tömböt és ha a játékos eltalálja, hogy melyik ajtó mögött van akkor a mibol tömbbe a másik két ajtó lehetősége kerül.Ha nem találja el akkor csak egyetlen érték az az ajtó ami mögött nincs semmi,de nem választotta a játékos.
        </para>
        <para>
            Ezután a műsorvezető úgymond kinyit egy ajtót tehát választ egyet a mibol tömbből.
        </para>
        <para>
            Majd lefut egy feltétel, amely megmutatja hányszor nyerne a játékos ha nem változtat.Tehát a tömbbe azok az indexek kerülnek amikor a jatekos és a kiserlet megegyezik.
        </para>
        <para>
            Létrehozunk egy új vektort amiben megváltoztatjuk a választást úgy, hogy kivételként adjuk a műsorvezető által kinyitott ajtót és a játékost által választottat.
        </para>
        <para>
            Végül lefuttatunk egy ugyan ilyen feltételes vizsgálatot, hogy mi lett volna ha mindig változtatunk. És itt is ugyan úgy letároljuk egy tömbbe, hogy mely indexeknél nyert a játékos. És kiiratjuk a statisztikát, amely megmutatja, hogyan járnánk jobban ha mindig változtatnánk vagy ha tartózkodnánk az először választott ajtóhoz.
        </para>
        <para>
            Egy példa a program futására:
        </para>
        <figure>
             <title>Monty Hall teszt</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/monty.png" scale="50"/>
                </imageobject>
        </mediaobject>
        </figure>
    </section>

</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:Az előadás fóliája.               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            Decimálisból unárisba, úgy váltunk, hogy annyi 1 est írunk le,amennyi a szám értéke vagy másképp fogalmazva amilyen messze van a 0-tól.Pl.:n=90 esetén 90 db 1 est kell leírnunk.
        </para>
        <para>
            Tehát itt pozitív számokat tudunk ábrázolni. A megvalósítás 2 féle lehet vagy indítunk egy for ciklust 0-tól és minden egyes lépésnél egy stringbe összefűzzük az egyeseket. Vagy pedig a számtól indítunk egy ciklust 0-ig és ugyan ezt tesszük. 
        </para>
        <figure>
             <title>Turing gép</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/turing.jpg" scale="45"/>
                </imageobject>
        </mediaobject>
        </figure>
    </section>        
        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            A környezetfüggő grammatika olyan szabályok összessége,amely segítségével a nyelvben minden jelsorozatot képesek vagyunk előállítani.
        </para>
        <itemizedlist>
            <listitem>
                <para>
            A grammatika forrása a fólia:
            A, B, C „változók”
            a, b, c „konstansok”
            A → aAB, A → aC, CB → bCc, cB → Bc, C → bc
            S-ből indulunk ki.
            S→ aC
            aC(C→ bc)
            abc
                </para>
            </listitem>
            <listitem>
                <para>
            S→ aAB
                </para>
            </listitem>
            <listitem>
                <para>
            aAB(A→ aAB)
                </para>
            </listitem> 
            <listitem>
                <para>aaABB(A→ aAB)</para>                        
            </listitem>
            <listitem>
                <para>aaaABBB(A→ aAB)</para>                        
            </listitem>
            <listitem>
                <para>aaaaABBBB(A→ aC)</para>                        
            </listitem>
            <listitem>
                <para>aaaaaCBBBB(CB→ bCc)</para>                        
            </listitem>
            <listitem>
                <para>aaaaabCcBBB(cB→ Bc)</para>                        
            </listitem>
            <listitem>
                <para>aaaaabCBcBB(CB→ bCc)</para>                        
            </listitem>
            <listitem>
                <para>aaaaabbCccBB(cB→ Bc)x2</para>                        
            </listitem>
            <listitem>
                <para>aaaaabbCBccB(CB→ bCc)</para>                        
            </listitem>
            <listitem>
                <para>aaaaabbbCcccB(cB→ Bc)x3</para>                        
            </listitem>
            <listitem>
                <para>aaaaabbbCBccc(CB→ bCc)</para>                        
            </listitem>
            <listitem>
                <para>aaaaabbbbCcccc(C→ bc)</para>                        
            </listitem>
            <listitem>
                <para>aaaaabbbbbccccc</para>                        
            </listitem>                   
            <listitem>
                <para>Ez a grammatika biztosan ezt a nyelvet generálja.</para>                        
            </listitem>            
            
        </itemizedlist>
       <itemizedlist> 
        <listitem>
                <para>S, X, Y „változók”
            a, b, c „konstansok”
            S → abc, S → aXbc, Xb → bX, Xc → Ybcc, bY → Yb, aY -&gt; aaX, aY → aa
            S-ből indulunk ki
            A grammatika forrása a fólia.</para>                        
        </listitem>  
        <listitem>
                <para>S(S→aXbc)</para>                        
        </listitem>
        <listitem>
                <para>aXbc(Xb→bX)</para>                        
        </listitem> 
        <listitem>
                <para>abXc(Xc→Ybcc)</para>                        
        </listitem> 
        <listitem>
                <para>abYbcc(bY→Yb)</para>                        
        </listitem> 
        <listitem>
                <para>aYbbcc(aY→aaX)</para>                        
        </listitem> 
        <listitem>
                <para>aaXbbcc(Xb→xB)2*</para>                        
        </listitem> 
        <listitem>
                <para>aabbXcc(Xc→Ybcc)</para>                        
        </listitem> 
        <listitem>
                <para>aabbYbccc(bY→Yb)</para>                        
        </listitem> 
        <listitem>
                <para>aaYbbbccc(aY→aaX)</para>                        
        </listitem> 
        <listitem>
                <para>aaaXbbbccc(Xb→bX)3*</para>                        
        </listitem> 
        <listitem>
                <para>aaabbbXccc(Xc→Ybcc)</para>                        
        </listitem> 
        <listitem>
                <para>aaabbbYbcccc(bY→Yb)3*</para>                        
        </listitem> 
        <listitem>
                <para>aaaYbbbbcccc(aY→aa)</para>                        
        </listitem> 
        <listitem>
                <para>aaaabbbbcccc</para>                        
        </listitem> 
        <listitem>
                <para>Környezetfüggő! Az abc-nek bárhanyadik hatványa előállítható.</para>                        
        </listitem>     
    </itemizedlist>
    
    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Savitar97/Prog1/blob/master/hivatkozas/hivatkozas.c">https://github.com/Savitar97/Prog1/blob/master/hivatkozas/hivatkozas.c</link> 
            
        </para>
        <para>
            <link xlink:href="https://hu.wikipedia.org/wiki/Backus%E2%80%93Naur-forma">https://hu.wikipedia.org/wiki/Backus%E2%80%93Naur-forma</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            A C utasítások a C nyelv kulcsszavai.
            A C nyelv tartalmazza a többsoros utasítás blokkokat,iterációkat (for,while,do-while),vezérlő szerkezeteket(if,switch),operátorok(++,--,!=,stb),deklarációk.
        </para>
        <para>
            Backus normal form egy általánosított leírása a programozási nyelveknek.Nyelv független. Vagyis ez a séma ráilleszthető a legtöbb programozási nyelvre és használható a nyelvekben írt programok leírására.
        </para>
        <programlisting><![CDATA[
            Forrás:https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_1.pdf?fbclid=IwAR1eImHN5PINqTMnhpJItlqA_PtEcfNGKqndS6nt5wNTFr_X-hcSdiVr5iQ
            A backus leírás röviden:
        <szimbólum> ::= <kifejezés a szimbólumra>
            van egy szimbólum aztán a ::= után van egy formai leírása 
        <egész szám> ::= <előjel><szam>
        <előjel> ::= [-|+]
        <szam> ::= <szamjegy>{<szamjegy>}
        <szamjegy> ::= 0|1|2|3|4|5|6|7|8|9
            /*A forrás az előadás pptjéről származik.*/
       ]]>
        </programlisting>
        <para>
            A c89-ben még nem lehet egysoros kommenteket írni (<command>//</command>) és szintén nem lehet a for ciklus fejében változót deklarálni, amit a c99 már enged. A különböző változatoknál a fordítást a <command>-std</command> kapcsolóval érjük el ez, így néz ki a gyakorlatban:
        </para>
        <para>
            <command>gcc -o hivatkozas -std=c89 hivatkozas.c</command>
        </para>
        <para>
            <command>gcc -o hivatkozas -std=c99 hivatkozas.c</command>
        </para>
        <programlisting language="c"><![CDATA[
        #include <stdio.h>
        int main(){
        int i;
        for(i=0;i<10;i++)
        /*Ez így lefog futni c89-ben is.
          Viszont
          for(int i=0;i<10;i++)
          ez nem.
        */
        return 0;
        }       ]]>
        </programlisting>
        <para>
            A következő hibaüzenetet kapjuk:
        </para>
        <figure>
             <title>Hibaüzenet</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/error.png" scale="50"/>
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            Emellett van olyan ami a c89-ben működik, de c99 ben nem. Ilyen a következő kódcsipet:
        </para>
        <programlisting language="c"><![CDATA[
        #include <stdio.h>


        int main()
        {
	
        int restrict=1;
        if (restrict) printf("restricted");
        return 0;
        }
              ]]>
        </programlisting>
        <para>
            Azért fordulhat le mivel a restrict még nem kulcsszó c89-ben,viszont c99-ben már igen. A restrict megadja, hogy mely pointerek férhetnek hozzá az adott memória területhez,ezeket a pointereket nem lehet módosítani.
        </para>
        
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/real">https://github.com/Savitar97/Prog1/tree/master/real</link>
        </para>
       <programlisting language="c"><![CDATA[
        %{
#include <stdio.h>
int counter = 0;
%}
digit	[0-9]
%%
{digit}*(\.{digit}+)?	{++counter; 
    printf("[realnum=%s %f]", yytext, atof(yytext));}
%%
int
main ()
{
 yylex ();
 printf("Valós számok száma:[ %d]\n", counter);
 return 0;
}
              ]]>
        </programlisting>
        <para>
            A lexernél az egyes részeket %%-jelek választják el. Az első résznél jön a könyvtár hivatkozás és a deklarációk és az első rész végén definiálunk(ilyen itt a digit amiben a számokat definiáljuk) a definícióknál lehet megadni a karakter csoportokat, amelyeket keresni akarunk a beolvasott szövegből.
        </para>
        <para>
            A következőben jöhetnek a formázási szabályok itt mondhatjuk meg, hogy mi történjen ha megtalálja az adott karakter sorozatot vagy karaktert a lexer.Itt már használhatjuk a definíciókat.
        </para>
        <para>
            Az első kapcsos zárójelben megadtuk, hogy számot keresünk, ezután a csillag azt jelenti,hogy bármennyiszer előfordulhat 0 vagy akárhány.Majd egy pontnak kell követni azután a + miatt jönnie kell egy számnak legalább vagy többnek. A kérdőjel viszont azt jelzi, hogy nem muszáj pontnak következnie és utána számnak ez azért kell mivel az egész számok is beletartoznak a valós számokhoz.
        </para>
        <para>
            Majd azt adjuk meg ha találunk ilyen karaktersorozatot akkor a countert növeljük-1 el. És írjuk ki ezt a karakter sorozatot -között az atof függvény pedig ezt a karaktersorozatot valós számmá konvertálja.
        </para>
        <para>
            A programot a következő képpen kell fordítanunk:
        </para>
        <para>
        <command>lex -o real.c real.l</command>
        </para>
        <para>
            Ilyenkor a lexer megírja a c programot, majd a létrehozott .c fájlt gcc-vel fordítjuk.
        </para>
        <para>
        <command>gcc -o real real.c -lfl</command>
        </para>
        <para>
            Az utolsó részben jön a program main része itt meghívjuk a yylex() függvényt és kiirassuk,hogy hány db valós számot találtunk.
        </para>
        <para>
            A programot a <keycap>Ctrl+D</keycap>-vel tudjuk leállítani.
        </para>
        <figure>
             <title>Lexikális elemző</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/realnum.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure>
    </section>                     

    <section>
        <title>l33t.l</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog1/tree/master/leet">https://github.com/Savitar97/Prog1/tree/master/leet</link> 
        </para>
       <programlisting language="c"><![CDATA[
        /*
Forditas:
$ lex -o lexer.c lexer.l 

Futtatas:
$ gcc lexer.c -o lexer -lfl
(kilépés az input vége, azaz Ctrl+D)

*/
%{
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
  #include <ctype.h>

  #define LEXERSIZE (sizeof lexer / sizeof (struct cipher))
    
  struct cipher {
    char c;
    char *leet[4];
  } lexer [] = {

  
  {'0', {"Ω", "○", "º", ""}},
  {'1', {"I", "I", "L", "L"}},
  {'2', {"Z", "Z", "Z", "e"}},
  {'3', {"E", "E", "E", "E"}},
  {'4', {"h", "h", "A", "A"}},
  {'5', {"S", "S", "S", "S"}},
  {'6', {"b", "b", "G", "G"}},
  {'7', {"T", "T", "j", "j"}},
  {'8', {"X", "X", "X", "X"}},
  {'9', {"g", "g", "j", "j"}}
  
// https://simple.wikipedia.org/wiki/Leet
  };
  
%}
%%
. {
    
    int found = 0;
    for(int i=0; i<LEXERSIZE; ++i)
    {
    
      if(lexer[i].c == tolower(*yytext))
      {
      
        int r = 1+(int) (100.0*rand()/(RAND_MAX+1.0));
      
          if(r<91)
          printf("%s", lexer[i].leet[0]);
          else if(r<95)
          printf("%s", lexer[i].leet[1]);
        else if(r<98)
          printf("%s", lexer[i].leet[2]);
        else 
          printf("%s", lexer[i].leet[3]);

        found = 1;
        break;
      }
      
    }
    
    if(!found)
       printf("%c", *yytext);   
    
  }
%%
int 
main()
{
  srand(time(NULL)+getpid());
  yylex();
  return 0;
}
              ]]>
        </programlisting>
        <para>
            Elsőként definiáljuk a lexer struktúra méretét. Ezt a define LEXERSIZE adja meg vagyis a sorok számát ez 36.
        </para>
        <para>
            Ezután létrehozunk egy struktúrát. Amiben definiálunk egy karakter változót és egy 4 elemű mutató tömböt.Ha több variációt akarunk behelyettesítésre,akkor növeljük ennek a számát.
         </para>
         <para>
             Ezután létrehozzuk a struktúra fő részét itt az első elem karakter típúsú, amelyet majd vizsgálunk, a 2. elem egy 4 elemű tömb, amelyben a karakter helyettesítési lehetőségeit tároljuk. 
          </para>
          <para>
              Ez volt az első része a lexernek ahol definiálunk és könyvtárakat hívunk meg.Most a defíníciókat kihagyjuk.
          </para>
          <para>
              Következőnek az utasítás része jön a lexernek.Itt behozunk egy változót, amely azt jelzi, hogy megtalálta -e a karaktert a struktúrában ha nem akkor visszaadja majd a lent lévő if magát a karaktert. Majd indítunk egy fort,amely átnézi a struktúrát keresve a beolvasott karaktert, amelyet kisbetűre alakítunk,hogy ne kelljen külön kezelni a kis és nagy betűket.
          </para>
          <para>
              Ha megtaláltuk a karaktert akkor egy random számot generálunk, amely segít, hogy véletlenszerűen válasszunk a 4 opció közül, amelyet a 4 if segítségével érünk el és visszaadjuk, hogy megtaláltuk a karaktert <function>found</function>.
          </para>
          <para>
              Az utolsó részben a mainben találjuk az srandomot, amely a randomot hívja ehhez a <emphasis role="red">time.h</emphasis> szükséges.A random generálásához az időt használja és hozzáadja a getpidet, amely az <function>unistd.h</function> könyvtárban van,ez azért szükséges, hogy jobban generáljon random számokat,vagyis nagyobb legyen a számok randomitása.Majd végül meghívjuk a yylex() függvényt.
          </para>
          <para>
              A program futása során a lexer cseréli a beírt karakter sorozatot és ez 1337 5P34CH.
          </para>
          <figure>
             <title>1337 5P34CH</title>
          <mediaobject>
                <imageobject>
                    <imagedata fileref="img/leet.png" scale="30"/>
                </imageobject>
        </mediaobject>
          </figure>
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>            
            </listitem>
        </orderedlist>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog1/tree/master/3.6 ">https://github.com/Savitar97/Prog1/tree/master/3.6 </link> 
        </para>

        <para>
            Megoldás videó: 
        </para>

        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <programlisting><![CDATA[signal.c:2: Include file <unistd.h> matches the name of a POSIX library, but
    the POSIX library is not being used.  Consider using +posixlib or
    +posixstrictlib to select the POSIX library, or -warnposix to suppress this
    message.
  Header name matches a POSIX header, but the POSIX library is not selected.
  (Use -warnposixheaders to inhibit warning)
signal.c: (in function jelkezelo)
signal.c:5:20: Parameter a not used
  A function parameter is not used in the body of the function. If the argument
  is needed for type compatibility or future plans, use /*@unused@*/ in the
  argument declaration. (Use -paramuse to inhibit warning)
signal.c: (in function main)
signal.c:16:4: Return value (type [function (int) returns void]) ignored:
                  signal(SIGINT, S...
  Result returned by function call is not used. If this is intended, can cast
  result to (void) to eliminate message. (Use -retvalother to inhibit warning)
signal.c:5:6: Function exported but not used outside signal: jelkezelo
  A declaration is exported, but not used outside this module. Declaration can
  use static qualifier. (Use -exportlocal to inhibit warning)
   signal.c:8:1: Definition of jelkezelo
]]></programlisting>
        <para>
            A signalis program ignorálja(SIG_IGN) vagy másképp elkapja a signalokat ilyen például a <keycap>Ctrl+C</keycap>.De nem minden signalt tud ignorálni. A SIGINT itt magát a signalt jelzi a 2 es signal neve SIGINT. A program a signal kezelést átadja a jelkezelésnek, tehát innentől nem a signal hajtódik végre hanem a jelkezelő.
        </para>
        <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>
        <para>
            Egy for ciklus, amely 0-tól meg 5-ig.A ++i jelentése pre-increment,ez azt jelenti, hogy a művelet lefutása előtt megnöveli a változó értékét egyel.
        </para>
        <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>
        <para>
            For ciklus amely 0-tól megy 5-ig. Az i++ az post-increment,vagyis előbb hajtódik végre a művelet és csak utána növeli az i értékét 1 el.
        </para>
         <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>
         <para>Splint error:</para>
         <programlisting><![CDATA[forforth.c: (in function main)
forforth.c:7:24: Expression has undefined behavior (left operand uses i,
                    modified by right operand): tomb[i] = i++
  Code has unspecified behavior. Order of evaluation of function parameters or
  subexpressions is not defined, so if a value is used and modified in
  different places not separated by a sequence point constraining evaluation
  order, then the result of the expression is unspecified. (Use -evalorder to
  inhibit warning)

Finished checking --- 1 code warning]]></programlisting>
         <para>
             A tömbnek az elemét egyenlővé teszi az i-nek az értékével kivéve az első elemét.
         </para>
          <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>
          <para>Elindít egy for ciklust, amely addig fut amíg az i kisebb mint n,ezen kívül d és s egy tömb mutatója és azokat a tömb elemeket,amelyekre a d mutat kicseréli azokra, amelyekre az s mutat.</para>
         <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>
         <para>splint által elkapott error:</para>
         <programlisting><![CDATA[forsix.c: (in function main)
forsix.c:10:24: Argument 2 modifies a, used by argument 1 (order of evaluation
                   of actual parameters is undefined): f(a, ++a)
  Code has unspecified behavior. Order of evaluation of function parameters or
  subexpressions is not defined, so if a value is used and modified in
  different places not separated by a sequence point constraining evaluation
  order, then the result of the expression is unspecified. (Use -evalorder to
  inhibit warning)
forsix.c:10:32: Argument 1 modifies a, used by argument 2 (order of evaluation
                   of actual parameters is undefined): f(++a, a)
forsix.c:10:19: Argument 2 modifies a, used by argument 3 (order of evaluation
    of actual parameters is undefined): printf("%d %d\n", f(a, ++a), f(++a, a))
forsix.c:10:30: Argument 3 modifies a, used by argument 2 (order of evaluation
    of actual parameters is undefined): printf("%d %d\n", f(a, ++a), f(++a, a))
forsix.c:2:5: Function exported but not used outside forsix: f
  A declaration is exported, but not used outside this module. Declaration can
  use static qualifier. (Use -exportlocal to inhibit warning)
   forsix.c:5:1: Definition of f

Finished checking --- 5 code warnings
]]></programlisting>
         <para>
             Az első függvénynél az a értéke 2 vel nő, míg a 2. nál 1 el.
         </para>
         <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>
         <para>Splint:</para>
         <programlisting><![CDATA[forseven.c:2:5: Function exported but not used outside forseven: f
  A declaration is exported, but not used outside this module. Declaration can
  use static qualifier. (Use -exportlocal to inhibit warning)
   forseven.c:5:1: Definition of f
]]></programlisting>
<para>Kiirja a függvénnyel módosított a és az a értékét.</para>
<programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>
<para>Splint error:</para>
   <programlisting><![CDATA[foreight.c:6:2: Parse Error. (For help on parse errors, see splint -help
               parseerrors.)]]></programlisting>
   <para>Konvertálási hiba a pointer értékeket %d helyett a %p-vel kell kiiratni printf-el.Tehát egy memória címet egészként akart kiiratni.</para>

    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX</link>
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            1. Bármely x-hez létezik olyan y, hogy az y nagyobb mint x és y prím.
            2. Bármely x-hez létezik olyan y, hogy y nagyobb mint x és y prím és y+2 is prím.
            3. Létezik olyan y, hogy bármely x esetén ha x prím akkor az x kisebb mint y.
            4. létezik olyan y, hogy bármely x esetén ha y kisebb mint x akkor x nem prím.
        </para>
        <para>
            Az első állítás azt mondja ki, hogy a prímszámok száma végtelen. Míg a második azt jelenti, hogy végtelen sok ikerprím létezik.Itt az SSy a successor function vagy másnéven a rákövetkező függvény,tehát  <emphasis role="red">S(S(y))=(y+1)+1)</emphasis>.
        </para>
        <para>
            A 3. állítás ennek az ellenkezőjét fejezi ki, tehát azt, hogy a prímszámok száma véges. A negyedik állítás ezzel ekvivalens, mivel azt mondja ki, hogy létik olyan y amitől nincs nagyobb prímszám.
        </para>
    </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                        
            </listitem>            
        </itemizedlist>            

       <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>            
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>            
            </listitem>            
        </itemizedlist>       


        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/deklaracio"> https://github.com/Savitar97/Prog1/tree/master/deklaracio</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            Az int a létrehoz egy változót, amely int típúsú az az egész, a néven. Egy változónak van neve,típúsa,hatásköre,memória címe ahol tárolódik,értéke.
        </para>
        <para>
            int *b létrehoz egy mutatót, amely a-nak a memória címére hivatkozik.
        </para>
        <para>
            Az r rekurzívan hivatkozik a értékére. Vagyis ugyan arra a memória területre hivatkozik mint az a. Tehát ha r értékét változtatjuk akkor a-nak az értéke is változik. Szemléltetésként a következő kód szolgál:
        </para>
        <programlisting language="c"><![CDATA[
        #include <stdio.h>
#include <iostream>

using namespace std;

int main()
{
	int a=5;
	int &r=a;
	int *d=&a;
	int *b=&r;
	cout<<a<<'\n'<<r<<'\n'<<d<<'\n'<<b<<'\n';
	r=r+2;
	cout<<a<<'\n'<<r<<'\n'<<d<<'\n'<<b<<'\n';
	return 0;
}
              ]]>
        </programlisting>
     <para>
         Futtatva következő eredményt kapjuk:
     </para>
     <figure>
             <title>Deklaráció</title>
      <mediaobject>
                <imageobject>
                    <imagedata fileref="img/deklaracio.png" scale="75"/>
                </imageobject>
        </mediaobject>
     </figure>
    <programlisting><![CDATA[int c[5];]]></programlisting>
    <para>
        A c deklarál egy 5 elemű tömböt.
    </para>
    <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting> 
    <para>
        A tr tömb rekurzívan hivatkozik a c tömbre.
    </para>
    <programlisting><![CDATA[int *d[5];]]></programlisting> 
    <para>
        Létrehoz egy 5 elemű mutató tömböt.
    </para>
    <programlisting><![CDATA[int *h ();]]></programlisting> 
    <para>
        Olyan függvény ami egy egészre mutató mutatót ad vissza.
    </para>
    <programlisting><![CDATA[int *(*l) ();]]></programlisting> 
    <para>
        Egy egészre mutató mutatóra mutatót ad vissza a függvényt.
    </para>
    <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>
    <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>
     <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>
      <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>
      <programlisting><![CDATA[
int (*sumormul (int c)) (int a, int b)
{
    if (c)
        return mul;
    else
        return sum;

}
int
main ()
{
 int (*f) (int, int);
int (*(*g) (int)) (int, int);
g = sumormul;
f = *g (0);
return 0;
}]]></programlisting>
<para>Itt az f egy olyan pointer ami egy int típúsú függvényre mutat.Tehát egyszerűen meghívhatunk függvényeket vele, ha egyenlővé tesszük egy 2 egészet kapó függvénnyel.Itt például a szummal ami 2 egészet kap. int sum(int a,int b)</para>
<para>Az f-nek megadjuk a g pointert.Viszont a g már a sumormulra mutat.Tehát egy olyan füvvényre, ami egy egész számot kér és egy két egész számot kapó függvényre hivatkozik.Ha a g-nek 0 át adunk akkor a sum, ha ettől eltérő értéket akkor a mul fog végrehajtódni.Amit így már az f(int,int)-el tudunk hivatkozni és attól függ,hogy melyik függvényre mutat, hogy a g-nek az értéke alapján a g melyik függvényre mutat.</para>
    </section>                     

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
            Írj egy olyan <function>malloc</function> és <function>free</function>
            párost használó C programot, amely helyet foglal
            egy alsó háromszög mátrixnak a szabad tárban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/1MRTuKwRsB0">https://youtu.be/1MRTuKwRsB0</link>,
            <link xlink:href="https://youtu.be/RKbX5-EWpzA">https://youtu.be/RKbX5-EWpzA</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/Savitar97/bhax/blob/master/thematic_tutorials/bhax_textbook/Caesar/tm.c">https://gitlab.com/Savitar97/bhax/blob/master/thematic_tutorials/bhax_textbook/Caesar/tm.c</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            Az alsó háromszög mátrix lényege, hogy a főátló fölött csupa 0-érték helyezkedik el. Az alsó háromszögmátrixokat sorfolytonosan szoktuk ábrázolni, ha M[i,j] a j&gt;i akkor a j értéke 0.
        </para>
        <figure>
             <title>Memória példa</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/doublecsillag2.png" scale="150"/>
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            Az nr-ben inicializáljuk, hogy hány soros és oszlopos legyen a mátrixunk. Ezután létrehozunk(deklarálunk) egy double típúsú mutatóra mutató mutatót, amely egy 2 dimenziós tömb lesz, ez látható a fenti képen.
        </para>
        <para>
            Majd kiiratjuk a címét ennek a mutatónak. Itt még nincs érték adva neki. Ezután a tm-nek a malloc típuskényszerítve double-re visszaad egy pointert a dinamikusan lefoglalt területtel. Egy pointernek lefoglalt hely függ,hogy hány bites a rendszerünk mivel általában 64 bitesek a rendszerek ezért ez 8 bájtos lesz, itt most megszorozzuk az nr el, tehát 40 bájtot foglal le a malloc. Ha nem tudod helyet foglalni akkor visszaad valamilyen hibát,itt a hibakezelést egy egyszerű return -1 oldja meg.
        </para>
        <para>
        Ezzel lefoglaltuk a sorokat azonosító mutatóknak a helyet(5 mutatónak a helyét).  
        </para>
        <para>
         Ezután a következő malloccal a sorokban elhelyezkedő elemekre foglalunk le helyet. Mivel a double mérete is 8 bájt ezért az első sorba 1*8bájtot a következőben 2*8 bájtot és így tovább foglalunk le. Miután ez lefut az elemeknek a helye is le lesz foglalva.
        </para>
        <para>
            Majd kiiratjuk az első sorra hivatkozó mutató memória területét.
        </para>
        <para>
            Majd feltöltjük a mátrixunkat elemekkel ez a forcikus 0-14 ig fogja feltölteni.
            </para>
        <para>
            A következő értékadásokkal kicseréljük a 4.sor elemeit a megadott elemekre csak különböző hivatkozásokkal van felírva, de mind ugyan azt jelenti.
        </para>
        <para>
            A program végén a free felszabadítja a malloc által lefoglalt de nem használt memória területeket.
        </para>
        <figure>
             <title>Alsó háromszög mátrix</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/doublecsillag.png" scale="30"/>
                </imageobject>
        </mediaobject> 
        </figure>     
    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/exor">https://github.com/Savitar97/Prog1/tree/master/exor</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            Az exor titkosítás egy viszonylag egyszerű, de mégis hatékony titkosítási módszer tud lenni.
        </para>
        <para>
            Ha törekszünk arra, hogy a kulcs minél hosszabb legyen. Ugyanis a program működése, hogy a szöveg karakterein egyessével bitenkénti xor műveletet hajtunk végre.Viszont ha a szöveg hoszabb,mint a kulcs akkor a kulcs ismétlődésével érjük el a titkosítást.Tehát például 8 karakterű kulcsnál a szöveg első karakterét a kulcs első karakterével exorozzuk, a másodikat a másodikkal és így tovább.
        </para>            
        <para>
            A programban elsőként definiáltuk a max kulcsméretet és a max buffer méretet.Deklarálunk 2 char tömböt ezek segítségével, majd deklarálunk és inicializáltunk 2 változót ez a kulcs_index és az olvasott_bajtok.
        </para>
        <para>
            Majd az int kulcs_meretbe megadjuk, hogy mekkora a kulcsunk ezt az argv[1] karakter tömbjének mérete adja. Ugyanis az argv az a futtatáskor bemenő egységeket nézi az argv[0] maga a futtatás parancsa a terminálta a ./fájlnév. Az 1 itt a kulcs amit megadunk. Ezek char mátrixok. Azt, hogy hány bemenet van az az ilyen char tömb az az argc-ben van letárolva ami ezeknek a számát kapja értékül.
        </para>
        <para>
            A strncpy-vel másoljuk át a bemenetben megadott kulcsot az argv[1]-tömbből a kulcs tömbbe. A while beolvassa a txt-t az első karaktertől a végéig(a buffer méretéig), a read visszatérési értéke a beolvasott bájtok száma.A for ciklus végig megy a szövegen és ez titkosítja a maradékos osztással éri el a program, ha kisebb a kulcs mint a szöveg, akkor a kulcs ismétlődésével titkosítsunk.
        </para>
        <para>
            A write és a read is ha negatív értéket kap akkor hibát fog kiírni.
         </para>
         <para>
             A readnél a 0 azt jelenti, hogy a standard inputról olvasson.A writenál az 1 es, hogy a standard outputba írjon azaz ez oldja meg, hogy a megadott szövegfájlt olvassa be és a megadott fájlba írja ki.
         </para>
         <para>
             Fordítani a szokásos módon tudjuk. Futtatási segédlet a következő minta:<programlisting><![CDATA[
            ./exor kulcs <bemenőszöveg.txt>titkosítottszöveg.txt
       ]]></programlisting> 
         </para>
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <caution>
            <title>
                Tutorált
            </title>
            <para>Ebben a feladatban tutorált Molnár Antal.</para>
        </caution>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog1/tree/master/exor">https://github.com/Savitar97/Prog1/tree/master/exor</link>                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para> 
        <para>
            A programunk úgy kezdődik h létrehozunk egy Exor osztályt. Majd létrehozunk egy stringet,amelyben a  kulcsot tároljuk és nyitunk két csatornát egy bejövőt és egy kimenőt az olvasás íráshoz. A throws a hibakezeléshez kell ha nem sikerül a beolvasás vagy kiiratás akkor hibát dob. Ezután definiálunk egy byte változót a buffernek és egy kulcs indexet, amely a kulcs első karakterére hivatkozik kezdetben és egy olvasott bájtokat, amely a beomenetről beolvasott szöveg hosszával egyenlő. Aztán a while-al olvassuk be a szöveget és letároljuk a bufferben közben a méretét az olvasott bájtokba. Aztán a forban titkosítunk a maradékos osztás azért szükséges, hogy ha a szöveg hosszabb mint a kulcs akkor a kulcs index ismét 0-tól kezdődjön mivel karakterenként történik a titkosítás. Majd a végén a write-al a megadott kimenetre írunk.
        </para>           
    </section>        
    <section>
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog1/tree/master/exor">https://github.com/Savitar97/Prog1/tree/master/exor</link>                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            Az exor törés az exor visszafejtése. Ez olyan mint a brutal force, addig próbálgatjuk a kulcs kombinációkat, amíg vissza nem kapjuk a szöveget.
        </para>
        <para>
            Annak meghatározásához, hogy jó -e a szöveg most két függvényt írtunk egyik szempont az átlagos szóhosszak figyelembe vétele a másik pedig,a mondatokban gyakran előforduló szavak.
        </para>
        <para>
            Az átlagos szóhosszt úgy kapjuk, hogy megszámoljuk hány darab space van a szövegben, majd a bemenő szöveg hosszát elosztjuk a szóközök számával.
        </para>
        <para>
            Az exorban ugyan azt csináljuk mint a titkosításnál csak most vissza fejtjük a titkos szöveget.
        </para>
        <para>
            Az exortörésben meghívjük az exor eljárást majd az exorozott szöveget átadjuk a tiszta lehetnek vizsgálatra,ha passzol akkor majd a brutal force-s forban az if igaz lesz és kiirja a terminálra a kulcsot és a megfejtett szöveget.
        </para>
        <para>
            A mainbe szintén definiáljuk a kulcsot és a titkos szöveget,a p-titkossal megkapjuk a szöveg méretét. A while-ban hívjuk be a titkos szöveget. A while-t követő forban pedig mindig 0-ázzuk a bufferben a maradék helyet. Ezután jönnek a kulcspróbálgatásos for ciklusok, amelyek a törést végzik, itt párhuzamosítva a gyorsabb működés érdekében.Ha nem állt le a for akkor újra exorozunk,így nincs szükség újabb meg újabb bufferre.
        </para>
        <para>
            Így néz ki a program futás közben:
        </para>
        <figure>
             <title>Exortörés</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/exor.png" scale="25"/>
                </imageobject>
        </mediaobject>
        </figure>
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <caution>
            <title>
                Tutor
            </title>
            <para>Ebben a feladatban tutoráltam Molnár Antalt.</para>
        </caution>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para> 
        <para>
            A program futtatásához az R-hez hozzá kell adnunk a neuralnetwork library-t. Ezután megadjuk neki az első mintát, ami alapján majd tanulni fog a program,tehát megoldunk egy minta feladatot. Tehát a program előre tudja mi lesz a bemenet és a kimenet. A program automatikusan választ súlyokat majd az értéket szorozzuk ezzel a súlyjal és összeadjuk őket és hozzáadja az eltolás mértékét. Majd behelyettesít egy 1/(1+exp(-x)) függvénybe. A kapott eredmény mindig 0 és 1 közé fog esni. A neural net függvénynél elsőnek megadjuk, hogy milyen értéket kell kapnunk ez az OR-nak az értéke Ha több kimeneti értéket számolunk akkor +-t használunk a felsoroláshoz, majd a ~-al adjuk meg, hogy miből kell ezt az eredményt kapnia, azaz a bemenetet.Következőnek megadjuk,hogy honnan vegye a bemenő adatokat.(Pl.:or.data,orand.data)
        </para>
        <para>
            Ha növeljük a rejtett neuronok számát akkor pontosodik az érték és kevesebb lépésből képes meghatározni az eredményt az az több mintát készít. A stepmax meghatározza a maximum lépések számát. A threshhold a küszöbfüggvény, ez amolyan leállási kritérium. Majd a compute kiadásával már számol a megtanult módon itt ellenőrizhetjük, hogy megtanulta -e a program a számítást. Lényegében a program próbál olyan értékpárokat találni súlynak és eltolási értéknek, amivel egy megközelítőleg hasonló értéket kap mint a mintában neki végeredményként megadott adat.
        </para> 
        <figure>
             <title>Signum függvény</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Rplot1.png" scale="100"/>
                </imageobject>
        </mediaobject> 
        </figure>         
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64">https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64</link>             
        </para>
        <para>
            <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/perceptron">https://github.com/Savitar97/Prog1/tree/master/perceptron</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            A hiba-visszaterjesztéses perceptron(back-propagation) a rejtett rétegekben fellépő hibákat is a tudtunkra hozza. Vagyis ami a színfalak mögött történik. Ugyanis a végeredmény kiszámításánál létrejövő hibákért már a rejtett rétegben kialakult hibák a felelősek. Az ilyen visszaterjesztési perceptronokat csak olyan neurális hálóknál lehet alkalmazni ahol van hidden réteg. A visszaterjesztés a legutolsó rejtett neurontól kezdődik ellentétesen mint az alap számolás,tehát a kimenet előtti neurontól. A visszaterjesztéses módszer lényege,hogy frissített súlyjal megbecsüljük, hogy az előző neuron mennyire hibázott a kívánt értéktől ez jó iránymutatást adhat a súlyok javításán. A program bekér egy képet. Majd a size-ban definiáljuk a kép méretét(szélesség*magasság).Majd a for ciklusban végig megyünk a kép pixelein. Példányosítjuk a perceptron osztályunkat, amely majd annyi neurális szintet képez ahány bemenet van, és annyi az argumentumok amiket kap generálja az egyes rétegeken a neuronok számát mint az R es példánál ha a hidden=c(2,3,2)-t használtuk például akkor azt jelentette hogy az első rétegen 2, a 2.-on 3 a 3.on megint 2 neuron legyen.Az utolsó érték azért 1 mert végül egy neuronon kell összekapcsolni minden értéket, amely majd a kimenethez csatlakozik. A perceptron a szigmoid függvényt használja 1.0/ ( 1.0 + exp ( -x ) ). Az unitsba tároljuk majd le a súlyjal megszorzott értékünket. Amelyről majd a sigmund megmondja, hogy jó -e vagy sem. A learning eljárásban történik a visszaterjesztés.Annak kiszámítása, hogy mekkora volt az eltérés úgy történik, hogy a sigmoid-al kiszámolt értéket kivonjuk az 1.0-ból az az a felső határból majd frissítsük a súlyokat és újra megnézzük.A perceptron kimenete egyetlen egy érték lesz, amely egy pixel, a visszakapott érték pedig egy 1 és 0 közé eső szám.
         </para>
         <figure>
             <title>Perceptron</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/perceptron.png" scale="30"/>
                </imageobject>
        </mediaobject> 
        </figure>          
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>A Mandelbrot halmaz</title>
        
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/mandelcomplex">https://github.com/Savitar97/Prog1/tree/master/mandelcomplex</link>              
        </para>
        <para> 
            A program elején definiáljuk a kép méretét és az iterációs határt mivel végtelen számra nem tudjuk megnézni ezért kell valamilyen korlát.      
        </para>
        <para>
            A mainben most használjuk az argc és argv-t, ez csak azért kell,hogy megadhassuk hogy milyen néven mentse el a kimenetet. Ha nem adunk meg fájl nevet az első if fog hibaüzenetet dobni nekünk.
        </para>
        <para>
            Ezután létrehozunk egy 2 dimenziós tömböt a kép méreteivel. Ezután a mandel függvénynek átadjuk ezt a tömböt. Itt vannak a futási időhöz való számítást segítő változók. De ami lényeg az a számoláshoz tartozó változók és, hogy az adott komplex szám a halmaznak eleme -e, ez akkor lehetséges ha a z kisebb mint 2 vagy elértük a 255. iterációt. Majd feltöltjük a tömböt. Majd létrehozunk egy új képet kép néven és pixelenként bejárjuk és ami benne van a halmazba elem azon a helyen a képkocka színét átszínezzük. Majd a write(argv[1])-el a megadott fájlnévvel készítünk egy képet. Az így kapott ábra a mandelbrot halmaz grafikus megjelenítése, amely egy fraktál az az egy végtelenül komplex alakzat lesz. Vagyis minél jobban rá nagyítunk ismétlődésként megfog jelenni ez az ábra.
        </para>
        <figure>
             <title>Mandelbrothalmaz</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel.png" scale="50"/>
                </imageobject>
        </mediaobject>
        </figure>
    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
                
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/mandelcomplex">https://github.com/Savitar97/Prog1/tree/master/mandelcomplex</link>              
        </para>
        <para>
            Ez a program ugyan az mint az előző csak most a complex osztályt fogjuk használni. Elsőként felvesszük a kezdetleges változókat vagyis, hogy mekkora legyen majd a kép mérete, hányszor fogunk iterálni és az intervallumot amin ábrázolni szeretnénk. Ezeket majd konzolról kérjük be de inicializáljuk, majd az if megvizsgálja megvan -e a kellő bemeneti adat, ha nincs akkor hibaüzenetet dob a program hasznáaltára.
        </para>
        <para>
            Ezután létrehozunk egy üres képet a mérettel és a szélességgel. Ezután a dx és dy al megadjuk, hogy minden egyes lépéssel mennyit megyünk előre azaz a lépésközöket. A következő for ciklussal végig megyünk a képnek a képpontjain. Ezután kiszámoljuk C-nek a valós és imaginárius részét és ezeket átadjuk a komplex C számnak.Majd létrehozunk egy z_n komplex számot és inicializáljuk. Ezután jön egy while ciklus ami addig megy amíg a z_n abszolút értékben kisebb mint 4 vagy pedig elértük az iterációs határt. Majd a while ciklus törzsében kiszámoljuk a z_n értékék és növeljük az iterációs határt. Majd ha kilép a while ciklusból a képnek az adott sorában és oszlopában lévő pixel színét átállítjuk. Az int százalékkal a feldolgozás állását közvetítjük a consolra. Végén kiiratjuk a képet a megadott fájlba.
        </para>
        <figure>
             <title>Mandelbrot halmaz komplex osztállyal</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel1.png" scale="20"/>
                </imageobject>
        </mediaobject> 
        </figure>
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
            A biomorfos program abban különbözik az előzőtől, hogy most több argumentumot tudunk megadni tehát adhatunk kezdőértéket egy komplexszámnak cc-nek, amelyet majd z-hez mindig hozzáadunk. A bekért karakterket az atoi intté alakítja míg az atof lebegőpontos számmá. Az előzőhöz képest ahol egy while-t futtattam, hogy eldöntsem mely elemeket tartoznak a halmazba és ez a feltétel az volt hogy abszolút értékbe a z komplex szám kisebb mint négy, vagy elértük -e az iterációs határt. Ez a feltétel most annyiban változott, hogy R ben megadhatjuk hogy mekkora érték felett kell legyen a z valós vagy z imaginárius részének és csak akkor növeljük az iterációk számát(ez egy küszöbérték), vagyis az iteráció azt az értéket fogja megkapni a 0-és az iterációs határ között,amelyre még teljesül a feltétel. Emellett még lényeges változtatás, hogy eddig csak az iterációt osztottuk maradékosan a kép színeihez, de mostmár konstansokkal szorozzuk meg a különböző színeket előállító képletet. Ez színesebb képet fog eredményezni és a több argumentum nagyobb szabadságot nyújt a felhasználónak,hogy különböző képeket alkosson.
            A biomorfos képek az egysejtűekre hasonlítanak, elég érdekes formákat lehet alkotni a program segítségével.
        </para>
        <para>
            Az általam létrehozott biomorf amely szerintem egész jól néz ki:
        </para>
        <figure>
             <title>Biomorf</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/bmorf.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure>                      
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <caution>
            <title>
                Tutorált
            </title>
            <para>Ebben a feladatban tutorált Molnár Antal.</para>
        </caution>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/Savitar97/bhax/tree/master/attention_raising/CUDA">https://gitlab.com/Savitar97/bhax/tree/master/attention_raising/CUDA</link>
             
        </para>
        <para><link xlink:href="https://www.nvidia.com/docs/IO/116711/sc11-cuda-c-basics.pdf">https://www.nvidia.com/docs/IO/116711/sc11-cuda-c-basics.pdf</link></para>
        <programlisting language="c"><![CDATA[
    #include <png++/image.hpp>
#include <png++/rgb_pixel.hpp>

#include <sys/times.h>
#include <iostream>


#define MERET 600
#define ITER_HAT 32000

__device__ int
mandel (int k, int j)
{
  // Végigzongorázza a CUDA a szélesség x magasság rácsot:
  // most eppen a j. sor k. oszlopaban vagyunk

  // számítás adatai
  float a = -2.0, b = .7, c = -1.35, d = 1.35;
  int szelesseg = MERET, magassag = MERET, iteraciosHatar = ITER_HAT;

  // a számítás
  float dx = (b - a) / szelesseg;
  float dy = (d - c) / magassag;
  float reC, imC, reZ, imZ, ujreZ, ujimZ;
  // Hány iterációt csináltunk?
  int iteracio = 0;

  // c = (reC, imC) a rács csomópontjainak
  // megfelelő komplex szám
  reC = a + k * dx;
  imC = d - j * dy;
  // z_0 = 0 = (reZ, imZ)
  reZ = 0.0;
  imZ = 0.0;
  iteracio = 0;
  // z_{n+1} = z_n * z_n + c iterációk
  // számítása, amíg |z_n| < 2 vagy még
  // nem értük el a 255 iterációt, ha
  // viszont elértük, akkor úgy vesszük,
  // hogy a kiinduláci c komplex számra
  // az iteráció konvergens, azaz a c a
  // Mandelbrot halmaz eleme
  while (reZ * reZ + imZ * imZ < 4 && iteracio < iteraciosHatar)
    {
      // z_{n+1} = z_n * z_n + c
      ujreZ = reZ * reZ - imZ * imZ + reC;
      ujimZ = 2 * reZ * imZ + imC;
      reZ = ujreZ;
      imZ = ujimZ;

      ++iteracio;

    }
  return iteracio;
}


/*
__global__ void
mandelkernel (int *kepadat)
{

  int j = blockIdx.x;
  int k = blockIdx.y;

  kepadat[j + k * MERET] = mandel (j, k);

}
*/

__global__ void
mandelkernel (int *kepadat)
{

  int tj = threadIdx.x;
  int tk = threadIdx.y;

  int j = blockIdx.x * 10 + tj;
  int k = blockIdx.y * 10 + tk;

  kepadat[j + k * MERET] = mandel (j, k);

}

void
cudamandel (int kepadat[MERET][MERET])
{

  int *device_kepadat;
  cudaMalloc ((void **) &device_kepadat, MERET * MERET * sizeof (int));

  // dim3 grid (MERET, MERET);
  // mandelkernel <<< grid, 1 >>> (device_kepadat);
  
  dim3 grid (MERET / 10, MERET / 10);
  dim3 tgrid (10, 10);
  mandelkernel <<< grid, tgrid >>> (device_kepadat);  
  
  cudaMemcpy (kepadat, device_kepadat,
	      MERET * MERET * sizeof (int), cudaMemcpyDeviceToHost);
  cudaFree (device_kepadat);

}

int
main (int argc, char *argv[])
{

  // Mérünk időt (PP 64)
  clock_t delta = clock ();
  // Mérünk időt (PP 66)
  struct tms tmsbuf1, tmsbuf2;
  times (&tmsbuf1);

  if (argc != 2)
    {
      std::cout << "Hasznalat: ./mandelpngc fajlnev";
      return -1;
    }

  int kepadat[MERET][MERET];

  cudamandel (kepadat);

  png::image < png::rgb_pixel > kep (MERET, MERET);

  for (int j = 0; j < MERET; ++j)
    {
      //sor = j;
      for (int k = 0; k < MERET; ++k)
	{
	  kep.set_pixel (k, j,
			 png::rgb_pixel (255 -
					 (255 * kepadat[j][k]) / ITER_HAT,
					 255 -
					 (255 * kepadat[j][k]) / ITER_HAT,
					 255 -
					 (255 * kepadat[j][k]) / ITER_HAT));
	}
    }
  kep.write (argv[1]);

  std::cout << argv[1] << " mentve" << std::endl;

  times (&tmsbuf2);
  std::cout << tmsbuf2.tms_utime - tmsbuf1.tms_utime
    + tmsbuf2.tms_stime - tmsbuf1.tms_stime << std::endl;

  delta = clock () - delta;
  std::cout << (float) delta / CLOCKS_PER_SEC << " sec" << std::endl;

}

  ]]></programlisting>
        <para>
            Lényegében itt azt kell megfigyelnünk, hogy mennyivel gyorsabban dolgoznak a cuda magok a processzornál. A processzornál ugyebár a képpontokat szekvenciálisan számljuk tehát a processzor egyessével számolja a képpontokat.Ez a cudanál egyszerre történik most az az minden egyes képpontot egy szál fog számolni a számolás egyszerre történik mint a párhuzamos programoknál. Ez hatalmas sebességbeli növekedést eredményez konkrétan egy pillanat alatt végez a program ha elég erős a videókártyánk, mivel itt már a gpu számol nem a cpu. Ez azért lehetséges mivel a GPU-ban sokkal több szál van mint a processzorban.
            A programban a cudaMalloccal foglalunk helyet a GPU-n dinamikusan történik, amely a kép méretei alapján és az int mérete alapján történik.A dim3 adja meg a blokkok és szálak méretét, ezzel 3 dimenzióban szoktuk megadni,de itt most csak 2-t használunk. Külön figyelmet kíván a:
        </para>
         <programlisting language="c"><![CDATA[
       <<<
             és
       >>>
             operátor.

  ]]></programlisting>
  <para>
      Ezekkel használjuk a kernelt azt hogy hány szálat szeretnénk futtatni és hány blokkra osztjuk fel ezeket a szálakat azaz ez a párhuzamos kernelünk, a grid a legfelsőbb szintje az az ez olyan mint egy keret(rács),amely összefogja a blokkokat és szálakat, ezen kívül a tgrid a blokk méretet számolja ki.Ezeket adjuk át a kernelnek. A global típúsú függvények az eszközön futnak és a processzoron futó program hívja meg, míg  a device kódokat a processzor nem tudja meghívni ezek csak a videókártyán használhatók. A cudaMemcpyvel tudunk adatokat mozgatni a videókártyán számolt adat és a processzor között.Mivel dinamikusan forglaltunk memóriát itt is fel kell szabadítani ezt a cudaFree-vel érjük el.
  </para>
  <figure>
             <title>Mandel CUDA</title>
  <mediaobject>
                <imageobject>
                    <imagedata fileref="img/cuda.png" scale="200"/>
                </imageobject>
        </mediaobject>
  </figure>
        <para>Először cudával lett futtatva majd azután C-ben processzorral.</para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <caution>
            <title>
                Tutor
            </title>
            <para>Ebben a feladatban tutoráltam Kun-Limberger Anettet és Duszka Ákos Attilát.</para>
        </caution>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
            
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/Nagyito">https://github.com/Savitar97/Prog1/tree/master/Nagyito</link> 
        </para>

        <para>
            Megoldás videó: 
        </para>
        <para>
            Újra a mandelbrot halmazzal fogunk foglalkozni, de most felhasználjuk a qt-t hogy létrehozzunk egy grafikus interfacet. A programban a tartományt ugyan úgy az a, b , c és d változó határozza meg A képlet most is ugyan az mint a legelsőnél, amivel számoljuk az iterációt: z_(n+1) = z_n * z_n + c, ez a számolás a frakszal.cpp-ben van. A számításokat soronként küldjük vissza a frakablaknak, amely majd elvégzi a színezést. A változó deklarációja és inicializálása a számításokhoz a frakablak.h-ban található.A frakablak.cpp-ben definiáljuk, hogy mit csináljon a program az egérmozgására és, hogyha kijelölünk egy területet az egérrel akkor arra a területre nagyítson rá. Tehát a mousepressevent letárolja a kattintásunk koordinátáit, míg a mousemove a szélességet és a magasságot tehát, hogy az adott pontból mekkora területet jelöltünk ki. Majd a felengedéskor újra számol és rá zoomol a területre.Az N gomb lenyomásával változtathatjuk az iterációs határt amivel változik a kép részletessége is, ugyanis az N gomb lenyomására az iterációs határ kétszereződik emiatt nagyobb lesz a részletessége a képnek,így amikor jobban rá zoomolunk akkor nem csak olyan mintha egy sima képre nagyítanánk mivel ha az iterációs határ megnő akkor a mandelbrothalmaznak egyre több eleme lesz emiatt változik a kép is.Persze minden számolás után update-eljük az osztáyban lévő értékeket. Az újra számoláshoz készítünk mindig egy új FrakSzal-t, a régi mandelbrot halmazt töröljük és a frissített iterációshatárral számolunk.  
        </para>
        <figure>
             <title>Mandelbrot nagyító</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandelzoom.png" scale="50"/>
                </imageobject>
        </mediaobject> 
        </figure>
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <caution>
            <title>
                Tutor
            </title>
            <para>Ebben a feladatban tutoráltam Kun-Limberger Anetett és Duszka Ákos Attilát.</para>
        </caution>
        <para>
        Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/javacnagyito">https://github.com/Savitar97/Prog1/tree/master/javacnagyito</link> 
        </para>
        <para>
            A mandelbrot nagyító javában. Mivel a mandelbrot javás programunkhoz készítünk nagyítót, ezért ez lesz a szülő osztály. A származtatást az extends kifejezéssel érjük el.
            Létrehozunk két változót private jogosultságokkal. Az elsőben azt a pontot tároljuk el, ahova kattintunk majd az egérrel tehát a kezdő pont koordinátáit. A másik az egér jelenlegi pozícióját fogja tárolni.
            Ez a terület kijelölésénél lesz majd fontos, hogy mekkora területet jelölünk ki. Majd meghívjuk az osztály konstruktorát public jogosultságokkal és 6 argumentummal, amelyből az első 4 argumentum a tartományt adja meg.Majd a tömbnek a méretét, amelyben a halmaz szerepel.
            Majd a nagyítási pontosságot, a képen ez adja azt, hogy minél részletesebb legyen a többszörös nagyításnál. Ezt követően a superrel meghívjuk az ős osztály konstruktorát az argumentumaival. A supert többféle képpen lehet használni. Képesek vagyunk vele azonnal a szülő osztály konstruktorát argumentumokkal vagy nélküle,esetleg a változóit,függvényeit meghívni.
            A settitle-vel adjuk meg az ablaknak a nevét. Majd a mouseListenerrel figyeljük az egér vezérlést. Ha kattintunk akkor letároljuk a koordinátáit az egérnek.Felengedéskor a megadott tartományt újra számoljuk. És létrehozunk egy új objektumot a halmaznak, amelyet kirajzolunk.  A nagyítandó területet úgy számoljuk, hogy a jelenlegi egér pozícióból, azaz a négyszög jobb alsó sarkából kivonjuk a bal felső sarok koordinátáit, ez lesz az mx és my.
            Az s lenyomásával pillanatfelvételt készíthetünk a fájl nevében megjlenítsük, hogy milyen tartományi értéknél készítettük a képet.Az n gombbal változtatunk az iterációs értékeken mindig növeljük a pontosságot 256 al. Az m-el ugyan úgy növeljük a pontosságot de itt 10*256-al pontosítunk. Majd jön a kép kirajzolása, ha számítást végzünk akkor egy vörös vonallal jelezzük az állapotát ezt a drawline éri el. A számításhoz a kijelölt területet zölddel jelezzük, ezt a drawrect éri el. Végül a mainbe létrehozunk egy mandelbrot halmaz példányt és már futtathatjuk is a programunkat.</para>
           <para> A fordítás a következővel hajtjuk végre: <command>javac MandelbrotHalmazNagyító.java</command>.</para><para> A futtatást pedig, így hajtjuk végre:<command>java MandelbrotHalmazNagyító</command>.
            
        </para>
        <figure>
             <title>Java Mandelbrot nagyító</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Mandelnagyit.png" scale="100"/>
                </imageobject>
        </mediaobject>
        </figure>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban az módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/polar">https://github.com/Savitar97/Prog1/tree/master/polar</link>              
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... térj ki arra is, hogy a JDK forrásaiban a Sun programozói
            pont úgy csinálták meg ahogyan te is, azaz az OO nemhogy nem nehéz, hanem éppen természetes neked!
        </para>
        <programlisting language="java"><![CDATA[
        public class PolarGen 
        {

            boolean nincsTarolt = true;
             double tarolt;

             public PolarGen () 
            {

             nincsTarolt = true;

            }

            public double kovetkezo () 
            {

            if (nincsTarolt) 
            {

                double u1, u2, v1, v2, w;
                do
                {
                         u1 = Math.random();
                         u2 = Math.random();
                         v1 = 2 * u1 - 1;
                         v2 = 2 * u2 - 1;
                         w = v1 * v1 + v2 * v2;
                }
                while (w > 1);

            double r = Math.sqrt ((-2 * Math.log (w)) / w);

            tarolt = r * v2;
            nincsTarolt = !nincsTarolt;

            return r * v1;
        }
        else
        {
            nincsTarolt = !nincsTarolt;
            return tarolt;
        }

    }


    public static void main (String[] args) 
    {
        PolarGen pg = new PolarGen();

        for (int i = 0; i < 10; ++i) 
        {
            System.out.println(pg.kovetkezo());
        }

    }

    }
     ]]>
        </programlisting> 
        <para>
            Elsőként létrehozzuk a polargen osztályt.Amelyben deklarálunk egy konstruktort és egy destruktort. A konstruktorban egy a private részben tárolt nincstarolt nevű bool típúsú változót inicializálunk és meghívjuk a randomot. És létrehozunk még egy következő nevű double függvényt.
        </para>
        <para>
            A private részben két változót deklarálunk egyik a tarolt a másik a nincstarolt. Ezután a PolarGen névtérben lévő kovetkezo függvényt írjuk le, ha a nincstarolt=true akkor létrehozunk 5 változót az u1 és az u2 random értéket vesznek fel és ezeket az értékeket felhasználjuk a v1 és v2 értékek kiszámolásánál. Majd a w a v1 és v2 értékek négyzetének az összege. Ez az érték addig változik, amíg nem lesz kisebb az értéke w-nek 1-nél, a do while miatt legalább 1x lefut a ciklus. Majd egy r változóba a gyökét veszi a -2*log(w)-nek, amelyet eloszt w-vel. Majd ezt az értéket felhasználja a tarolt-nál, amely a private-ban lévő változóba teszi az értéket az r*v2-t és a nincstaroltat negáljuk tehát az értéke true helyett false lesz. A visszatérési értéke a fv-nek r*v1 lesz.  
        </para>
        <para>
            Ha már van tárolt érték akkor pedig azzal tér vissza. Majd a main-be meghívjuk az osztályunkat pg néven és a forral létrehozunk 10 mintapéldányát az osztálnyak. Ez az osztály a random számgenerálás osztálya. Tehát végülis 10 véletlen számot fog generálni nekünk a program a Java-ban ez az osztály ugyan így szerepel a forrásfáflok közt Random.java néven találjuk a mappában. Az objektum orientáltságnak 3 lényeges pontja van az egyik, hogy az összetartozó adatok képekes legyenek egy zárt adategységet alkotni. Az adatrejtés segítségével kezeljük a jogosultságokat vagyis, hogy az előtt említett egységből, ki milyen adatokat képes elérni(private,protected,public). Emellett a harmadik fontos tulajdonság az öröklődés. Öröklődés során az "utód" örökli a szülője összes tulajdonságát, de lehetőségünk van még plusz tulajdonságokat adni neki.
        </para>
        <figure>
             <title>Polargen random</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/sourcejava.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure>
    </section>        

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Savitar97/Prog1/blob/master/binfac/binfa.c">https://github.com/Savitar97/Prog1/blob/master/binfac/binfa.c</link>              
        </para>
        <para>
            Ez a bináris fa, a bináris fák egy speciális típúsa ugyanis LZW algoritmust használ, ami egy tömörítő algoritmus.
        </para>
        <programlisting language="c"><![CDATA[
       #include <stdio.h>
#include <stdlib.h>
#include <unistd.h>



typedef struct binfa
{
  int ertek;
  struct binfa *bal_nulla;
  struct binfa *jobb_egy;

} BINFA, *BINFA_PTR;

BINFA_PTR
uj_elem ()
{
  BINFA_PTR p;

  if ((p = (BINFA_PTR) malloc (sizeof (BINFA))) == NULL)
    {
      perror ("memoria");
      exit (EXIT_FAILURE);
    }
  return p;
}
extern void kiir2 (BINFA_PTR elem);
extern void kiir1 (BINFA_PTR elem);
extern void kiir (BINFA_PTR elem);
extern void szabadit (BINFA_PTR elem);

int
main (int argc, char *argv[])
{
  char b;
  if (argv[1][0]!='-')
  	{perror("használat ./binfa -kapcsolo");
  	return -1;
}
  if(argc!=2)
  {
  	perror("nincs kapcsolo ./binfa -kapcsolo");
  	return -2;
  }

  char kapcsolo=argv[1][1];
  BINFA_PTR gyoker = uj_elem ();
  gyoker->ertek = '/';
  BINFA_PTR fa = gyoker;

  while (read (0, (void *) &b, 1))
    {
      write (1, &b, 1);
      if (b == '0')
	{
	  if (fa->bal_nulla == NULL)
	    {
	      fa->bal_nulla = uj_elem ();
	      fa->bal_nulla->ertek = 0;
	      fa->bal_nulla->bal_nulla = fa->bal_nulla->jobb_egy = NULL;
	      fa = gyoker;
	    }
	  else
	    {
	      fa = fa->bal_nulla;
	    }
	}
      else
	{
	  if (fa->jobb_egy == NULL)
	    {
	      fa->jobb_egy = uj_elem ();
	      fa->jobb_egy->ertek = 1;
	      fa->jobb_egy->bal_nulla = fa->jobb_egy->jobb_egy = NULL;
	      fa = gyoker;
	    }
	  else
	    {
	      fa = fa->jobb_egy;
	    }
	}
    }
switch(kapcsolo)
{
	case 'i':printf ("Inorder\n");
  kiir (gyoker);
  break;
  case 'p':printf ("Preorder\n");
  kiir1 (gyoker);
  break;
  case 'o':printf ("Postorder\n");
  kiir2 (gyoker);
  break;
  default: printf("%s\n","Hibás a kapcsolo.");
  break;
}
  
  
  
  extern int max_melyseg;
  printf ("melyseg=%d", max_melyseg);
  szabadit (gyoker);
}

static int melyseg = 0;
int max_melyseg = 0;

void
kiir (BINFA_PTR elem)
{
  if (elem != NULL)
    {
      ++melyseg;
      if (melyseg > max_melyseg)
	max_melyseg = melyseg;
      kiir (elem->jobb_egy);
      for (int i = 0; i < melyseg; ++i)
	printf ("---");
      printf ("%c(%d)\n", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek,
	      melyseg);
      kiir (elem->bal_nulla);
      --melyseg;
    }
}
void
kiir1 (BINFA_PTR elem)
{
  if (elem != NULL)
    {
    	++melyseg;
      if (melyseg > max_melyseg)
	max_melyseg = melyseg;
	for (int i = 0; i < melyseg; ++i)
	  printf ("---");
      printf ("%c(%d)\n", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek,
	      melyseg);
      kiir (elem->jobb_egy);

      kiir (elem->bal_nulla);
      --melyseg;
    }
}
void
kiir2 (BINFA_PTR elem)
{
  if (elem != NULL)
    {
    	
      ++melyseg;
      if (melyseg > max_melyseg)
	max_melyseg = melyseg;
      kiir (elem->jobb_egy);
	    kiir (elem->bal_nulla);
      	    for (int i = 0; i < melyseg; ++i)
	        printf ("---");

            printf ("%c(%d)\n", elem->ertek < 2 ? '0' + elem->ertek : elem->ertek,
	      melyseg);
      --melyseg;
    }
}

void
szabadit (BINFA_PTR elem)
{
  if (elem != NULL)
    {
      szabadit (elem->jobb_egy);
      szabadit (elem->bal_nulla);
      free (elem);
    }
}
     ]]>
        </programlisting> 
        <para>
            Kezdésképp létrehozunk egy struktúrát binfa néven, amely tartalmaz egy értéket és 2 struktúra típúsú mutatót. A BINFA és *BINFA_PTR a typedefnek a kulcsszavai mindkettő binfa típúsú lesz. 
         </para>
         <para>
             Ezután meghívunk egy BINFA_PTR típúsú függvényt, amely visszaadja majd értékül a példányosított p eredményét, amely egy sikeres dinamikus memória foglalás az új elemnek.
         </para>
         <para>
             A következő két eljárásnál az externnel jelezzük a fordítónak, hogy majd a program végén fogjuk deklarálni őket.A kiirba ha van elemünk a fában akkor növeljük a mélységet ha a mélység nagyobb mint a maximum mélység akkor ezt egyenlővé tesszük majd kiiratjuk elsőként a jobbos elemet majd a balost és visszacsökkentjük a mélységet. A szabaditnál a fölöslegesen lefoglalt tárhelyet szabadítjuk fel.
         </para>
         <para>
             Létrehozunk egy karater típúsú változót, amely majd azt mutatja milyen elem megy be a fába. Ezután deklarálunk és inicializáljuk a fának a gyökerét majd a fa mutatót ráállítjuk a gyökérre ezután majd a while ciklusban pakolgatjuk az elemeket jobbra vagy balra attól függően hogy milyen elem megy be a fába, ha nincs több érték az adott ágon akkor visszaállítjuk a mutatót a gyökérre.
          </para>
    </section>        
        
    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/blob/master/binfac/binfa.c">https://github.com/Savitar97/Prog1/blob/master/binfac/binfa.c</link>              
        </para>
        <para>
               A fabejárás 3 különböző féle képpen történhet.Lehet inorder amikor a baloldalt veszi először majd a gyökeret irassa ki és csak aztán tér át a jobb oldalra. A második lehetőség a preorder itt a gyökeret irassa ki először, majd a bal oldalt és végül a jobb oldalt. A legutolsó variáció a postorder, amikor elsőként irassuk ki a bal oldalt majd a jobb oldalt és csak végül a gyökeret. Inordernél a csomópontok mindig középre kerülnek.
               </para>
               <para>
                   A lényeg hogy mikor irassuk ki az egyes és nullás gyermeket, ha a forciklus előtt akkor postorder, ha a forciklus után akkor preorder, ha pedig az egyest a forciklus előtt és a nullást a forciklus után akkor inorder bejárással irassuk ki a bináris fánkat.
                </para>
                <para>
                    Inorder bejárás:
                 </para>
                 <figure>
             <title>Inorder bejárás</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/inorder.png" scale="30"/>
                </imageobject>
        </mediaobject>
                 </figure>
        <para>
                    Preorder bejárás:
                 </para>
                 <figure>
             <title>Preorder bejárás</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/preorder.png" scale="30"/>
                </imageobject>
        </mediaobject>
                 </figure>
        <para>
                    Postorder bejárás:
                 </para>
                 <figure>
             <title>Postorder bejárás</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/postorder.png" scale="30"/>
                </imageobject>
        </mediaobject>
                 </figure>
    </section>        
                   
    <section>
        <title>Tag a gyökér</title>
        <caution>
            <title>
                Tutor
            </title>
            <para>Ebben a feladatban tutoráltam Ádám Petrát.</para>
        </caution>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Bevprog/tree/master/vedes">https://github.com/Savitar97/Bevprog/tree/master/vedes</link>               
        </para>
        <programlisting language="c"><![CDATA[
      

#include <iostream>		// mert olvassuk a std::cin, írjuk a std::cout csatornákat
#include <cmath>		// mert vonunk gyököt a szóráshoz: std::sqrt
#include <fstream>		// fájlból olvasunk, írunk majd



class LZWBinFa
{
public:

    LZWBinFa ()
    {
        gyoker = new Csomopont();
      fa=gyoker;
        }
    ~LZWBinFa ()
    {
        szabadit (gyoker->egyesGyermek ());
        szabadit (gyoker->nullasGyermek ());
        delete gyoker;
    }

    void operator<< (char b)
    {

        if (b == '0')
        {

            if (!fa->nullasGyermek ())	// ha nincs, hát akkor csinálunk
            {

                Csomopont *uj = new Csomopont ('0');

                fa->ujNullasGyermek (uj);

                fa = gyoker;
            }
            else	
            {

                fa = fa->nullasGyermek ();
            }
        }

        else
        {
            if (!fa->egyesGyermek ())
            {
                Csomopont *uj = new Csomopont ('1');
                fa->ujEgyesGyermek (uj);
                fa = gyoker;
            }
            else
            {
                fa = fa->egyesGyermek ();
            }
        }
    }

    void kiir (void)
    {

        melyseg = 0;

        kiir (gyoker, std::cout);
    }
 
    int getMelyseg (void);
    double getAtlag (void);
    double getSzoras (void);

   
    friend std::ostream & operator<< (std::ostream & os, LZWBinFa & bf)
    {
        bf.kiir (os);
        return os;
    }
    void kiir (std::ostream & os)
    {
        melyseg = 0;
        kiir (gyoker, os);
    }

private:
    class Csomopont
    {
    public:
      
        Csomopont (char b = '/'):betu (b), balNulla (0), jobbEgy (0)
        {
        };
        ~Csomopont ()
        {
        };
       
        Csomopont *nullasGyermek () const
        {
            return balNulla;
        }
        
        Csomopont *egyesGyermek () const
        {
            return jobbEgy;
        }
        
        void ujNullasGyermek (Csomopont * gy)
        {
            balNulla = gy;
        }
    
        void ujEgyesGyermek (Csomopont * gy)
        {
            jobbEgy = gy;
        }

        char getBetu () const
        {
            return betu;
        }

    private:
     
        char betu;

        Csomopont *balNulla;
        Csomopont *jobbEgy;
      
        Csomopont (const Csomopont &); 
        Csomopont & operator= (const Csomopont &);
    };


    Csomopont *fa;

    int melyseg, atlagosszeg, atlagdb;
    double szorasosszeg;

    LZWBinFa (const LZWBinFa &);
    LZWBinFa & operator= (const LZWBinFa &);

    void kiir (Csomopont * elem, std::ostream & os)
    {

        if (elem != NULL)
        {
            ++melyseg;
            kiir (elem->egyesGyermek (), os);

            for (int i = 0; i < melyseg; ++i)
                os << "---";
            os << elem->getBetu () << "(" << melyseg - 1 << ")" << std::endl;
            kiir (elem->nullasGyermek (), os);
            --melyseg;
        }
    }
    void szabadit (Csomopont * elem)
    {
        if (elem != NULL)
        {
            szabadit (elem->egyesGyermek ());
            szabadit (elem->nullasGyermek ());
            delete elem;
        }
    }

protected:			
    Csomopont *gyoker;
    int maxMelyseg;
    double atlag, szoras;

    void rmelyseg (Csomopont * elem);
    void ratlag (Csomopont * elem);
    void rszoras (Csomopont * elem);

};



int
LZWBinFa::getMelyseg (void)
{
    melyseg = maxMelyseg = 0;
    rmelyseg (gyoker);
    return maxMelyseg - 1;
}

double
LZWBinFa::getAtlag (void)
{
    melyseg = atlagosszeg = atlagdb = 0;
    ratlag (gyoker);
    atlag = ((double) atlagosszeg) / atlagdb;
    return atlag;
}

double
LZWBinFa::getSzoras (void)
{
    atlag = getAtlag ();
    szorasosszeg = 0.0;
    melyseg = atlagdb = 0;

    rszoras (gyoker);

    if (atlagdb - 1 > 0)
        szoras = std::sqrt (szorasosszeg / (atlagdb - 1));
    else
        szoras = std::sqrt (szorasosszeg);

    return szoras;
}

void
LZWBinFa::rmelyseg (Csomopont * elem)
{
    if (elem != NULL)
    {
        ++melyseg;
        if (melyseg > maxMelyseg)
            maxMelyseg = melyseg;
        rmelyseg (elem->egyesGyermek ());

        rmelyseg (elem->nullasGyermek ());
        --melyseg;
    }
}

void
LZWBinFa::ratlag (Csomopont * elem)
{
    if (elem != NULL)
    {
        ++melyseg;
        ratlag (elem->egyesGyermek ());
        ratlag (elem->nullasGyermek ());
        --melyseg;
        if (elem->egyesGyermek () == NULL && elem->nullasGyermek () == NULL)
        {
            ++atlagdb;
            atlagosszeg += melyseg;
        }
    }
}

void
LZWBinFa::rszoras (Csomopont * elem)
{
    if (elem != NULL)
    {
        ++melyseg;
        rszoras (elem->egyesGyermek ());
        rszoras (elem->nullasGyermek ());
        --melyseg;
        if (elem->egyesGyermek () == NULL && elem->nullasGyermek () == NULL)
        {
            ++atlagdb;
            szorasosszeg += ((melyseg - atlag) * (melyseg - atlag));
        }
    }
}


void
usage (void)
{
    std::cout << "Usage: lzwtree in_file -o out_file" << std::endl;//f a fájlba írásért c a consoleba írásért
}

int
main (int argc, char *argv[])
{
    try{
   
    if (argc != 5)
    {
  
        usage ();
        throw std::invalid_argument("arg");
        return -1;
    }


    char *inFile = argv[1];

    if (argv[2][1] != 'o')
    {
        usage ();
        throw std::ios::failure("Hibás bemenet");
            return -2;
    }
   

    std::fstream beFile (inFile, std::ios_base::in);

    if (!beFile)
    {
        std::cout << inFile << " nem letezik..." << std::endl;
        usage ();
        throw std::ios::failure("Hibás bemenet");
        return -3;
    }

    std::fstream kiFile (argv[3], std::ios_base::out);

    unsigned char b;		// ide olvassik majd a bejövő fájl bájtjait
    LZWBinFa binFa;		// s nyomjuk majd be az LZW fa objektumunkba


    while (beFile.read ((char *) &b, sizeof (unsigned char)))
        if (b == 0x0a)
            break;

    bool kommentben = false;

    while (beFile.read ((char *) &b, sizeof (unsigned char)))
    {

        if (b == 0x3e)
        {			// > karakter
            kommentben = true;
            continue;
        }

        if (b == 0x0a)
        {			// újsor
            kommentben = false;
            continue;
        }

        if (kommentben)
            continue;

        if (b == 0x4e)		// N betű
            continue;


        for (int i = 0; i < 8; ++i)
        {

            if (b & 0x80)
                binFa << '1';
            else
                binFa << '0';
            b <<= 1;
        }

    }

    if(argv[4][0]=='f'){
    kiFile << binFa;

    kiFile << "depth = " << binFa.getMelyseg () << std::endl;
    kiFile << "mean = " << binFa.getAtlag () << std::endl;
    kiFile << "var = " << binFa.getSzoras () << std::endl;
    }
    else if(argv[4][0]=='c')
    {std::cout<< binFa; 

    std::cout << "depth = " << binFa.getMelyseg () << std::endl;
    std::cout << "mean = " << binFa.getAtlag () << std::endl;
    std::cout << "var = " << binFa.getSzoras () << std::endl;
    }
    kiFile.close ();
    beFile.close ();

    return 0;
}
catch (std::invalid_argument& e) {
        std::cout << "Hiba történt: ";
        std::cout << e.what() << std::endl;
}
catch (std::ios::failure& e) {
        std::cout << "Hiba történt: ";
        std::cout << e.what() << std::endl;
}
}


     ]]>
        </programlisting>
        <para>
            A C-s változattól abban különbözik, hogy használhatunk osztályokat. Létre is hozzuk az LZWBinFa osztályunkat majd deklarálunk egy konstruktort és egy destruktort. Majd túlterheljük az operátort a void operator-ban, amely paraméterül a char b-t kapja. Ezzel vizsgáljuk milyen elem megy be épp.
            Ha ez az elem 0 és a fának nincs 0 ás eleme akkor létrehozunk egyet neki. Ha van akkor ráállítjuk a fa mutatót. Ha ez az elem 1-es akkor hasonlóképpen működik. Majd jön a kiir eljárás, amely rekurzívan hívja meg magát.Argumentumként megkapja a gyökeret és azt, hogy mit kell kiirni ez az egyes gyermek és nullás gyermek lesz.
            Ezután az LZWBinFa osztály private részében létrehozunk egy Csomópont osztályt. A csomópont konstruktora argumentumként kapja meg inicializálva a gyökér karaktert és typedefeljük a betűt a a balNullát és a jobbEgyet. Ezután jön a destruktora az osztálynak. Ezután jönnek a csomópontok gyermekeinek vizsgálata, van -e nekik ha nincs akkor nullal tér vissza.
            Majd a két eljárás, amelynek mutatója átadja a címet, hogy hol legyen az egyes vagy nullás gyermeke a megadott csomópontnak. A char get betűben pedig az értéket vizsgáljuk, hogy éppen 0 vagy 1 es jön.
            Majd a private részben deklaráljuk a mutatókat és a változókat és letiltjuk a másoló konstruktort. Ezután a csomópont osztályon kívül létrehozzuk a csomópont fa mutatót, amely mindig az aktuális csomópont elemre mutat. Majd deklaráljuk a számításhoz szükséges függvények változóit és letiltjuk a binfának is a másolását.
            Létrehozzuk a kiir eljárást, a kiiratás csak akkor tud megtörténni ha van elem a fában,itt inorder kiiratás történik.Ezután a fölösleges nem használt részeket felszabadítjuk a szabadíttal. Majd van egy protected rész ahol kiemeljük, hogy a fának van egy kitüntetett tag csomópontja a /. Ezután az osztályból kilépve a sima globális térbe létrehozunk egy usage eljárást, amelyel ha hibásan futtatnánk a programot segítséget nyújtunk a felhasználónak.
            A mainben a try catch hibakezelő eljárást alkalmazzuk. Ha nincs elég argumentum megadva akkor hibaüzenetet dobunk, ezután inicializálunk egy mutatót, amely a fájl nevére mutat.Majd vizsgáljuk, hogy a fájl név után a -o kapcsoló jön -e, ha nem hibaüzenetet dobunk.Majd az fstreammel beolvassuk a fájlt, amelynek megadtuk a bemenő fájl nevének címét. Majd létrehozzuk a kifile-t, amely a fájlba írásért lesz felelős.
            Deklarálunk egy karakter változót és meghívjuk a LZWBinFa osztályt binfa néven.Majd indítunk egy while ciklust, amelyben felsoroljuk a kivételeket, hogy mit hagyjon figyelmen kívül a beolvasás.A következő forciklusban végig megyünk a 8 biten és ha egyes van akkor egyes kerül a tárba ha 0-ás akkor 0. A kifile-nak átadjuk a binfát, majd a mélység,átlag,szórást és végül bezárjuk a filestreamet.
        </para>
    </section>        
                
    <section>
        <title>Mutató a gyökér</title>
        <para>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/blob/master/mozgato/pointer2.cpp">https://github.com/Savitar97/Prog1/blob/master/mozgato/pointer2.cpp</link> 
        </para>
        <programlisting language="c"><![CDATA[
#include <iostream>		
#include <cmath>		
#include <fstream>	
#include <algorithm>
#include <utility>

class LZWBinFa
{
public:
  
  LZWBinFa()
  {
      gyoker = new Csomopont();
      fa=gyoker;
  }
   ~LZWBinFa ()
  {
    szabadit (gyoker->egyesGyermek ());
    szabadit (gyoker->nullasGyermek ());
    delete gyoker;
  }
  
  
  
  LZWBinFa ( LZWBinFa && regi ){
  
      gyoker = nullptr;
      
      *this = std::move(regi);

      
  }
  
  LZWBinFa & operator= (LZWBinFa && regi){
      
      std::swap(gyoker, regi.gyoker);

      return *this;
}

  void operator<< (char b)
  {

    if (b == '0')
      {
	
	if (!fa->nullasGyermek ())	
	  {
	    Csomopont *uj = new Csomopont ('0');
	    fa->ujNullasGyermek (uj);
	    fa = gyoker;
	  }
	else			
	  {
	    
	    fa = fa->nullasGyermek ();
	  }
      }
    else
      {
	if (!fa->egyesGyermek ())
	  {
	    Csomopont *uj = new Csomopont ('1');
	    fa->ujEgyesGyermek (uj);
	    fa = gyoker;
	  }
	else
	  {
	    fa = fa->egyesGyermek ();
	  }
      }
  }
  
  void kiir (void)
  {
    
    melyseg = 0;
    kiir (gyoker, std::cout);
  }
  
  int getMelyseg (void);
  double getAtlag (void);
  double getSzoras (void);

  friend std::ostream & operator<< (std::ostream & os, LZWBinFa & bf)
  {
    bf.kiir (os);
    return os;
  }
  void kiir (std::ostream & os)
  {
    melyseg = 0;
    kiir (gyoker, os);
  }

private:
  class Csomopont
  {
  public:

  Csomopont (char b = '/'):betu (b), balNulla (0), jobbEgy (0)
    {
    };
    ~Csomopont ()
    {
    };
    Csomopont (const Csomopont& elem){
        
        betu = elem.getBetu();
        balNulla = new Csomopont;
        jobbEgy = new Csomopont;
        *balNulla= *(elem.nullasGyermek());
        *jobbEgy= *(elem.egyesGyermek());
    }
    
    Csomopont & operator= (const Csomopont& elem){
        
        betu = elem.getBetu();
        Csomopont* ujBal = new Csomopont();
        *ujBal = *(elem.nullasGyermek());
        delete balNulla;
        balNulla = ujBal;
        Csomopont* ujJobb = new Csomopont();
        *ujJobb = *(elem.egyesGyermek());
        delete jobbEgy;
        jobbEgy = ujJobb;
        
        return *this;
    }
   
    Csomopont *nullasGyermek () const
    {
      return balNulla;
    }
    
    Csomopont *egyesGyermek () const
    {
      return jobbEgy;
    }
  
    void ujNullasGyermek (Csomopont * gy)
    {
      balNulla = gy;
    }
    
    void ujEgyesGyermek (Csomopont * gy)
    {
      jobbEgy = gy;
    }
   
    char getBetu () const
    {
      return betu;
    }

  private:
   
    char betu;
    Csomopont *balNulla;
    Csomopont *jobbEgy;
    
  };

  Csomopont *fa;
  int melyseg, atlagosszeg, atlagdb;
  double szorasosszeg;
  LZWBinFa (const LZWBinFa& binfa);

  void kiir (Csomopont * elem, std::ostream & os)
  {
    
    if (elem != NULL)
      {
	++melyseg;
	kiir (elem->nullasGyermek (), os);
	for (int i = 0; i < melyseg; ++i)
	  os << "---";
	os << elem->getBetu () << "(" << melyseg - 1 << ")" << std::endl;
	kiir (elem->egyesGyermek (), os);
	--melyseg;
      }
  }
  void szabadit (Csomopont * elem)
  {
    if (elem != NULL)
      {
	szabadit (elem->egyesGyermek ());
	szabadit (elem->nullasGyermek ());
	delete elem;
      }
  }

protected:			
  Csomopont *gyoker;
  int maxMelyseg;
  double atlag, szoras;

  void rmelyseg (Csomopont * elem);
  void ratlag (Csomopont * elem);
  void rszoras (Csomopont * elem);

};

int
LZWBinFa::getMelyseg (void)
{
  melyseg = maxMelyseg = 0;
  rmelyseg (gyoker);
  return maxMelyseg - 1;
}

double
LZWBinFa::getAtlag (void)
{
  melyseg = atlagosszeg = atlagdb = 0;
  ratlag (gyoker);
  atlag = ((double) atlagosszeg) / atlagdb;
  return atlag;
}

double
LZWBinFa::getSzoras (void)
{
  atlag = getAtlag ();
  szorasosszeg = 0.0;
  melyseg = atlagdb = 0;

  rszoras (gyoker);

  if (atlagdb - 1 > 0)
    szoras = std::sqrt (szorasosszeg / (atlagdb - 1));
  else
    szoras = std::sqrt (szorasosszeg);

  return szoras;
}

void
LZWBinFa::rmelyseg (Csomopont * elem)
{
  if (elem != NULL)
    {
      ++melyseg;
      if (melyseg > maxMelyseg)
	maxMelyseg = melyseg;
      rmelyseg (elem->egyesGyermek ());
      rmelyseg (elem->nullasGyermek ());
      --melyseg;
    }
}

void
LZWBinFa::ratlag (Csomopont * elem)
{
  if (elem != NULL)
    {
      ++melyseg;
      ratlag (elem->egyesGyermek ());
      ratlag (elem->nullasGyermek ());
      --melyseg;
      if (elem->egyesGyermek () == NULL && elem->nullasGyermek () == NULL)
	{
	  ++atlagdb;
	  atlagosszeg += melyseg;
	}
    }
}

void
LZWBinFa::rszoras (Csomopont * elem)
{
  if (elem != NULL)
    {
      ++melyseg;
      rszoras (elem->egyesGyermek ());
      rszoras (elem->nullasGyermek ());
      --melyseg;
      if (elem->egyesGyermek () == NULL && elem->nullasGyermek () == NULL)
	{
	  ++atlagdb;
	  szorasosszeg += ((melyseg - atlag) * (melyseg - atlag));
	}
    }
}


void
usage (void)
{
  std::cout << "Usage: lzwtree in_file -o out_file" << std::endl;
}

int
main (int argc, char *argv[])
{

  if (argc != 4)
    {
      usage ();
      return -1;
    }

  char *inFile = *++argv;

  if (*((*++argv) + 1) != 'o')
    {
      usage ();
      return -2;
    }

  std::fstream beFile (inFile, std::ios_base::in);

  if (!beFile)
    {
      std::cout << inFile << " nem letezik..." << std::endl;
      usage ();
      return -3;
    }

  std::fstream kiFile (*++argv, std::ios_base::out);

  unsigned char b;		
  LZWBinFa binFa,binFa2;		


  while (beFile.read ((char *) &b, sizeof (unsigned char)))
    if (b == 0x0a)
      break;

  bool kommentben = false;

  while (beFile.read ((char *) &b, sizeof (unsigned char)))
    {

      if (b == 0x3e)
	{			// > karakter
	  kommentben = true;
	  continue;
	}

      if (b == 0x0a)
	{			// újsor 
	  kommentben = false;
	  continue;
	}

      if (kommentben)
	continue;

      if (b == 0x4e)		// N betű
	continue;

      for (int i = 0; i < 8; ++i)
	{
	  if (b & 0x80)
	    binFa << '1';
	  else
	    binFa << '0';
	  b <<= 1;
	}

    }


  kiFile << binFa;
  kiFile << "depth = " << binFa.getMelyseg () << std::endl;
  kiFile << "mean = " << binFa.getAtlag () << std::endl;
  kiFile << "var = " << binFa.getSzoras () << std::endl;
  kiFile << &binfa
  binFa2=std::move(binFa);
  kiFile<<"\n Mozgatás után binFa:"<< std::endl;
  kiFile << binFa;
  kiFile << "depth = " << binFa.getMelyseg () << std::endl;
  kiFile << "mean = " << binFa.getAtlag () << std::endl;
  kiFile << "var = " << binFa.getSzoras () << std::endl;
  kiFile  << "\nMozgatás után a binFa2"<< std::endl;
  kiFile<<binFa2;
  kiFile << "depth = " << binFa2.getMelyseg () << std::endl;
  kiFile << "mean = " << binFa2.getAtlag () << std::endl;
  kiFile << "var = " << binFa2.getSzoras () << std::endl;

  kiFile.close ();
  beFile.close ();

  return 0;
}

              ]]>
        </programlisting>
        <para>
            A különbség mostmár az hogy a csomópontból pointer lett. Tehát a konstruktorba be kellett vinni a konstruktor argumentum listájából az eddig átadott fa gyokeret(ugyebár eddig a konstruktor után volt írva a : után felsorolva). Mivel eddig a gyökér tagként szerepelt a csomópontba, de most mutató lett tehát könnyedén átadhatjuk az értékét a fának ami egy mutató,tehát memória cím átadása történik. Miután a gyökérből pointert csináltunk így könnyedén elhagyhatjuk az és jeleket ugyanis alapból a memória címét fogja átadni majd nem kell érték szerinti referenciaként hivatkozni rá.Viszont, így hogy pointer lett a destruktorban őt is felkell szabadítani tehát bele írjuk a delete gyokeret a destruktorba.
        </para>
    </section>                     

    <section>
        <title>Mozgató szemantika</title>
        <para>
            Írj az előző programhoz mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/blob/master/mozgato/pointer2.cpp">https://github.com/Savitar97/Prog1/blob/master/mozgato/pointer2.cpp</link> 
        </para>
        <para>
            A mozgató szemantikához a mutatós gyökerű binfát fogjuk felhasználni. Amíg nem írtuk meg a mozgató szemantikát addig tiltanunk kellett.Az osztály private részében. Ez a csomópontra és a fára egyaránt vonatkozik. A mozgató konstruktorra dupla és-el hivatkozunk. Az dupla és operátor jelzi, hogy jobboldali referenciáról van szó. Ez azért jó, mert a jobboldali referencia elkerüli a fölösleges másolatot.Ez azért jó mert ha másoljuk akkor megmarad az előző gyakran szükségtelen másolat,vagy úgyis elpusztítjuk egy destruktorral.De a mozgató szemantikával elkerüljük az ideiglenes másolatot mivel konkrét memória címekkel dolgozunk.
            A konstruktorba elsőként nullára állítjuk a gyökér pointert.Ez azért szükséges, hogy a régit bele tudjuk tenni az újonnan elkészített gyökérbe.Ezt a move segítségével érjük el. Ez lényegében az értéket átpakolja az újba majd a régit null-ra állítja. Majd ezután visszatérünk az új gyökérrel.Következőnek túlterheljük az =jel operátort.És az új gyökérelemekbe beleteszem a régi gyökér elemeket.Majd visszaadom az újnak a this-el. De a régieket ezután töröljük.A mozgatást a mainbe úgy érjük el, hogy a move-al átpakoljuk az egész binFa-t a binFa2-be. Ilyenkor a binFa üres lesz és a binFa2 lesz az új példány.
        </para>
    </section>                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <caution>
            <title>
                Felhasznált irodalom:
             </title>
             <para>
                <link xlink:href=" http://www.cs.ubbcluj.ro/~csatol/mestint/pdfs/BME_SpecialisUtkeresoAlgoritmusok.pdf">http://www.cs.ubbcluj.ro/~csatol/mestint/pdfs/BME_SpecialisUtkeresoAlgoritmusok.pdf</link>
             </para>
             <para>
                 Az ábra a <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link> származik.
             </para>
        </caution>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
        <para>
            A hangyaszimuláció a hangyák mozgását és nyomvonalát szimulálja, minden hangya feromon nyomot hagy, és ha feromon nyomra lép akkor elkezdi követni az előző hangya által hagyott feromont,a feromon kezdetben sötétzöld de egyre halványodik ha nem kezdi el követni egy újabb hangya.Minél erősebb egy feromon nyom annál nagyobb az esélye, hogy elkezdi követni egy közelben járó hangya. Elsőként is létrehozzuk a hangya osztályt,amelyben a hangyák koordinátáit és mozgásukat adjuk meg. A mozgásuk irányát maradékos osztással számoljuk.Majd típusdefiniáljuk a hangya osztályt, ez a multiplicitás miatt, ugyanis több hangyát akarunk majd létrehozni és kezelni.
            Az AntWinbe adjuk meg az ablak tulajdonságait(A hangyák megjelenítését, amely zöld négyzetekkel történik,a rácsvonalak méreteit és a megfelelő key eventeket ez itt most csak a pause a P vel és a Q-val vagy ESC-el való kilépés. Ha nem adunk meg semmit kapcsolóval akkor az alapértelmezett értékeket veszi fel viszont mi is megadhatjuk neki az ablak tulajdonságait és a hangyák tulajdonságait. Emellett a kirajzolás event is itt történik meg.
        </para>
        <para>
            A parancssorban itt az érték megadaást a qcommandlineoptionnal érjük el. Amit módosítani tudunk a w kapcsolóval a szélességet cellákban mérve. Az m-el a magasságot cellákban mérve. Ezen kívül megadhatjuk a hangyák számát(-n), sebességüket(-t két lépés közötti időt nézi), és a párolgási időt(-p), hogy hány mp után pusztítsuk el az objektumot.Majd a nyomvonalukat a hangyáknak ezek a feromonok(-f) és a cellák méretét(-c), hogy hány hangya fér rá egy cellára.
        </para>   
        <para>
            Az antthread.h ban vannak a program eventjei, hogy éppen fut -e a program vagy szünetel.Ha nem adunk meg kapcsolókkal értékeket akkor az antwin.h-ban lévő alap beállításokkal fog futni a program.
            A program futtatásához a Qt-nak legalább 5.2 es verziója szükséges.
        </para>
        <figure>
             <title>Hangyaszimuláció</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Ant.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure>
        <figure>
             <title>UML osztálydiagramm</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/antabra.png" scale="40"/>
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            Az ábra elején lévő + jelzi hogy globálisan hozzáférhető -e az adott program részhez a - a helyi hozzáférésű részek.
        </para>    
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apb.html#conway"/>               
        </para>
        <para>
            A java életjáték lényege, hogy vannak élő és halott sejtek. Tehát a sejtnek ez a két állapota van. Egy élő sejt addig él tovább, amíg 2 vagy 3 szomszédja élő. Ha ez nem teljesül akkor elpusztul. Egyik véglet a túlnépesedés amikor 3-tól több a másik véglet amikor 2 nél kevesebb akkor pedig túl kevés az életben maradáshoz.Ha halott állapotban van egy sejt, akkor mindaddig halott marad, amíg 3 szomszédja élő. Két ráccsal dolgozunk egy jelenlegi állapottal és a megváltozott állapottal. Ezt az időfejlődés eljárás befolyásolja, itt figyeljük a sejtek állapotát, azt hogy hogyan változnak. A rácsok közötti váltakozást egy indexxel figyeljük. Külön definiáljuk a cella méreteit és azt, hogy mekkora a sejttér azaz, hogy hány cella magas és széles.
            Emellett definiáljuk, hogy mennyi idő múlva váltson a jelenlegi sejttér a következőre. A programban készíthetünk pillanatfelvételt az S gombbal ezeket számoljuk, hogy hányat készítünk. Magát a felvétel készítését egy bool típúsú változóval érjük el. Majd a konstruktorban definiáljuk a sejtterünket, kezdetben minden sejt állapota halott. Majd létrehozzuk az első élőlényeket a siklókilövőket. Magát a sejtteret úgy hozzuk létre, hogy ami kiúszik az egyik oldalon az térjen vissza a másikon. A funkció gombok a program futása során a már tárgyalt 'S', ezen kívül van lehetőségünk felezni a cella méreteit a 'K'-val vagy esetleg duplázni az 'N'-el. Emellett a 'G'-vel gyorsíthatjuk a rácsok közötti váltást vagy pedig az 'L'-el lassíthatjuk. Az egérmutatóval változtathatjuk a sejtek állapotát. Tehát ha húzzuk az egeret a cellákon akkor a halott cellákból élőket tudunk csinálni. A kezdeti cellaméret 10x10 es.
            A sejttér kirajzolásáért a paint eljárás a felelős. Ha egy sejt élő akkor feketével rajzoljuk ki ellenkező esetben fehérre színezzük a cellát. A rácsokat szürkével rajzoljuk ki. A létrehozott siklók a sejttérben automatikusan másolják magukat és megadott irányba haladnak. És végülis a legjobban az egérrel tudunk beavatkozni az egész sejttér fejlődésbe. A mainben már csak példányosítjuk magát a sejtautomatát a konstruktora segítségével. A következő feladatban majd láthatjuk ennek a feladatnak a c++ és qt segítségével elkészített megoldását.
        </para>
        <para>
            Élet a sejttérben:
            </para>
            <figure>
             <title>Sejtautomata</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/sejtautomata1.png" scale="30"/>
                </imageobject>
        </mediaobject>
            </figure>         
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://sourceforge.net/p/udprog/code/ci/master/tree/source/kozepes/Qt/sejtautomata/">https://sourceforge.net/p/udprog/code/ci/master/tree/source/kozepes/Qt/sejtautomata/</link>               
        </para>
        <para>
            A programban a sejt ablakban van definiálva, hogy mekkora legyen az ablak lényegében, hogy hány cella van. A cellák méretét külön adjuk meg itt, 6x6 os kocka.A sejtnek két állapota van élő vagy halott, élő marad mindaddig amíg kettő vagy három szomszédja van ellenkező esetben halott lesz.A sejt ablakban az élőlények a siklók, amelyek másolják magukat és adott irányba haladnak. A siklókat sikló ágyúkból lőjük ki.A sikló ágyúknak fix pozíciója van. A painteventben rajzoljuk ki magát a táblát és a skiló kilövőket.Minden egyes kockának 8 szomszédja van az az egy sejt 9 kockát befolyásol.
            A lényeg, hogy teremthetünk egy világot ahol eldönthetjük a létrehozott sejtek számát az az megadhatjuk mikor lehet élő a sejt vagy mikor halott.Így végülis a populációt tudjuk befolyásolni. És ez egy olyan játék ahol a személy csak megfigyelője az eseményeknek nem pedig részese ugyanis miután beállítottuk a szabályait a világnak onnantól magától fut és teremtődnek az élőlények.
        </para>
        <figure>
             <title>Életjáték</title>
             <mediaobject>
                <imageobject>
                    <imagedata fileref="img/eletjatek.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            Káoszba fordult világ a halálozási arány csökkentésével.
        </para>     
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <caution>
            <title>
                Tutor
            </title>
            <para>Ebben a feladatban tutoráltam Egyed Annát.</para>
        </caution>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/BrainBbench">https://github.com/Savitar97/Prog1/tree/master/BrainBbench</link>               
        </para>
        <para>
            A BrainB benchmark egy felmérés. Amely főleg az mmorpgvel játszó játékosokat képes mérni. Mégpedig azt, hogy mennyire képesek követni a karakterüket a tömegbe. A lényeg,hogy az egérmutatót a karakterünkön samun tartsuk a játék pedig egyre több hőst generál a karakterünk köré és 10 percen keresztül nem szabad elveszteni a karakterünk nyomát.Majd a benchmark ad egy eredményt, amely számosítja a teljesítményét a játékosnak. Ez alapján készíthetünk esetleg egy táblázatot, hogy meghatározzuk sávokban is a pontszámokat, így megtudjuk ki a jobb képességű.A moba területen is hasznos lehet a játék ugyanis a teamfightokban a sok effekt között könnyen eveszíthetjük a karakterünket vagy épp a focusolandó enemy játékosét.
            Ezzel a programmal lehetséges, mérni az egyén teljesítőképességét és kiválogatni azokat akik sokkal jobbak az átlagtól és akár a csapatok meghatározhatnának egy minimális pontszámot, amit elkell érni a jelentkezéshez.Viszont a 10 perc szerintem elég sok idő. Mármint jó a koncentráció képességet próbára tesszük. De akkor is elég unalmas végig ülni, amíg a teszt lefut.
        </para>            
        <para>
            És most beszéljünk kicsit a programról a BrainBThread.cpp-ben hozzuk létre a hős osztályunkat és itt hozzuk létre(deklaráljuk) a hősünket Samut.A hős osztály konstruktorában. A mozgását az ablakban randommal számoljuk. A Qthread-ban határozzuk meg az eventeket.Ilyen  a pause. És magát, hogy a hőst hogyan jelnítse meg, hogy írja ki a nevét stb.A BrainBWin-ben vannak meghatározva a presd eventek vagyis, hogy az egérgomb levan -e nyomva vagy nincs és hogy az S el mentse el az eredményt a P-vel pause-oljon az ESC-el vagy Q-val pedig lépjen ki.Ha az egérgombot lenyomjuk akkor kezdődik a mérés.Az ifben vizsgáljuk, hogy az egér a hősünkön van -e ha igen akkor létrehozunk egy new entropyt ez a incCompban van a BrainBThread.h-ban és növeljük a hősünk agilityjét 2 vel ha nincs rajta akkor kiszedünk a vektorból egy entropyt és csökkentjük a hősünk agilityjét.
        </para>
        <figure>
             <title>BrainB benchmark</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/BrainB.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Schwarzenegger!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Szoftmax Py MNIST</title>
        <para>
            Python
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/j7f9SkJR3oc">https://youtu.be/j7f9SkJR3oc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0">https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0</link> (/tensorflow-0.9.0/tensorflow/examples/tutorials/mnist/), <link xlink:href="https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol">https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol</link>  
        </para>
        <para>
            <link xlink:href="https://github.com/Savitar97/Prog1/blob/master/tensorflow/twicetwo.py">https://github.com/Savitar97/Prog1/blob/master/tensorflow/twicetwo.py</link>
        </para>
        <para>
            Felhasznált irodalom:<link xlink:href="http://biointelligence.hu/pdf/tf_bkp.pdf">http://biointelligence.hu/pdf/tf_bkp.pdf</link>
        </para>
        <para>
           A tensorflowot a google készítette és fejleszti a gépi tanulást segíti, a tervezésben a fejlesztésben és a tanulmányozásban használják főként mivel készít adatáramlási gráfot, amelyben a node-ok a matematikai műveletek és az élek az áramló adatok. A tensorflow-ot import tensorflow ként hívjuk meg. A readimg függvény beolvassa a kép file-t majd dekódolja erre a későbbiekben lesz szükség.A program lényege, hogy a megadott képen szereplő számot felismerje.Ehhez megkell tanítanunk a programunkat. Tehát elsőnek készítünk egy modelt.Majd ezen gyakoroltassuk a programunkat. Majd futtatunk egy teszt kört ahol a program kiirja a becsült pontosságát. Ezután a 42 es tesztkép felismerése következik. Majd végül a beolvasott képünkön teszteljük a program működését.
           A tesztnél a program súlyokat használ ami a W változó, ezzel dönti el a súlyokat,amely alapján dönt hogy benne van -e a kép amit megadtunk a jó halmazban. Az x változó jelenti a bemenő értéket míg az y a számított kimenő érték. Ez hasonló mint a már átvett perceptron és neurális and or xor kapu. A súlyokkal mindig szorzunk a b mint bias mindig egy konstans érték. A tanulási folyamat is a neurális and or xor kapuhoz hasonló, ugyan úgy vannak hidden rétegek és nekik vannak node-jai. X a példa és Y a várt eredmény. A tanulánál ugyan úgy iterációs határt számolunk. Az Y értékét úgy számoljuk mintha egy egyenes egyenletét írnánk fel az Y= x*a súlyjal ami a W és hozzá adjuk a b-t ami a kostants.
           </para>
           <programlisting><![CDATA[
            y = tf.matmul(x, W) + b
       ]]>
        </programlisting>
            <para>
            Ez az egyenes az ami elválasztja a jó megoldásokat a rosszaktól. Vagyis amelyik teljesíti a feltételt és megközelítőleg helyes értéket ad.
            Itt a feladatunkban az elfogadási arányt(iterációs határ,gradient) 50% nál húztuk meg tehát a program hibázhat. A pontosságot minél több hidden réteggel és noda-al tudjuk növelni. Tehát az egész egy valószínűségi értéket figyel ha megüti a meghatározott küszöböt ez az érték és a hiba mértéke kevés akkor a program elfogadja mint megoldást. A programmal 28*28 pixeles képekről döntjük el, hogy milyen szám szerepel a képen. A y_ a loss-t definiáljuk, amely azt számolja,hogy mennyire térünk el a a várt eredményünktől. A GradientDescentOptimizer deriváltakat számít a hibahatárok figyelembe vételével. Ez a minimize.
                
            </para>
            <figure>
             <title>Softmax mnist</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Softmax.png" scale="30"/>
                </imageobject>
        </mediaobject>
            </figure>
    </section>        

<!--
    <section>
        <title>Szoftmax R MNIST</title>
        <para>
            R            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->
    
    <section>
        <title>Mély MNIST</title>
        <para>
            Python            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A deep mnist az előző példára épül annyi különbséggel, hogy itt sokkal több a hidden réteg és azokon a node-ok száma. Emellett két súlyjal dolgozunk. Az az 2 layerünk van a 2. layer az első layer által számolt adatokból dolgozik így már pontosabb eredményeket kapunk, azaz ezzel növelhetjük a pontosságát a programnak.Ugyebár a neuronoknak két állapot van vagy aktiválva vannak vagy nem tehát ez olyan mint a boolean vagy igen vagy nem. Mindig csak egy neuronunk lehet aktiválva, ha több van megkell találnunk melyik az amelyik a többi közül közelebb áll az eredményhez. Vagyis megkell találnunk azt a súly és bias párt amelyjel a legjobb pontosságot kapunk. Ezt a hibavisszaterjesztéssel ellenőrizhetjük.Tehát akkor a legpontosabb az eredmény ha a pontosságunk a legnagyobb és a loss a legkisebb. Itt 32x32 képet vizsgálunk és már nem csak számokat képes felismerni hanem bármit amit megadunk az adatbázisba. Itt az adatbázis is egy sokkal nagyobb 100000 kép körüli a, futási idő is nagyon megnövekedett több órára. A reshape a bemeneti 2 dimenziós kép pixeleit átrendezi egy soros listába.Ez azért kell mert a program csak így tudja vizsgálni a pixeleket. A végeredmény ugyan úgy felismeri a képet az adatbázisból.
        </para>
    </section>        
<!--
    <section>
        <title>Deep dream</title>
        <para>
            Keras            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->                  
    <section>
        <title>Minecraft-MALMÖ</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/bAPSu3Rndi8">https://youtu.be/bAPSu3Rndi8</link>      
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Microsoft/malmo">https://github.com/Microsoft/malmo</link>                
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://microsoft.github.io/malmo/0.17.0/Python_Examples/Tutorial.pdf">https://microsoft.github.io/malmo/0.17.0/Python_Examples/Tutorial.pdf</link>                
        </para>
        <para>
            Valószínűleg sokan ismerik a MineCraft játékot a kockákból álló világ melynek a főszereplője Steve. A program lényege,hogy Steve egy megadott időintervallumon belül ne akadjon el semmiben. Tehát képes legyen kikerülni a mozgását blokkoló akadályokat.Ezt úgy értük el hogy a steve körül lévő 26 kockát vizsgáljuk mivel ő áll a közepén. Ha nincs szabad út előtt megpróbálja kikerülni ha nem lehetséges akkor ugrik.Azt, hogy épp milyen objektum van Steve előtt a program jelzi. A forgásszámláló counter 8-ban lett meghatározva. Steve egyenesen előre halad mindaddig, amíg valamilyen akadályba nem ütközik. Akadályok lehetnek a víz,levegő,növényzet. A program futása során számoljuk az akadályokat és kiirjuk, hogy steve előtt éppen milyen objektum van.Az akadályok elkerülésének lehetőségei az ugrás, a kitérés vagy az akadály elpusztítása. Az elpusztítás akkor lehet jó lehetőség ha 2 blokk magas fal veszi körül Stevet mert azt már nem tudja átugrani. A programba a cselekvési utasításokat a while world state is mission running ba kell beleírnunk. Az agent alapvető utasításai attack,move,turn,jump,stafe,use ezeknek argumentumként a sebességet adjuk meg 1 a max sebesség tehát 0 és 1 között adhatunk meg argumentumként neki értéket.
        </para>
        <para>
            Sajnos a gyenge gépem miatt a futtatás eléggé haldoklott. De a telepítése az egésznek eléggé egyszerű letöltjük a Malmo-0.37.0-Linux-Ubuntu-18.04-64bit_withBoost_Python3.6 ezt <link xlink:href="https://github.com/Microsoft/malmo/releases">innen</link> tudjuk megtenni.Ezután kicsomagoljuk a főkönyvtárunkba. 
         </para>
         <para>
             Szükségünk van még a következőkre: <command>sudo apt-get install libboost-all-dev libpython3.5 openjdk-8-jdk ffmpeg python-tk python-imaging-tk</command>
             </para>
          <para>
              Majd bemegyünk a malmö mappájába ott megkeressük a Minecraft mappát és ott futtatjuk a <command>./launchClient.sh</command>-t
          </para>
          <para>
              Valószínűleg szükséges lesz kiadni a terminálba egy <command>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/</command> és egy <command>export MALMO_XSD_PATH=~/MalmoPlatform/Schemas</command> parancsot a futtatáshoz.
            </para>
          <para>
              Ez megfog nyitni egy MineCraft játék ablakot. Ezután nyitunk egy újabb terminált és megkeressük a python exmaples-t. És itt tudjuk futtatni a mintákat és ha csinálunk saját küldetést szintén ide kell betennünk. Ha esetleg problémák lennének a futtatással érdemes megnézni, hogy a 10000-res portot nem -e használja más alkalmazás mivel alapértelmezetten ezt használja a malmö. Ha esetleg ütközés lenne a run_mission.py ba megkeressük a client infot is itt tudjuk átírni.
          </para>
          <para>
              Ha fut a küldetésünk az f3-al tudunk bővebb információt kapni például memória használat milyen blokk van előttünk milyen irányba nézünk stb.
          </para>
          <para>Minta egy küldetéses xml-re ahol az időt, a játékmódot, küldetés kezdetén a chatre kiirt szöveget stb-t tudjuk beállítani.</para>
          <programlisting language="xml"><![CDATA[
       missionXML='''<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
            <Mission xmlns="http://ProjectMalmo.microsoft.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
            
              <About>
                <Summary>Misszió leírás</Summary>
              </About>
              
              <ServerSection>
                <ServerHandlers>
                  <FlatWorldGenerator generatorString="3;7,220*1,5*3,2;3;,biome_1"/>
                  <ServerQuitFromTimeUp timeLimitMs="50000"/> //itt állíthatjuk be az időt
                  <ServerQuitWhenAnyAgentFinishes/>
                </ServerHandlers>
              </ServerSection>
              
              <AgentSection mode="Survival">
                <Name>QuitBot</Name>
                <AgentStart/>
                <AgentHandlers>
                  <ObservationFromFullStats/>
                  <ContinuousMovementCommands turnSpeedDegs="180"/>
                  <ChatCommands />
                  <MissionQuitCommands quitDescription="give_up"/>
                  <RewardForMissionEnd>
                    <Reward description="give_up" reward="-1000"/>
                  </RewardForMissionEnd>''' + malmoutils.get_video_xml(agent_host) + '''
                </AgentHandlers>
              </AgentSection>
            </Mission>'''
       ]]>
        </programlisting>
        <para>Egy újabb példa az agent-nek kiadott parancsokhoz</para>
        <programlisting language="python"><![CDATA[
       while world_state.is_mission_running:
    print(".", end="")
    time.sleep(0.5)
    count += 1
    world_state = agent_host.getWorldState()
    for error in world_state.errors:
        print("Error:",error.text)
    for reward in world_state.rewards:
        print("Reward:",reward.getValue())
    agent_host.sendCommand("attack 1")
    agent_host.sendCommand("move 1")
    agent_host.sendCommand("jump 1")
print()
print("Mission ended")
       ]]>
        </programlisting>
        <para>Az agent host gondoskodik a cselekvések elvégzéséről.</para>
     <mediaobject>
                <imageobject>
                    <imagedata fileref="img/malmo.png" scale="30"/>
                </imageobject>
        </mediaobject>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/malmo1.png" scale="30"/>
                </imageobject>
        </mediaobject>
          
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chaitin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Iteratív és rekurzív faktoriális Lisp-ben</title>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/z6NJE2a1zIA">https://youtu.be/z6NJE2a1zIA</link>      
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A lisp eltér az eddig használt programozási nyelveinktől. Mégpedig mivel a lisp fordított lengyel jelölést használ. Tehát kicsit másabb gondolkodás módot igényel.Itt az operátorok mindig a változók elé kerülnek és nem közé tehát nem a+b hanem (+ a b). A függvények definiálását a define-al érjük el. Egy szám faktoriálisát kiszámolhatjuk úgy, hogy n-1 faktoriális szorozva n el. Ebből következik, hogy rekurzívan így néz ki a faktorális:
        </para>
     
       <programlisting language="lisp"><![CDATA[
        rekurzív:
            (define (fakt n) (if(< n 1) 1 (* n (fakt(- n 1)))))
            iteratív:
            (define (factorial n)(define (iter product counter)(if (> counter n)product(iter (* counter product) (+ counter 1))))(iter 1 1))
            forrás:https://www.programminglogic.com/factorial-algorithm-in-lispscheme/
        
       ]]>
        </programlisting>
       <para>
           Iteratívan pedig egyszerűen csinálunk egy for ciklust, aminek a countere addig megy amíg kisebb mint a bemenő szám. És eddig összeszorozza az elemeket, amelyek a productban fognak tárolódni.
       </para>
    </section>        
<!--        
    <section>
        <title>Weizenbaum Eliza programja</title>
        <para>
            Éleszd fel Weizenbaum Eliza programját!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
-->
    <section>
        <title>Gimp Scheme Script-fu: króm effekt</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely megvalósítja a króm effektet egy 
            bemenő szövegre!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/OKdAkI_c7Sc">https://youtu.be/OKdAkI_c7Sc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome</link>               
        </para>
        <para>
           A gimp króm effekt készítéséhez úgy kezdünk bele, hogy fekete háttérre fehér szöveget írunk. Majd ezt a két layert összefésüljük. Kezdetben létrehozzuk a programban a lokális változókat. Az imageba a gimp-image-new segítségével elkészítjük az új képet, ennek 3 bemenő argumentuma van szélesség ,magasság és rgb. A gimp-context-set-foreground el állítjuk be a színeket ennek a bemenő paramétere egy rgb színkód fontos, hogy a ' el jelezzük, hogy itt az első elem nem fv-név. A gimp-drawable-fill-el töltjük ki az adott színűre a groundot.
           Az gimp-text-layer-new létrehozunk egy új text layert ez argumentumként megkapja a képet, a szöveget, a betűméretet és a pixeleket. A gimp-image-insert-layer adja hozzá a lajert a képhez a megadott pozícióba. A szöveg eltolását a képen a gimp-layer-set-offsets segíti, ezzel igazítjuk középre. A két layer konbinációját a gimp-image-merge-down éri el. A második lépésben használunk egy erős gaus elmosást. Ezt a plug-in-gauss-iir-el tudjuk használni itt a függvény megkapja a képünket az elmosni kívánt layert, az elmosás értékét és az irányokat.
            A 3. lépésben állitjuk be a színszinteket, hogy egy nagyon világos vakító fehér színű szöveget kapjunk. Itt a gimp-drawable-levels-t fogjuk használni, amely megkapja a layert, azt hogy melyik csatornát akarjuk módosítani,az intenzitási értékeket, és a gammát. A step 4-el ugyan azt hívjuk. Majd az 5. lépésben kijelöljük a hátteret ami a fekete rész és ezt kell invertálni.A 6. lépésben létrehozunk egy új layert és ugyebár az előző kijelölés miatt megmarad a szöveg körvonala mivel a fekete részt szelektáltuk ki és ezt adjuk hozzá a képhez.Majd a 7. lépésben állítunk be egy szürkés skalár színátmenetet(gradienst) a szövegnek.Majd a 8. lépésben készítünk egy bump mapet a szövegnek. Majd a 9. lépésben állíjuk be a színgörbéket a gimp-curves-spline függvény segítségével és készen is van a scriptünk. 
        </para>
        <figure>
             <title>Nemesis króm effektel</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/nemesis.png" scale="100"/>
                </imageobject>
        </mediaobject>
        </figure>
        <figure>
             <title>Nemesisborder króm effektel</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Nemesisborder1.png" scale="400"/>
                </imageobject>
        </mediaobject>
        </figure>     
    </section>        

    <section>
        <title>Gimp Scheme Script-fu: név mandala</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
        <para>
            Ebben a gimp scriptben ugyan úgy mint az előzőnél az elején definiáljuk az új képünket és layereinket. A gimp-image-new függvény létrehoz egy listát, mivel minden gimpfüggvény egy listát ad vissza. A lista elemeihez a car-al férünk hozzá, ami kiveszi a lista első elemét. A legfontosabb rész itt a forgatások mivel a mandala úgy készül, hogy a szöveget körbe forgatjuk egy pontban és így a betűk keresztezik majd egymást. A forgatást a gimp-item-transform-rotate-simple függvénnyel érjük el.A változók értékét a set-el tudjuk beállítani.
            Mivel a betűknek a mérete változó szövegtípúsonként ezért függvényt használunk ezeknek az értékeknek a kezelésére ez a text-wh függvény. Ez konkrétan lekéri a fonttípusnak a méreteit és azt tároljuk a szélességben és a magasságban.
            A forgatások után a plug-in-autocrop-layer törli az üres szegélyeket. Majd megadjuk a szélesség és magasságnak a kirajzolható méreteket a drawable-el ez a függvény a kirajzolható pixelekkel tér vissza. Majd ez alapján újraméretezzük a layert a resize- al. Az ecset méreteit a gimp-context-set-brush-size-al tudjuk módosítani ez pixelben adja meg a méreteket. Ezzel adjuk meg majd a mandala keretének a vastagságát, amelyet az gimp-image-select-ellipse-el hozunk létre. Ebből 2 van az egyik a külső körív a vastagabb 22 pixel míg a véknyabb 8 pixel vastag.
            Párbeszéd ablakokat a gimp-message-el tudunk készíteni. Az elkészített képet a gimp-display-new-al jelenítsük meg új ablakban.Majd ki cleareljük a képet gimp-image-clean-all.
            Futtatáskor a kép méretét tudjuk beállítani a betűtípust és a betűméretet. Ezen kívül a színt és színskálát.
        </para>
        <figure>
             <title>Név mandala</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandala.png" scale="100"/>
                </imageobject>
        </mediaobject>
        </figure>          
    </section>        

<!--    
    <section>
        <title>Lambda</title>
        <para>
            Hasonlítsd össze a következő programokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
-->    

<!--
    <section>
        <title>Omega</title>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
-->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>     
    
            <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>
        <para>
            A megírt programokat "forrásszövegnek" nevezzük. A nyelvtani szabályai a forrásszövegeknek a szintaktikai szabályok, míg a tartalmi szabályokat a szemantika adja meg.
            A forrásszöveget a fordítóprogram alakítja gépi kóddá, amelyet a processzor feltud dolgozni. A fordító program végzi tehát a kód szemantikai,szintaktikai,lexikális vizsgálatát és a kód generálását a szemantikai hibát nem mindig veszi észre mivel lehet, hogy olyan hibát vétettünk, amely formailag helyes csak nem a várt eredményt kapjuk.
            A gépi kódból a szerkesztő állít elő futtatható programot. A magas szintű nyelvek közül a C-ben előfordító segítségével generálunk forrásszövegből forrásszöveget.
            Az interpreternek is megvan a saját elemzője viszont itt soronként veszi az utasítást és egyből el is végzi. A programnyelvek szabályai a hivatkozási nyelvek.
            Amikor a programozó programkódot ír akkor algoritmusokat fogalmaz meg, amivel vezérli a processzort. A lefgőbb eszköz a változó, amelyben értékeket tud letárolni, amelyeket az algoritmusok változtatnak.
            
        </para>
        <para>
            Imperatív nyelvek:Eljárásorientált nyelvek,Objektum orientált nyelvek.
         </para>
         <para>
             Dekleratív nyelvek : Funkcionális nyelvek, logikai nyelvek.
         </para>
         <para>
             Az adattípus egy absztrakt programozási eszköz. Az adattípusnak neve van , amely egy azonosító. Egy adattípust három dolog határoz meg: tartomány, műveletek,reprezentáció. A tartomány megmondja milyen értékeket vehet fel a változó. Minden típúsos nyelvnek vannak standard beépített típúsai. Némelyik programozási nyelv megengedi, hogy definiáljunk típúsokat. Vannak olyan típúsok,amelyet úgy kapok, hogy egy másik típús tartományát szűkítem le ők az altípúsok.Adattípúsok csoportja lehet skalár vagy struktúrált.
             Egyszerű típusok: egész,valós, karakteres,logikai.
             Összetett típusok:tömb(értékei csak egyféle típusú lehet kivéve olyan programozási nyelvekben ahol megvan engedve, hogy a tömb összetett adattípusú legyen.A tömb indexei általában egész típúsúak.A tömb nevével a tömb összes elemére képesek vagyunk hivatkozni.).
             Mutató típus:elemei memóriacímek, legfontosabb művelet a memóriacímen lévő érték elérése.
         </para>
         <para>
             Nevesített konstans: mindig deklarálni kell, van neve, típusa és értéke. Mindig a nevével hivatkozunk rá és a hozzá rendelt értékre hivatkozik.
         </para>
         <para>
             Utasítások
         </para>
         <para>
             Utasításokkal adjuk meg az algoritmus lépéseit.Kétféle van deklarációs és végrehajtó utasítások.
             A deklarációs utasítások a fordítóprogramnak szólnak, olyan infromációt szolgáltat amelyet a fordítóprogram használ fel majd a tárgykód elkészítéséhez.
             A végrehajtó utasítások csoportosítása a következő szerint zajlik:
                     
          </para>
          <itemizedlist>
          <listitem>
              <para>1. Értékadó utasítás:módosítja vagy beállítja a változó értékeit
          </para>
          </listitem>
          <listitem>
              <para>2. Üres utasítás:főleg az eljárás orientált nyelvekben van rájuk szükség ilyenkor a processzor egy üres utasítást hajt végre
          </para>
          </listitem>
          <listitem>
              <para>3. Ugró utasítás:goto utasítás a program a futását máshonnan folytatja(ahová az ugró utasítás mutat) 
          </para>
          </listitem>
          <listitem>
              <para>4. Elágaztató utasítások:if else szerkezet vagy a többirányú switch szerkezet.Itt tudjuk irányítani, hogy a program futása merre haladjon tovább. Ifnél ha egy utasítás van a zárójel blokkot elhagyhatjuk.Switchnél van default-ág amely akkor hajtódik végre ha egyik lehetőség sem hajtódik végre.
          </para>
          </listitem>
          <listitem>
              <para>5. Ciklusszervezı utasítások:bizonyos utasítások ismétlése. Előírt lépésszámú ciklus for.Elől tesztelős ciklus while, hátul tesztelős do while.Ha egyszersem fut le üres ciklusnak hívjuk a do while mindenképp lefut 1x.Emellett a ciklusok lehetnek végtelenek és összetettek mikor egymásba ágyazzuk őket.
          </para>
          </listitem>
          <listitem>
              <para> 6. Hívó utasítás: 
          </para>
          </listitem>
          <listitem>
              <para>7. Vezérlésátadó utasítások:continue, break,return. A continuevel kitudunk hagyni például ciklusból lépéseket,break-el megtudjuk szakítani a ciklust vagy az utasítást. A returnnel adunk vissza értékeket főképp függvényeknél használjuk őket.
          </para>
          </listitem>
          <listitem>
              <para>8. I/O utasítások
          </para>
          </listitem>
          <listitem>
              <para>9. Egyéb utasítások
          </para>
          <para>
              Programok szerkezete:
          </para>
          <para>
              Az eljárásorientált nyelvekben :alprogram,blokk,csomag,taszk létezik.
          </para>
          <para>
              Az alprogramok az újrafelhasználás eszközei másnéven eljárások vagy függvények.A meghívásukkal aktivizálódnak.Meghívni a deklarált nevükkel tudjuk.Az alprogramoknak van neve, paraméter listája,törzse amiben az utasítások és vezérlések szerepelnek és környezete, amelyben megtudjuk hívni. A függvényeknek mindig van visszatérési értékük,tehát értéket számolnak ez az érték bármilyen típúsú lehet.Az eljárás ezzel szemben valamilyen tevékenységet hajt végre és ahol meghívjuk ennek a tevékenységnek az eredményét akarjuk felhasználni.
          </para>
          <para>
              Függvényt meghívni csak kifejezésben lehet. A függvény akkor fejeződik be szabályosan ha van visszatérési értéke. Nem szabályosan legtöbbször megszakítás vagy goto utasítással való megszakítással.
              Minden programozási nyelvben van egy fő program egység a main. Minden alprogram ennek adja át a vezérlést.
          </para>
          <para>
              A hívási lánc: amikor egy programegység meghív egy másik programegységet.
              Rekurzió lehet közvetlen:Amikor a program önmagát hívja meg rekurzívan vagy lehet közvetett amikor egy már előzőleg meghívottat és lefutott alprogramot újra meghív.Ezek mindig átírhatók iteratív algoritmusokká ami kevesebb memóriát használ.Néhány programozási nyelvben meglehet határozni másodlagos belépési pontokat vagyis, hogy ne a fejtől fusson le a függvény vagy az eljárás.
           </para>
           <para>
               Paraméterkiértékelés:formális paraméterlistából csak egy darab van viszont az aktuális paraméterlisták száma végtelen lehet.
               Paraméterkiértékelés aspektusok:sorrendi kötés vagy név szerinti kötés.
               
           </para>
           <para>
               A blokk: olyan programegység amely más programegység belsejében helyezkedik el.A blokk aktivizációja úgy történik hogy vagy rákerül a vezérlés vagy a goto utasítással a kezdetére ugrunk.
           </para>
          </listitem>
          </itemizedlist>
          <para>
              Az I/O:
          </para>
          <para>
              Az I/O az eszközökkel kapcsolatos kommunikációért felelős. Feladata a perifériák és program közötti adatmozgatás. Az I/O-nál az állományok a fontosak. Ezek lehetnek logikai vagy fizikai állományok, amelyeket funkcióik szerint is megkülönböztetjük van az input ami a program bemenete tehát már létező fájl. Az output a program által létrehozott fájl és van az input-output ez az eset, amikor egy fájlt beolvasunk majd módosítjuk a tartalmát,de nem új fájlt hozunk létre mint az outputnál. 
          </para>
          <para>
              Az adatátvitelt is két részre bontjuk van a folyamatos és a bináris átvitel. A bináris átvitelnél a bitsorozatnak meg kell egyeznie a tárban és az adattárolón is. A file streameket mindig deklarálni kell. Figyelni kell, hogy milyen adatokkal dolgozunk és aszerint választani adattípust. A filestream deklarálásával és a filenév megadásával megnyitjuk az adott file-t és ekkor dolgozhatunk vele módosíthatjuk,felhasználhassuk a benne lévő adatokat. Ezeket a filestreameket a használat után mindig lekell zárni. Kiemelt fontossággal a streamwritereket.
              </para>
              <para>
                  A C nyelvnek az input/output alapból nem része ezt külön könyvtár meghívásával implementálhatjuk a nyelvbe.
              </para>
              <para>
                  Kivétel kezelés:
                  </para>
                  <para>
                      A kivételkezelés egy meghatározott program rész, amely akkor fut le ha valamilyen esemény bekövetkezik. A kivételeknek van egy neve és egy kódja.
                  </para>
                  <para>
                      A beépített kivételek például nullával való osztás vagy egy tömb indexén való túl hivatkozás. A programozó is definiálhat kivételeket, ezt főleg a try catch szerkezettel képes elérni vagy az if-el.Kivétel keletkezésekor is folytatódhat a program például a goto utasítás használatával vagy egyszerűen olyan kivételt adunk meg, amely nem szakítja meg a program futását például a do while-ban ha azt vizsgáljuk, hogy a megadott formában adtuk -e meg a bemenetet, ha nem akkor csak annyit csinálunk,hogy újra kérjük, hogy adja meg a felhasználó.
                  </para>
    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>
        <para>
            3. Fejezet Vezérlési szerkezetek
            
            A C-nyelvben az utasításokat pontos vesszővel zárjuk. Az utasítás blokkokat {}-el jelöljük.
        </para>
        <para>
            3.2
            If-else
            
            Az if szerkezet döntést hozó utasítás. Ha(feltétel) utasítás else utasítás2 , az elsre nem mindig van szükség lehet olyan is, hogy ha történik valami akkor csináljon valamit a program,ha nem akkor ugorja át. Az else ág mindig a hozzá legközelebb lévő else nélküli ifhez fog tartozni. Ha nem így szeretnénk akkor az if hatáskörét {}-jelek közé kell tenni. Az ifnek van egy másik fajtája az else if itt több feltétel egymásba ágyazása történik. Itt a legutolsó else akkor fut le ha egyik feltétel sem teljesül. Amint egy teljesül a feltételek közül a program végrehajtja és kilép az else-if ágról.
        </para>
        
        <para>
            3.3 Switch
            A switchet többirányú programelágazások esetén használjuk itt valamilyen állandó értékhez rendeli az utasítást. A switchben case-eket hozunk létre, amelyek akkor futnak le ha teljesül az állandó, ezen kívül minden case-t break-el kell zárni.Létezik egy default ág, amely akkor fut le ha egyik case feltétele se teljesül.
            </para>
            <para>
                A break el nem csak a switchből tudunk kilépni hanem bármely ciklust képesek vagyunk vele megszakítani.
             </para> 
             <para>
                A for előírt lépésszámú ciklus, amelynek van egy kezdő értéke egy végértéke és egy lépésszáma. 
              </para>
              <para>
                  A while addig fut amíg a ciklusfejben megadott feltétel hamis nem lesz.
               </para>
               <para>
                   A do while utasítás a while-al szemben az, hogy mindenképp lefut egyszer a ciklusban található utasítás.
               </para>
               <para>
                   A continue utasítás segítségével lehetséges, hogy egy ciklusból kihagyjunk lépéseket vagyis,hogy átugorjunk egy egy lefutást. A goto utasítással a megadott címkére ugorhatunk, goto utasítással általában több egymásba ágyazott ciklusból tudunk kilépni mivel a break nem működik ezeknél.
               </para>  
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
        <para>
            A BME-tankönyv második fejezete a C++ újításait veszi szemügyre a C-vel szemben ezek nagyrészt, csak az olvashatóbb kódot szolgálják.
        </para>
        <para>
        Az első változás a függvények paraméterénél van.C++ ban ha egy függvénynek nem adunk paramétert akkor az egy void paraméterrel lesz egyenlő. C-ben ugyanez tetszőleges számú paramétert jelentett,de C++-ban ez a lehetőség már a ...-lett.
        </para>
        <para>
            Ha nem adunk meg visszatérési típust akkor C-nél ez az int lesz viszont C++-nál már hibát ír ki a fordító azaz nincs alapból ilyen definiálva.
        </para>
        <para>
            C++-ban kétféle main függvény van van a sima int main() és létezik az int main(int argc,char** argv). Az argc a bemenő paraméterek számát, míg az argv egy 2 dimenziós tömböt ad vissza magukról a bemenő argumentumokról. És C++-ban már nem kötelező a return 0; ami a sikeres futást jelzi.
        </para>
        <para>
            Ezeken kívül bevezetésre került a bool típus ez megkönnyíti az olvasást két értéke van true és false.
         </para>
         <para>
             Emellett alapértelmezett típus lett a wchar_t amivel több bájtos karaktereket lehet letárolni pl unicode karakterek. 
         </para>
         <para>
             Képesek vagyunk C függvényeket meghívni C++-ból ez az extern "C"-vel lehetséges. Ez a fordítottját is lehetővé teszi,ha a C++-ban definiálunk egy ilyen függvényt akkor C-ből képesek vagyunk C++ függvényt hívni.
         </para>
         <para>
             Emellett adhatunk meg alapértelmezett argumentumokat ezeket arra az esetre hozhatunk létre ha létrejöhet olyan hiba, hogy a felhasználó kevesebb argumentumot ad meg ekkor van rá egy alapértelmezett alternatíva.
          </para>
          <para>
              A változók deklarálása bárhol történhet ahol utasítás lehetséges a C++-ban érdemes mindig azelőtt deklarálni egy változót mielőtt felhasználunk ezzel átláthatóbb a kód.
          </para>
          <para>
             Függvénynevek túlterhelése: A C-ben a függvényeket a neve azonosította, így nem lehetett két ugyan azzal a névvel rendelkező fv.-t létrehozni. De a C++-ban egy fügvényt már a neve és az argumentumai együttesen azonosítja.
           </para>
           <para>
               Paraméter szerinti átadás: A függényben pointert hívunk meg int* valami néven,míg a változó elé egy és jelet teszünk, így a változó memória címét adjuk át a függvénynek tehát ha valamilyen módosítás történik a változóval a függvényben az kihat a mainben deklarált változóra is. C++-ban bevezették a referencia típust.Így elég ha simán átadjuk a változó értékét majd a függvényben adunk és jelet az argumentumnak aztán mint egy sima változó úgy tudunk vele dolgozni.
            </para>
            <para>
                Az és jel ezen kívül még egy egyoperandusú operátor ami a változó címét adja vissza C-ben még nem szerepelhetett deklarációnál,így a C++-ezt felhasználhatta a referencia típushoz.
            </para>
            <para>
                A cím szerinti paraméter átadás főként a nagyméretű adatszerkezetnél hasznos ugyanis nem kell egy másolatot készíteni róluk, hanem közvetlenül használhatjuk az adatszerkezetet és módosítgathatunk benne.
            </para>
            <para>
                A programok egységbe zárás alapelvét nevezik osztálynak.Az osztályoknak lehetnek példányai ezeket objektumoknak nevezzük.Az objektumnak azt a tulajdonságát, hogy a többi program ne férjen hozzá a tulajdonságaihoz adatrejtésnek nevezzük.Öröklődés amikor az egyik osztály örökli a másik osztály bizonyos tulajdonságait.Behelyettesíthetőség a fentebb lévő osztályba mindig behelyettesíthessük az elvontabb osztályokat.Típustámogatás az osztályok támogathatnak operátorokat és típuskonverziót.
                A struktúráknak nem csak tagváltozói, hanem tagfüggvényei is lehetnek.A tagváltozók megnevezése attribútumok, míg a függvényeké metódusok. Ahányszor létrehozunk egy példányát a stuktúrára a tagváltozók annyiszor foglalnak helyet a memóriában.A tagváltozókra az arrow vagy a . operátorokkal hivatkozhatunk.A hatókör operátor vagy scope azt segíti elő ha több osztálynak van ugyan olyan nevű függvénye akkor képes megkülönböztetni őket. A tagváltozókkal ellentétben a tagfüggvényeknek nem történik többszörös helyfoglalás ezek egy példányban jönnek létre.
                Mivel a függvények képesek változtatni a tagváltozókat ezért pointereket használunk a tagfüggvényeknél és láthatatlan első paramétereket alkalmazunk.Ezek a láthatatlan első paraméterek a példányosított osztály mutatója.Ha van egy ugyanolyan nevű tagváltozónk és függvény argumentumunk akkor az argumentumok és lokális változók az erősebbek,ilyenkor általában a this-el hivatkozunk a tagváltozókra.Az adatrejtésnél a public részben lévő tagváltozókat mindenki eléri mint egy globális változót viszont a private részben csak a belső tagfüggvények férnek hozzá,ilyenkor lekérdező függvényeket kell írnunk.
                Ha nem írunk láthatóságot szabályzó kulcsszavakat automatikusan publicot használ viszont az osztály private-t.
                Az osztály az egy típus.Egy osztályt több osztály is felhasználhat ezért a .h-fájlban a #ifndef és #define segítségével érjük el hogy az osztálydefiníció többször is be legyen includeolva egy programba.
                Mivel a csak deklarált változók véletlen értékeket hordoznak ezért szükségünk van a konstruktorokra amelyek inicializálják a tagváltozókat.Ez egy olyan speciális tagfüggvény,amelynek ugyan az a neve mint az osztálynak és minden egyes példányosításkor lefut.
                A függvénynév túlterhelése miatt egy függvénynek lehet különböző paraméterszámú konstruktora.A destruktorok a fölösleges memória használat felszabadítását végzik általában ~-el kezdődnek és ezt az osztály neve követi, nem lehet argumentuma.
                Dinamikus memóriaterület kezelés: a malloc és free függvényekkel lehetséges.A c++-ban a dinamikus memória kezelést a new végzi és a felszabadítást a delete.A new használatával már nem kell számolgatni a tömböknél a lefoglalt hely értékét, mivel magától képes kiszámolni.A tömböknél mindig a szögletes zárójelt használjuk tehát a delet-hez is hozzá kell írni a szögletes zárójelet ha tömböt akarunk felszabadítani.
                Ha Fifo adatszerkezetet akarunk használni akkor ha új elemet akarunk hozzáadni akkor eggyel nagyobb területet kell foglalnunk majd a végére beszúrni az értéket viszont ha ki akarunk értéket szedni akkor az elsőnek betett értéket tudjuk kivenni majd miután kiszedtük az értéket belőle a megmaradt elemeket visszamásolni és a destruktor a fölösleges helyet elpucolja.Másoló konstruktor ez esetében az inicializálás a már meglévő osztály változói alapján történik mivel egy másolatot akarunk létrehozni.
                A fordító a másoló konstruktort hívja meg ha megvan írva ha nem írunk másoló konstruktort akkor alapértelmezetten bitenként másol.A bitenkénti másolás neve a sekély másolás.Ha a dinamikus adattagokat is másoljuk azt mély másolásnak nevezzük.Érték szerinti paraméter átadásnál referencia szerint kell átadni a másolókonstruktor paraméterét.
            </para>
            <para>
                A friend függvénnyel egy osztály feljogosít más osztályokat vagy globális függvényeket, hogy a private részéhez hozzáférjenek.Tagváltozókat a :-al tudjuk inicializálni a konstruktor zárójele után írva.A referencia tagváltozókat kötelező az inicializálási listában inicializálni.Statikus változókat a static kulcsszóval deklarálunk.Ez hasonlít a globális változókhoz, de annyi különbséggel, hogy itt megkell adni melyik osztályból származik a ::-al.Kezdőértéket nem kötelező adni nekik, mivel ekkor 0 lesz a kezdőértékük. A statikus változóknak a program indításakor foglalódik hely és csak a program bezárásával szabadul fel.
                A statikus függvények törzsében nem használhatunk this mutatót mivel nem lenne értelme.
                Az első futtatott kód a program indulásakor nem a main függvény első sora hanem a statikus és globális változók konstruktorai.Beágyazott függvények esetén megkell adni a teljes elérési utat,ha nem az osztálydefinícióban definiált.A beágyazott osztályoknál nem kap speciális jogokat sem a beágyazott sem a tartalmazó osztály.A különböző absztrakt adattípusok miatt megjelent az operátor túlterhelés.A c++-ban az operátorok az argumentumaikon végeznek műveletet,az operátorok különböző számú argumentumot igényelhetnek. A c++-ban az operator kulcsszó.Itt nem az operátorok működésének megváltoztatása a cél, hanem az, hogy a saját magunk által létrehozott típusra is használhassuk.A túlterhelt operátorokat általában tagfüggvényként érdemes definiálni.
            </para>
            <para>
              Típuskonverzió:  
            </para>
            <para>
                C++-ban az enum típusnál a típuskonverziót muszáj kiírni, ugyan ez a helyzet a void*-nál ugyan ez a helyzet áll fent. Referenciaként való átadásnál nem használható típuskényszerítés. Ugyanis a memóriareprezentációk eltérőek minden típusnál.Függvénynek nem tudunk átadni ideiglenesen létrehozott értéket, csak ha a függvény konstanst kér paraméterül. Mivel az ideiglenesen létrehozott értékek konstansok.
            </para>
            <para>
                Ha viszont nem akarjuk változtatni az értéket akkor a fordító engedi felhasználni a kényszerített típuscserét csak, ilyenkor a const kulcsszót kell használnunk.Tehát elkerüljük a fölösleges másolgatásokat és dolgozhatunk az argumentumként átadott értékkel.
            </para>
            <para>
                A C++-ban a megírt osztályokat könnyen használhassuk típusként mint a beépített típúsokat akkor azt az operátor túlterheléssel és konverziós konstruktor jelenti a megoldás kulcsát. A stringeket a \0 karakterrel zárjuk ez egy nul terminator karakter, az az egy záró karakter, ezt nem számoljuk a string hosszába. Tehát egy char tömböt a legkönnyebben úgy alakítunk stringgé, hogy túlterheljük az összeadás operátort, amely így összefogja fűzni a szöveget és a char tömb elemszámát 1 el megnövelve a végére tesszük a \0 záró karaktert.
                A típuskonverzió a beépített típúsokra úgy működik, hogy a kívánt típust zárójelekbe zárva elé tesszük az átalakítani kívánt változó neve elé. Ha egy argumentumú a konstruktor akkor itt a konvezió magától értetődik. Ha kiakarjuk kapcsolni az automatikus típuskonverziót akkor azt az osztályunk konstruktora elé írt  explicit kulcsszóval érhetjük el. A visszaalakítást az operator kulcsszóval érhetjük el ilyenkor a konstruktor visszatérési értékéhez nem kell típust megadni mert azt már a bemenetkor megkapott változó megmutatja. Az ilyen operátorok csak tagfüggvényként hívhatók meg, mivel globálisan nem alkalmazhatók.
                Viszont nincsenek kizárva az öröklődés alól és lehetnek virtuálisak is. Ha több megoldás is létezik akkor a fordítónknak megkell adnunk, hogy pontosan, hogyan szeretnénk létrehozni a típus átalakítást. Ha nem írunk másoló konstruktort akkor is létezik, mivel a fordító biztosít egy bitenkénti vagy másnéven sekély másolást. A leszármaztatás és az öröklődés nagyon veszélyes ugyanis felléphet olyan probléma, hogy a mutató a program által használt memóriaterüten kívülre próbál hivatkozni, ezért az oprendszer a biztonság szempontjából leállítja  a programot.
             </para>
             <para>
                 A c++ a típuskonverzióra új teret nyit ezek a castok. Ez lehet statikus vagy dinamikus vagy konstans, esetleg újraértelmező konverzió.Használata az előző 4 _cast típus_neve és az átalakítani kívánt változó. Konstans típust csak konstans típuskonverzió alakíthat nem konstans típussá.
             </para>
             <para>
                 Kivételkezelés(hozzá kapcsolódó rész a pici könyvben):
                 </para>
                 <para>
                     A kivételkezelés lényege, hogy a program futása során felmerülő problémákat kezeljük. Tehát a program ne hibásan folytassa a működését.
                     Ha valamilyen kivétel bekövetkezik a kivételkezelő segítségével érjük el, hogy a program egy új ágon folytatódjon. A try-catch szerkezet az alap hibakezelő parancs.Itt különböző hibaüzeneteket a throw kulcsszóval tudunk megadni. A try blokkban lévő kód lefut ha nem tapasztal hibát és ilyenkor a catch ág nem fut le és a catch után folytatódik azonnal a program. Ha hibát tapasztal akkor kiirja a throw-ban megadott hibaüzenetet. A throw paraméterét kivétel objektumnak is nevezzük. A throw utasítás a returnhoz hasonló. A catch(...) minden kivételt eltud kapni viszont ha megadunk neki valamilyen argumentumot akkor csak akkor dob hibaüzenetet ha illeszkedik valamelyik hiba típusra. A nem elkapott kivételek esetén a program meghívja az abort függvényt, amely a program bezárásával jár ezek a kezeletlen kivételek. A kivételkezelésnek vannak szintjei, ezt a try-catch blokkok egybeágyazásával érhetjük el. A kivételkezelésnél lehetséges a kivétel újra dobása tehát a throw-al elkapott hibát tovább dobhatjuk a throwval egy fentebbi szinten lévő kivétel kezelőnek. A kivétel dobása és elkapása között is futhat le utasítás, ilyenek az osztályok destruktorai amelyek felszabadítják az objektumot. Az uncaught_exception függvény megmondja, hogy a kivételkezelés miatt futott -e le a destruktor vagy sem. A valóságban persze kivételkezelő osztályokat használunk inkább a kivételek kezelésére. 
                 </para>
    </section>        
  
</chapter>  
</part>                                                              

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Második felvonás</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Berners Lee!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>C++ és Java</title>
        <para>
            Ebben a fejezetben a Java és C++ nyelv összefüggéseit és különbségeit fogjuk vizsgálni és bővebben tárgyaljuk a Java programozási nyelvet. Már a könyv elején is említik, hogy
            a Java a jelölésrendszerében nagyon sokmindent átvett a C++-ból.Az előzőleges tudásunkból pedig tudjuk, hogy a C++ eljárás és objektum orientált
            nyelv, míg a Java már szimplán az objektum orientált szemléletmódot követi. Az objektum orientált programozás célja, hogy implementálja a valós-világ egyedeit. Az objektum a valós világ egyedeire utal. Míg az objektum orientált programozás egy paradigma arra, hogy
            olyan programot írjunk, amely osztályokat és objektumokat használ.Az objektumoknak vannak tulajdonságai és van viselkedésük.Az objektumok tulajdonságait változókkal írjuk le általában, míg a viselkedésüket a metódusokkal jellemezzük. Az objektumok lehetnek fizikai vagy logikai dolgok.
            Emellett az objektum orientáltságnál fontos megemlíteni az öröklődést.Amikor az egyik objektum örökli minden tulajdonságát és viselkedését a szülőobjektumától.
        </para>
        <para>
            
        </para>
        <para>
            A Java-ban ezen kívül nagy figyelmet fordítottak a biztonságra és a megbízhatóságra.
            Ebből következik az, hogy itt már nincsenek pointerek minden referencia. A Javában interpretert használnak, míg a C++-ban compiler végzi a fordítást.
            A C++ fordító gépi kódra fordítja a programot. Addig a Java fordítóprogramja egy byte kódot hoz létre, amelyet a JVM futtat. Ezért a Java platform független. Míg azért a C++-nál vannak megkötések.
            A Java program objektumok és ezek blueprintjeinek összessége. Az osztály változókból és metódusokból épül fel. A JVM hátránya a sebesség.(lassabb mint a compiler)
        </para>
        <para>
            
        </para>
        
        <para>
            Javában ha több osztályunk van akkor mindig azt fogja futtatni, amelyikben a JVM megtalálja a main-t.Javaban a C vagy C++ nyelvtől eltérően a visszatérési típus megadása minden metódus számára kötelező.
            A C++-tól eltérően itt már egy igazi String szövegtömbbel kerülnek átadásra a paraméterek nem char.
        </para>
       
        <para>
        A java-val könnyen írhatunk olyan kódot, amely html-ben futtatható ez az applet.Ilyenkor a html oldalon kívül a java kód is letöltődik a weboldalt megtekintő részére és a távoli gépen fog futni.Persze gondoltak arra,hogy ez veszélyforrást jelenthetne
        a vírusok miatt, de a java futtatórendszerének erős a biztonsági rendszere. Az applet programoknak fontos jellemzőjük, hogy hiányzik a main metódusuk.
        </para>
        
        <para>
            A változók típúsai nem különböznek a C++-ban használtaktól.
        </para>
       
        <para>
            Javában a final kulcsszóval hivatkozunk rájuk,míg C++-ban const ként. Javaban lehetőségünk van ezenkívül az unicode karakterek használatára is mivel már nem a 8 vagy 7 bites karaktereket használja, mint a C++ vagy a C.
        </para>
        
        <para>
            A megjegyzések használata megegyezik a C++-éval, kivétel hogy itt már vannak dokumentációs megjegyzések, ami olyan mint a több soros megjegyzés csak 2 db *-al kezdjük.
            A dokumentációs megjegyzéseket a javadochoz tudjuk használni.Ez kiszedi a kódból a lényeges információkat és egy html oldalként jeleníti meg. Használata olyan mint a fordítása a java programoknak csak nem javacot használunk,hanem javadocot.
        </para>
        
        <para>
            Ugyan úgy mint C++-ban a class szóval hívjuk meg.Minden egyes osztály tagnak egyessével adhatjuk meg a láthatóságát.Ha elhagyjuk akkor csak az adott osztályban látható.
            Az új objektumokat szintén ugyan úgy a new kulcsszóval vagyunk képesek létrehozni.Javaban az új objektumok létrehozásukkor inicializálódnak 0 vagy null értékkel. A nyelvben már nem karakter tömb hanem ellenőrzőtt String osztály szerepel.
            A static kulcsszó nem egy elemhez tartozik hanem az osztályhoz.Ez azt jelenti, hogy a new alkalmazásakor nem foglalódik le memóriaterület számukra az objektumban.Nem kell inicializálásnál értéket adni nekik. Ezen kívül az osztály nevével is hivatkozhatunk rájuk.
            Az ezzel megjelölt objektumból tetszőleges számú objektum készítése után is csak egy lesz.A memória felszabadítása úgy történik, hogy egyszerűen már nem hivatkozunk az objektumra, azaz null értéket adunk neki,ezzel szemben C++-ban a delete vagy a free metódust kellett használnunk. 
        </para>
        <para>
        A metódusok a C++-hoz hasonlóan működnek és a kivételkezelés is a try-catch-el.A C++-al ellenben a Java már tartalmazza a párhuzamosítást és a grafikai megoldásokat sem kell különböző megoldásokkal megoldani pl Qt.A javának már van saját grafikai csomagja a Swing.Emellett kikerültek a Javaban a nyelből a goto és a const szavak ezek bár foglaltak mégsem használtak.
        
            
        </para>
        <para>Literálok:</para>
        <para>
         A típusoknál a primitív típúsú típusok mellet megjelentek a csomagoló osztályaik.
         pl.:az int nek az Integer.Ez annyiban különbözik, hogy ezek objektumhivatkozásokat tartalmaznak.Ezek bizonyos kontextusokban nyerik el valódi jelentőségüket.Ilyenek az adatszerkezetek.
         A java nyelvben a tömböket ugyan úgy kell megadni viszont a C++tól eltérően ez már igazi típus és nem csak a mutatók egy másik formája.  
        </para>
        <para>
            Metódusnevek túlterhelése:
        </para>
        <para>
            Egy osztálynál több metódus is szerepelhet ugyan azzal a névvel, ha a formálisparamétereinek a száma vagy típúsa eltérő. A java fordító alapból tudni fogja ezekből, hogy mikor melyik metódust kell meghívni. C++-ban is hasonlóképpen működik.
        </para>
        <para>
            Bezárás,adatrejtés:
        </para>
        <para>
            Az osztályoknál a jellemzőknek és metódusoknak két fajtájuk van. Vannak amelyeket elrejtünk más osztályok elől ez a privát vagy védett(protected).És vannak amelyeket megosztunk másokkal ezek a public információk.
            Az állapotleíró jellemzőket általában privátként használjuk, míg a metódusok többsége publikus. A jelöletlen tagokra nem hivatkozhat bármelyik osztály csak az azonos csomagban lévők látják. A privát tagokat csak az osztályon belül lehet látni.
            A protected szorosan összefügg az öröklődéssel, mivel ez a félnyilvános láthatóság kiterjesztése.A protected kategóriájú konstruktort egy más csomagba tartozó gyermek csak a super kulcsszóval képes meghívni.
        </para>
        <para>
            Osztályhierarchia:
        </para>
        <para>
            Az osztályok egymáshoz viszonyított összességét osztályhierarchiának nevezzük.Minden osztálynak az Object osztály vagy szülője ha nem használtunk extends-et rajta vagy pedig őse.
        </para>
        <para>Öröklődés vagy inheritence:</para>
        <para>
            Öröklődésnél egy osztály alosztályát hozzuk létre, amely örökli a szülő jellemzőit és metódusait. És ezeket sajátjaként használja.De ezenkívül lehetnek más tulajdonságai és metódusai is. Vagy olyan metódusai, amely ugyan azt csinálják mint a szülő osztálynak csak másképpen.
            Az öröklődés egy is-a kapcsolat. Az öröklődés C++-ban a :-al történik,míg javában az extends kulcsszót használjuk.Javaban a super kulcsszóval használhatjuk a szülő konstruktorát, de alapvetően a gyerek nem örökli a konstruktorokat. C++-ban engedélyezett a többszörös öröklődés, de javaban nem.
        </para>
        <para>
            Absztraktáció:
        </para>
        <para>
            Az absztraktáció az amikor egy osztályból létrehozunk egy vázlatot nem deklarálunk semmi, csak definiálunk és ebből majd leszármaztatunk osztályokat. Absztraktációnál megfigyeljük, hogy mik a közös tulajdonságai az objektumainknak amikkel dolgozunk és lényegében egy közös interfészt nyújt, amely minden száramaztatott objektumra egyaránt érvényes.
        </para>
        <para>
            Polimorfizmus:
        </para>
        <para>
            A polimorfizmus lehetővé teszi, hogy mivel a gyermek minden olyan tulajdonsággal rendelkezik mint a szülője, ezért minden olyan esetben ahol a szülő használható, ott legyen használható a gyerek is.
            Felülbíráló polimorfizmus mikor a gyermek örököl egy metódust a szülőtől viszont a gyermeknél az a metódus másképpen működik ezért lehetőség van overrideolni a metódusokat. Tehát az a lehetőséget, hogy egy változó nem csak a deklarált típúsú, hanem a származtatott objektumra is hivatkozhat polimorfizmusnak nevezzük.
            Osztálydefiníciókat nem lehet felüldefiniálni csak elfedni. Mindig futási időben dől el, hogy a metódus mely implementációját kell meghívni ez a dinamikus kötés.C++-ban a dinamikus kötést a virtual kulcsszóval kellett jeleznünk java-ban minden virtuális kötéssel van ellátva.
        </para>
        <programlisting language="java"><![CDATA[
            class Alakzat{
            void kiir(){System.out.println("Alakzat vagyok");}
            }

            class Haromszog extends Alakzat{
                void kiir(){System.out.println("Háromszög vagyok");}
            }

            class Teglalap extends Alakzat{
                void kiir(){System.out.println("Teglalap vagyok");}
            }

            class Pelda{

             public static void main(String[] args) {
                
                Alakzat a=new Alakzat();
                a.kiir();
                a=new Haromszog();
                a.kiir();
                a=new Teglalap();
                a.kiir();
             }
                
    
            }
          ]]>
        </programlisting>
        <para>
            Interface:
        </para>
        <para>
            Az interface már a C-óta létezik protokoll néven, innen vette át a java csak módosítva. Az interface egy új referencia típus.Az interface-ben a metódusok megvalósítás nélkül szerepelnek azaz csak deklarálva szerepelnek.
            Az interface egy felületet definiál. Az interfacek használata egy új absztraktációs szintet jelent, így el lehetet vonatkoztatni a konkrét implementációtól. Ez megkönnyíti a tervezést és segíti a módosíthatóságot. Az interface használata az implementációján keresztül történik.Egy osztály implementál egy interfacet ha az osztály minden egyes interface által specifikált metódushoz
            implementációt ad. Ahol interface szerepel típusként ott az interface-t implementáló osztály vagy leszármazottjának példánya felhasználható.
            Interfaceknél is létezik öröklődés itt kiterjesztésnek nevezzük.Az osztályokéval ellentétben itt lehetséges a többszörös öröklődés. Egy osztály tetszőleges számú interfacet örökölhet, ez kiváltja a C++-os többszörös öröklődést.
        </para>
        <para>
            A kulcsszavak: Azok a szavak amelyből a nyelv építkezik. Tehát ezek lefoglalt karakterek, amit nem adhatunk meg azonosítónak. Az azonosítók például változónevek azok a szavak amelyek betűvel kezdődnek majd folytatódhatnak számmal vagy betűvel.
            Emellett vannak a literálok, amelyek nevesített konstansok értékeként vagy kezdőérték adáskor használatosak. Emellett lefoglalt karakterekhez tartoznak az operátorok, amelyek lehetnek egy vagy több operandúsúak. Használatukkor valamilyen művelet(matematikai,logika) hajtódik végre.
        </para>
        <para>
            Utasítások:kétféle létezik a deklarációs és a kifejezéses. Deklarációs változók létrehozása, metódusok definiálása például. Kifejezéses a metódusok meghívása vagy ilyen például a prefix és a postfix operátorok használata. De az értékadás és példányosítás is.
            A deklarációs utasítás a változó létrehozását és kezdőérték adását foglalja magába. Ezeknél jön képbe a blokkok használata és a hatáskör egy változónak az adott blokkon belül van hatásköre. Persze van kivétel is.
        </para>
        <para>
            Konstansok: Javában a final kulcsszóval tudjuk létrehozni őket c++-ban ugyan ezt a const-al érjük el. A konstansoknak mindig nevet adunk és kezdőértéket. A típúsuk lehet bármilyen. A konstansok értéke nem változik a program futása során.
        </para>
        <para>
            Karakterkészlet: a java a c++ 8bites karakterkészletével szemben már 16 bites karakterkészeltet használ, amely már a magyar szavakat is magába foglalja.
        </para>
        <para>
            Metódusok: Az osztályok metódusai ugyebár az objektumok viselkedését írják le nem úgy mint a változók, amelyek a tulajdonságukat az objektumoknak.
        </para>
        <para>
            Konstruktorok: Minden osztálynak van egy konstruktora mind javaban mind C++-ban. De emellett írhatunk újabb konstruktorokat. De lesz mindig egy alapértelmezett, amely nem vár paramétert. Ugyebár itt is él a metódus túlterhelés lehetősége. A konstruktor neve megegyezik az osztály nevével.
            A konstruktorok minden példányosításkor meghívódnak. Öröklődéskor gyakori, hogy a leszármaztatott osztály meghívja a szülője konstruktorát.
        </para>
        <para>
            Destruktorok: Javaban garbage collector c++-ban magunknak kell definiálni. Lényegében itt szabadítjuk fel az objektum által lefoglalt területet a memóriában,azaz töröljük az objektumot. A destruktor neve szintén megegyezik az osztály nevével csak itt egy ~ a neve előtt jelzi, hogy ő a destruktor. Alapból létrehozódik egy a compiler által
            akkor kell sajátot írni ha van dinamikusan lefoglalt memóriánk az osztályban.
        </para>
        <para>
            Indexelők: Szögletes zárójelekbe írjuk főként tömböknél használjuk őket.
        </para>
        <para>
            A beágyazott osztályok lényegében osztályok az osztályban ezzel jelezzük a szoros kapcsolatot például,hogy egyik nem létezhet a másik nélkül,mert önmagában nem értelmezhető.
        </para>
        <para>
            Gyűjtemények: olyan adatszerkezetek amely több objektumot tudnak tárolni, akár különböző típúsúakat is. C++-ban tömböt létrehozhatunk mutatók segítségével is maga a tömb egy olyan mutató amely más mutatókra mutat, amelyek a tömbben tárolt elemek címére mutatnak. Javában nincsenek mutatók tehát ilyet nem tehetünk meg.
        </para>
        <para>
            Lambda kifejezések: egysoros utasítások amelyek lerövidítik és egyszerűbbé teszik a kódot általában a visszatérési értékük határozza meg a típúsúkat. Szerepel mind a C++-ban a C++11 től és a javaban is. Lényegében egyszeri felhasználású kódok, ezért is nem nevezzük el őket azaz névtelenek.
            Viszont más a definiálásuk. Nézzük is meg:
        </para>
        <programlisting language="java"><![CDATA[
            C++-ban a lambda kifejezés:
            [ captures ] <tparams>(optional)(c++20) ( params ) specifiers exception attr -> ret requires(optional)(c++20) { body }
            Captures lehet =-jellel érték szerint másolni vagy referenciaként &-el lehetséges. () a paraméterek kerülnek ide amiket átadunk a lambdának. Majd végül a -> operátor után jöhet a body {}- hogy mit csináljon a lambda utasítás.
            Javaban a lambda kifejezés:
            lambda operator -> body
            pl: (p) -> System.out.println("One parameter: " + p);
            ]]>
          </programlisting>
          <para>
              Streamok: Javaban mint minden ez is objektumként van jelen. Tehát osztály felel a streamokért. C++-ban ez byte sorozatokként jelenik meg,tehát adatfolyamatokban(streamokban). A C-ben 3 előredefiniált és megnyitott állomány leírója. Az első az stdin ami a standard input C++-ban a cin.
              A második az stdout a standard output vagy C++-ban a cout. És az stderr a szabványos hibakimenet.  Ezek magas szintű állományleírók az stdin csak olvasható a másik kettő csak írható. C++-ban leírók helyett már objektumok vannak. Az istream típúsú objektumok csak olvasható bemeneti adatfolyamatokat, míg az ostream csak írható
              kimeneti adatfolyamatokat takarnak. Ezek az adatfolyamatok a következő operátorokat használják:
          </para>
          <programlisting language="java"><![CDATA[
            beolvasás >> és kiírás << operátorok
            ]]>
          </programlisting>
          <para>
              A használatához bekell építenünk a az iostream állományt. C++-ban az állománykezelések is adatfolyamokat használnak. A kétirányú adatfolyamot az fstream valósítja meg. Az állományok megnyitását a konstruktorok végzik lezárásukat a destruktorok. Az adatfolyamok mögött létezik egy buffer, amely kezeli a beí¶t adatokat.  Az adatfolyam buffer itt egy olyan objektum, 
              amely rdbuf tagfüggvényének paraméter nélküli változatával lekérdezhető az adatfolyamba beírt karakterek.
          </para>
          <para>
              Szerializáció: Az objektumokat byte sorozattá alakítja. A használatához egy interface szükséges a Serializable.
          </para>
          <para>
              Kivételkezelés: lényegében ez a hibakezelés, ha futási időben valamilyen probléma történik, amire számítunk, hogy bekövetkezhet. Például: rossz file név, kevés bemeneti argumentum stb.
              Akkor ezeket képesek vagyunk kezelni és a futást a hibakezelő ágon folytatni. Ez C++-ban és Javaban is a try catch segítségével történik. De persze nem csak hiba felmerülésekor dobhatunk
              exceptiont azaz kivételt. Javaban természetesen ez is objektum lesz mivel osztályokon alapszik az egész. És persze kiegészül a try-catch szerkezet egy finally-val.
          </para>
          <para>
              Annotációk: @-al jelöljük őket a kódban. Ez lényegében a fordítónak nyújt segítséget. Nagyon gyakran fordul elő Javaban az @Override. Lényegében ez azt mondja meg, hogy felüldefiniáljuk a függvényét
              a szülő osztálynak. Tehát a fordítónak ellenőriznie kell, hogy ez megtörténik -e.
          </para>
          <para>
              Multiparadigmás nyelvek: Ahogy a neve is sugallja ezek olyan nyelvek, amelyek több programozási paradigmát támogat. Ezzel nyújt nagyobb szabadságot a programozónak. Tehát több eszközt is nyújt a programozónak
              egy probléma megoldására. És a programozó feladata a számára leghasznosabb kiválasztása.
          </para>
  
    </section>
    <section>
        <title>Python</title>
        <para>
            A pythont 1990-ben alkotta meg Guido van Rossum. Ez egy magas szintű,dinamikus,objektum orientált programozási nyelv.
            Pythonban a fejlesztés sokkal könnyebb mint Javaban vagy C/C++-ban. Tökéletes választás a prototípusok elkészítéséhez vagy algoritmusok teszteléséhez.
            Rengetek modult tartalmaz. Ezek lefedik a hálózatkezelés,felhasználói felület kialakítása,fájlkezelés,rendszerhívások területet és ezen kívül még sok mást is.
            A pythonnak nincs szüksége fordításra vagy linkelésre.A kódok pythonba sokkal rövidebbek mint java-ban vagy c++-ban.A magasszintű adattípusok segítségével összetett kifejezéseket valósíthatunk meg röviden.
            A csoportosítás egyszerű tagolással működik nem kell zárójelezni. Nem kell a változókat vagy argumentumokat definiálni,ezen kívül a ; is elhagyható az utasítások végéről.
            Ha több sorban akarunk utasítást használni a \-t kell használni.A python kis és nagybetű érzékeny. Az értelmezője mindent tokenekre bont. Tokenfajták:azonosítók,kulcsszók,operátorok,literálok,delimiterek.
            A megjegyzéseket a #-el írhatjuk, ez a sor végéig tart. A pythonba minden adatot objektum reprezentál.Itt nem muszáj változó típust adni,ez automatikusan történik érték alapján.
            </para>
            <para>Adatszerkezetek: ennesek sima zárójellel hivatkozunk rájuk az értékek közé vesszőt teszünk, listák kocka zárójellel hivatkozunk rá,szótárak kapcsos zárójellel hivatkozunk rájuk kulcs-érték párokat használ.
            Pythonban a null értékre None-val hivatkozunk.Szekvenciákat a + jellel fűzhetünk össze. Az indexek 0-nál kezdődnek,és ezekre a :-al hivatkozhatunk.
            
        </para>
        <para>
            Változók:objektumokra mutató referenciák,nincs típusuk.Ugyan úgy mint a javánál ha egy objektumra nem hivatkozik már semmi, akkor a garbage collector felszabadítja.
            Egy változó hozzárendelést a del kulcsszóval törölhetünk.A függvényben felvett változók alapértelmezetten lokálisak lesznek, ha globálisat akarunk létrehozni a függvény elején kell és a global kulcsszót kell elé írnunk.
        </para>
        <para>
            Lista műveletek:count megadja az előfordulások számát,append hozzáfűz a lista végére,extend egy másik listát fűz a lista végére,insert beszúr egy elemet a megadott helyre.
            Remove eltávolítja az első előfordulást a listából,pop az i edik elemet távolítja el.Revers megfordítja az elemek sorrendjét.Sort:sorba rendez.
        </para>
        <para>
            Kiiratás konzolra maradt a print.Az if hasonló mint a többi nyelven kivéve, hogy itt else if helyett elif-van. A függvények is hasonlóak kivéve a fornál a 3 as tagolásból kettő lett csak megkell adni min lépkedjen végig a ciklus.
            Támogatja a goto utasítást. Függvényeket a def kulcsszóval hozhatunk létre.Függvényeknek egy visszatérési értéke van,de akár ennesekkel is visszatérhet.
        </para>
        <para>
            Ahogy már említettem a python támogatja az objektum orientált programozást. Osztályokat a class szóval hozhatunk létre.Az osztályoknak lehetnek attribútumai és függvényei.
            Ezen kívül van inheritance-is azaz öröklődés. Az osztályoknak lehet egy speciális konstruktor metódusuk az _ _init_ _.A speciális tulajdonságú változókat és függvényeket jelezzük még úgy, hogy két alulvonás közé írjuk őket.
            Az init függvény első paramétere a self azaz az objektum maga.
        </para>
        <para>
            Modulok:Sokat segítenek a mobilapplikáció fejlesztésben. PL.:messaging modul az sms üzenetek kezelését,sysinfo a telefon adatainak lekérdezése imei,aksi töltöttségi szintje.
        </para>
        <para>
            A kivételkezelés szintén támogatott és hasonló a C++hoz try-catch szerkezet.
        </para>
    </section>
</chapter> 
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>
            A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá,
            hogy a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elő, kell egy
            példánytag, amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell
            az algot.) és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
            https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf (16-22 fólia)
            Ugyanezt írjuk meg C++ nyelven is! (lásd még UDPROG repó: source/labor/polargen)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/polar">https://github.com/Savitar97/Prog1/tree/master/polar</link>              
        </para>
        <para>
            A polargenünk két előállított normálisa a v1 és v2 változó. A példánytagunk, amely a nem visszaadottat tárolja az a tarolt nevű változó.
            A logikai tagunk a nincsTarolt változó ezt igazról indítjuk, mivel az elején még nincs érték a tarolt nevű változónkban.
            </para>
            <programlisting language="java"><![CDATA[
            boolean nincsTarolt = true;
            double tarolt;

            public PolarGen () {

            nincsTarolt = true;

            }
            ]]>
        </programlisting>
            <para>
            Tehát elsőnek az if águnknak a true ága fog lefutni elsőként.
            Itt addig fut a do while ciklusunk, amíg a w változó értéke nem lesz 1-nél nagyobb. Majd számolunk egy r-t. A tarolt változónkba letároljuk az r*v2-t. Majd a nincsTarolt-at negáljuk és kiiratjuk a nem tárolt normálist az r*v1-et.
            Következő futtatásnál az ifnek a hamis ága fog lefutni. Tehát a letárolt értéket fogja kiiratni a program és a nincsTaroltat újra negáljuk ezzel true-ra állítjuk, hogy új két normálist számoljon a programunk. A konstruktorban inicializáljuk a nincsTaroltat, hogy minden egyes objektum példányosításnál true értéket vegyen fel a nincsTarolt változó.    
        </para>
        <programlisting language="java"><![CDATA[
            public double kovetkezo () {

            if (nincsTarolt) {

            double u1, u2, v1, v2, w;
            do
            {
                u1 = Math.random();
                u2 = Math.random();
                v1 = 2 * u1 - 1;
                v2 = 2 * u2 - 1;
                w = v1 * v1 + v2 * v2;
            }
            while (w > 1);

            double r = Math.sqrt ((-2 * Math.log (w)) / w);

            tarolt = r * v2;
            nincsTarolt = !nincsTarolt;

            return r * v1;
            }
            else
            {
                nincsTarolt = !nincsTarolt;
                return tarolt;
            }

            }

          ]]>
        </programlisting>
        <figure>
             <title>Polargen random</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/polargen.png" scale="200"/>
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            A C++-os verziónál a header file-ban írjuk meg a <classname>PolarGen</classname> osztályunkat. Az osztálynak itt nem csak a konstruktorát kell megírni, de a destruktorát is. Javaval ellentétben, ugyanis ott a garbage collector elvégzi a munkát, tehát nekünk nem szükséges definiálnunk.
            Az osztály kovetkezo nevű függvényét mivel kívülről hívtuk meg, ezért a ::-t kell használnunk, amely mutatja melyik osztály hatáskörébe tartozik. A felépítés a Java-s hoz képest nem sokat változott. A különbség annyiban szenbetűnő, hogy a java erősen objektum orientált, míg a C++-ban lehetőségünk van ettől eltérni.
            A példányosításnál is látunk minimális különbséget ugyanis a javaban mindig a new kulcsszót kell használnunk, míg C++-ban elég az osztály nevét és az objektum nevét megadni.A polargen lényegében két randomot állít elő (-1,1) intervallumban a függvény segítségével.
            A java jdk könyvtárában hasonlóképp megtalálható a jdk/src/share/classes/java/util Random.java fájlában, de nem teljesen ugyan az a kettő.A jdkban szereplő kód a következőképpen néz ki:
        </para>
        <programlisting language="java"><![CDATA[
            synchronized public double nextGaussian() {
        // See Knuth, ACP, Section 3.4.1 Algorithm C.
        if (haveNextNextGaussian) {
            haveNextNextGaussian = false;
            return nextNextGaussian;
        } else {
            double v1, v2, s;
            do {
                v1 = 2 * nextDouble() - 1; // between -1 and 1
                v2 = 2 * nextDouble() - 1; // between -1 and 1
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s == 0);
            double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);
            nextNextGaussian = v2 * multiplier;
            haveNextNextGaussian = true;
            return v1 * multiplier;
        }
        }
          ]]>
        </programlisting>
        <para>
            A feladat az elmélethez úgy kapcsolódik, hogy egy egyszerű osztály szervezést mutat be. Találunk itt tagváltozókat, metódusokat, példányosítást.
            Emellett még az egységbe zárás jelenik meg. De ez olyan általános hiszen a sima függvényeknél is tapasztaltuk már. Láthatósági szintekből a public tűnik fel.
        </para>
    </section>        

    <section>
        <title>Homokozó</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Binfa">https://github.com/Savitar97/Prog2/tree/master/Binfa</link>              
        </para>
        <para>
            Servlet megoldása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/WebApplication1">https://github.com/Savitar97/Prog2/tree/master/WebApplication1</link>
        </para>
        <caution>
            <title>
                Tutoráltás
            </title>
            <para>Ebben a feladatban tutoráltam Molnár Antal Albertet,Ádám Petrát.</para>
        </caution>
        <para>
            Az elmélet a feladathoz úgy kapcsolódik, hogy rávilágít két objektum orientált nyelv között elég könnyű az átmenet itt például a pointerek elhagyása szemléltette ezt.Tehát itt a paradigma játszik nagyobb szerepet az elméletből.
            A binfa java a c++-hoz képest nem sokat változik. A különbség annyi, hogy itt nem választhatunk, hogy tagként,referenciaként vagy esetleg pointerként adjuk át a csomópontot.
            Ugyanis a javaban nincsenek pointerek. A létrehozott <classname>Node</classname> osztály azaz a csomópont osztály tartalmaz egy érték változót és egy jobb és egy bal oldali objektumát a csomópontnak.
            Ezen kívül tartalmazza a jobb és baloldali csomópontok értékének lekérdezéséhez szükséges get függvényeket és az értékek beállításához szükséges set függvényeket, ezen kívül a csomópont értékének lekérdezéséhez szükséges get függvény.
        </para>
        <programlisting language="java"><![CDATA[
        class Node {
        private char value;
        private Node left;
        private Node right;
        
        public Node(char rhs){
            value = rhs;
            left = null;
            right = null;
        }
	
	
        public char getNode(){
            return value;
        } 
        
        public void setLeft(Node rhs){
            left = rhs;
        }
        
        public void setRight(Node rhs){
            right = rhs;
        }
        
        public Node getLeft(){
            return left;
        }
        
        public Node getRight(){
            return right;
        }
        
        }
          ]]>
        </programlisting>
            <para>
            Most nézzük a <classname>binfa</classname> osztályt. Először is létrehozunk egy final kulcsszóval ellátott Node objektumot a root-ot, ez lesz a fánknak a gyökere. Tehát ennek az értéke nem változik fix marad az egész program futása során. Ezen kívül létrehozzuk a csomópontnak a jelenlegi objektumát amibe, majd az értéket pakoljuk, ami éppen jön a bemenetről.
            Emellett itt definiáljuk az átlaghoz,mélységhez,magassághoz és szóráshoz szükséges változókat private kulcsszóval. Javaban látszik, hogy nem private blokk van, hanem mindig jelezni kell, hogy az a változó,metódus,függvény stb éppen milyen láthatósági körben szerepel.
            Az osztály konstruktorában inicializáljuk a csomópontot és a fa magasságát és a fa kezdetét ráállítsuk a csomópontra. Ugyanis innen fogunk indulni.
            Emellett csinálunk egy olyan Node típúsú függvényt, amely mindig a root-ot fogja visszaadni. Az épp bemenő értékeket a metódusokban és a Node konstruktorában is jelzett Node típúsú rhs objektumba adjuk át. A write függvénnyel írjuk be a bemenő értékeket a fába. Ha a bemenő karakter 0, akkor megnézzük van -e érték a bal oldalon, ha nincs akkor létrehozunk egyet azaz beírjuk a 0-ást a fába.
            Egyébként ha van akkor rálépünk arra a csomópontra és nézzük a következő karaktert. Ugyan ez fut le akkor is ha 1-es érték megy be a fába csak logikusan ott a jobb oldalt vizsgáljuk. A writeout metódussal fogjuk kiiratni a fánkat.Ezen kívül még vannak a mélység,átlag,szórás számoló függvényeink.
            Legutolsó sorban nézzük meg a <classname>main</classname> osztályunkat. Itt láthatjuk, hogy String args-t vizsgálunk. Ugyanis a binfának megkell adni egy bemenetet és egy kimenetet. Ha tehát az argumentumaink száma kisebb mint 2 akkor hibát iratunk ki. Majd létrehozunk egy filereadert és példányosítjuk a Binfánkat bt néven.Majd a while függvénnyel olvassuk ki a bemenő file-ból az adatokat kihagyva pár karaktert például a spaceeket. Végül a 2. megadott argumentumunkba beírjuk a kimenetet.
        </para>
        <programlisting language="java"><![CDATA[
            class BinTree{
            private final Node root;
            private Node current;
            private int treeHeight;
            private int melyseg, maxMelyseg, atlagosszeg, atlagdb;
            private double atlag,szorasosszeg, szoras;
            
            
            public BinTree(){
                root = new Node('/');
                current = root;
                treeHeight = -1;
            }

            public Node getRoot(){
                return root;
            }
            public void setCurrent(Node rhs){
                current = rhs;
            }
            
            public void write(char b){
                if(b == '0'){
                    if(current.getLeft() == null){
                        current.setLeft(new Node('0'));
                        setCurrent(root);
                    }
                    else{
                        setCurrent(current.getLeft());
                    }
                }
                
                if(b == '1'){
                    if(current.getRight() == null){
                        current.setRight(new Node('1'));
                        setCurrent(root);
                    }
                    else{
                        setCurrent(current.getRight());
                    }
                }	
            }
            
            
            public void writeOut(Node n, PrintWriter pw){
                if(n != null)
                {
                    ++treeHeight;
                    
                    writeOut(n.getLeft(),pw);
                    
                    for(int i = 0; i < treeHeight; i++){
                        pw.print('-');
                    }
                    
                    pw.println(n.getNode() + " (" + treeHeight + ")");
                    
                    writeOut(n.getRight(),pw);
                    --treeHeight;
                }
            }	
        }
          ]]>
        </programlisting>
        <figure>
             <title>Binfa Servlet indexpage</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/servlet.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure>
        <programlisting language="html"><![CDATA[
        <!DOCTYPE html>

        <html>
            <body>
                <h2>BinfaInput</h2>
        <form action="nemesis" method="get">
            <input type="text" name="text"/>
            <input type="submit" value="Submit"/>
        </form>
            </body>
        </html>

          ]]>
        </programlisting>
        <figure>
             <title>Binfa Servlet after run</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/servlet2.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            A binfa szervlet megvalósításához a netbeans ide-t használtam. A servlethez a binfa <classname>main</classname> osztályát kellett áthelyezni. Ehhez az osztálynak örökölnie kellett a HttpServlet tulajdonságait és Override-olni a doGet függvényt, amelynek a két paramétere a request és a response, na meg persze importolni a servlet könyvtárakat. A request el kapom meg az értéket a címsorból és a response-val tudok majd válaszolni tehát kiiratni majd.
        </para>
        <programlisting language="java"><![CDATA[
            @WebServlet(name = "nemesis", urlPatterns = {"/nemesis"})
            public class nemesis extends HttpServlet {

            @Override
            public void doGet(HttpServletRequest request, HttpServletResponse response)
          ]]>
        </programlisting>
        <para>
            Lényegében a böngésző címsorából adom meg a bemenetet a binfának. A request.getParameter el és ennek a zárójelben megadott paramétere hivatkozik az indexben megadott inputra.Tehát a textboxra.
        </para>
        <programlisting language="java"><![CDATA[
        response.setContentType("text/html");    
    
        String bemenet = request.getParameter("text");
          ]]>
        </programlisting>
    <para>
            És a kimenetnél történt változásnál a setContentType-nál állítjuk be, hogy milyen típúsú választ akarunk küldeni a kliensnek itt most jelenleg text/html.Majd a response.getWriterrel küldjük át a kliensnek a választ és a out.println-al építjük fel a html lapot, amit a kliens fog megkapni.
            A szerverhez Tomcatet használtam. Amit az IDE-ben nagyon könnyű behúzni a projektbe. De ha maven projektet csinálunk akkor a pom.xml-ben is tudjuk pluginként behúzni.
        </para>
        <programlisting language="xml"><![CDATA[
            <plugin>
                <groupId>org.apache.tomcat.maven</groupId>
                <artifactId>tomcat7-maven-plugin</artifactId>
                <version>2.2</version>
                <configuration>
                    <path>/binfa</path>
                </configuration>
            </plugin>
            A futtatás ilyenkor mvn clean package tomcat7:run- al történik.
          ]]>
        </programlisting>
    </section>        
    <section>
        <title>"Gagyi"</title>
        <para>
            Az ismert formális 2 tesztkérdéstípusra adj a szokásosnál
            (miszerint x, t az egyik esetben az objektum által hordozott érték, a másikban meg az objektum
            referenciája) „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x, t
            értékekkel meg nem! A példát építsd a JDK Integer.java forrására 3 , hogy a 128-nál inkluzív objektum
            példányokat poolozza!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Gagyi">https://github.com/Savitar97/Prog2/tree/master/Gagyi</link>                
        </para>
        <programlisting language="java"><![CDATA[
        90:   // This caches some Integer values, and is used by boxing
        91:   // conversions via valueOf().  We must cache at least -128..127;
        92:   // these constants control how much we actually cache.
        93:   private static final int MIN_CACHE = -128;
        94:   private static final int MAX_CACHE = 127;
        95:   private static Integer[] intCache = new Integer[MAX_CACHE - MIN_CACHE + 1];
        305:   public static Integer valueOf(int val)
        306:   {
        307:     if (val < MIN_CACHE || val > MAX_CACHE)
        308:       return new Integer(val);
        309:     synchronized (intCache)
        310:       {
        311:     if (intCache[val - MIN_CACHE] == null)
        312:       intCache[val - MIN_CACHE] = new Integer(val);
        313:     return intCache[val - MIN_CACHE];
        314:       }
        315:   }

        private static class IntegerCache {
        private IntegerCache(){}

        static final Integer cache[] = new Integer[-(-128) + 127 + 1];

        static {
            for(int i = 0; i < cache.length; i++)
                cache[i] = new Integer(i - 128);
        }
        }

        public static Integer valueOf(int i) {
        final int offset = 128;
        if (i >= -128 && i <= 127) { // must cache
            return IntegerCache.cache[i + offset];
        }
        return new Integer(i);
        }
        jdk/src/share/classes/java/lang
          ]]>
        </programlisting> 
        <para>
            Mivel a cache-nek a mérete -128 és 127 közé esik,így ha az objektumunk ebből a tartományból vesz fel értéket akkor az <classname>Integer</classname> osztály valueof(int val) függvénye fog lefutni,tehát a cache-en belül poolozza az Integer objektumokat(azaz nem hoz létre új objektumot, hanem ugyan azt használja fel, referenciára hivatkozik).
            Tehát az előltesztelős ciklusunknak a feltétele egyből teljesül és kilép. Viszont, ha ezen a tartományon kívül veszünk fel értéket akkor a valueof új Integer objektumot hoz létre, ezért false eredményt kapunk és végtelen ciklusunk lesz.
            Ez egy memória megtakarító és teljesítmény növelő funkció, amit autoboxingnak neveznek. Tehát a poolozás miatt a két objektumnak ugyan az lesz a referenciája,ezt megkerülhetjük ha new-al hozzuk létre.
        </para>
        <programlisting language="java"><![CDATA[
        Integer x = 128;
        Integer t = 128;
        while (x <= t && x >= t && t != x)
            { System.out.println("Gagyi");  }
        System.out.println("Gagyi vége"); 
            
            ]]>
        </programlisting>
        <programlisting language="java"><![CDATA[
        De akkor is végtelen ciklust kapunk ha a new kulcsszóval hozzuk létre az objektumokat mert akkor nem a valueof true ága fut végig.
        Integer x = new Integer(127);
        Integer t = new Integer(127);
        while (x <= t && x >= t && t != x)
            { System.out.println("Gagyi");  }
        System.out.println("Gagyi vége"); 
          ]]>
        </programlisting>
        <figure>
             <title>Végtelen ciklus 128-nál</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Gagyi.png" scale="200"/>
                </imageobject>
        </mediaobject>
        </figure>
        <programlisting language="java"><![CDATA[
        Integer x = 127;
        Integer t = 127;
        while (x <= t && x >= t && t != x)
            { System.out.println("Gagyi");  }
        System.out.println("Gagyi vége"); 
          ]]>
        </programlisting>
        <figure>
             <title>Leállás 127-nél</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Gagyi1.png" scale="200"/>
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            Itt szintén az osztály definícióit használtuk. Javaba ugyebár minden is objektum. Emellett a beépített Integer osztályjal ismerkedtünk.
        </para>
    </section>
    <section>
        <title>Yoda</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Yoda">https://github.com/Savitar97/Prog2/tree/master/Yoda</link>               
        </para>
        <para>
            A Yoda condition a nevét a Starwars karakteréről kapta, aki elég egyedi angolnyelvi szintaxisával is kitűnt a sorozatból ez az egyedi szintaxis az volt, hogy az alany-&gt;ige-&gt;tárgyat felcserélte tárgy-&gt;alany-&gt;igére.
            A Yoda condition lényege az, hogy egy ekvivalenciánál a konstanst nem a megszokott jobb oldalára írjuk az ekvivalenciának, hanem a bal oldalra.
            Ezt általában stringeknél használjuk,de nem feltétlenül. Tehát nem az objektumunkat hasonlítsuk össze a stringgel, hanem a stringet az objektumunkkal.
            Az előnye a feltétel betartásának az, hogy elkerüljük a NullPointerExceptions-t.Viszont a hátránya az, hogy a kód olvasását nehezebbé teszi.
            Ugyanis ilyenkor jobbról balra érdemesebb olvasnunk a feltételeket. Viszont ezen kívül még, megkímélhetjük magunkat az == helyett = operátor hibától. A yoda conditiont még az equal el szoktuk használni.
            
        </para>
        <programlisting language="java"><![CDATA[
            String rand= null;
		    if(rand.equals("foo")){
			System.out.println(rand);
		}

          ]]>
        </programlisting>
        <figure>
             <title>NullPointExeption</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Yoda.png" scale="200"/>
                </imageobject>
        </mediaobject>
        </figure>
        
        <figure>
             <title>Yoda Condition nem kap errort</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Yoda2.png" scale="200"/>
                </imageobject>
        </mediaobject>
        </figure>
        <programlisting language="java"><![CDATA[
            String rand= null;
		    if("foo".equals(rand)){
			System.out.println(rand);
		}

          ]]>
        </programlisting>
    </section>
    <section>
        <title>Kódolás from scratch</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Scratch">https://github.com/Savitar97/Prog2/tree/master/Scratch</link>               
        </para>
        <para>
            A BBP algoritmus a 20. század egyik legfontosabb felfedezése volt. Segítségével kiszámolhatjuk a pi-nek a d+1-dik jegyének a hexadecimális értéket úgy, hogy a megelőző jegyek nem kell kiszámolni.
            Kezdetben létrehozunk egy osztályt a <classname>PiBBP</classname> algoritmusnak. A BBP algoritmus alapján:
        </para>
        <programlisting language="java"><![CDATA[
        {16^d Pi} = {4*{16^d S1} - 2*{16^d S4} - {16^d S5} - {16^d S6}}
          ]]>
        </programlisting>
        <para>
            Természetesen a {}- a törtrészét jelöli. Tehát  a konstruktorunknak van egy paramétere a d. Majd létrehozzuk a változókat. Kezdetben a d16pi-t.Kezdőértékül a 0.0d-vel jelöljük, hogy double lesz az értéke. Az S1,S4,S5,S6-nak metódussal(függvénnyel) számoljuk az értékét.
            d16Pi-értékét a fenti képlet alapján számoljuk. Majd a kiszámított értékből kivonjuk a lefelé kerekített értékét a d16Pi-nek ezzel elérve, hogy 0 és 1 közé essen d16Pi értéke. A végeredmény építéséhez a StringBuffert használjuk. A hexajegyek tömböt használjuk, hogy a 10 feletetti értéket helyettesítsük.
            Mivel a 16-os számrendszerben a 10-es számjegy az A például és egészen F-ig megy. Majd létrehozunk egy while ciklust, ami addig megy ameddig a d16pi értéke nem lesz 0-val egyenlő.Itt elvégzünk egy típuskényszerítést és egy lefelé kerekítést a d16Pi-n és letároljuk a jegy-be.Ugyebár ha a jegy 10-nél kisebb nem kell vele semmit csinálnunk.
            Viszont ha 10 vagy ettől nagyobb, akkor a visszaadott értéket a hexajegyekből választjuk. Ugyebár ha 10 et kapunk például eredményül akkor abból kivonva 10-et megkapjuk a 0. indexű elemet a tömbben. Ezt használjuk itt ki.
            Majd a végén a toString metódussal létrehozzuk a stringet, amit mi hoztunk létre a biztonság kedvéért, pedig minden osztálynak van toString metódusa javaban.
        </para>
        <programlisting language="java"><![CDATA[
        public PiBBP(int d) {
        
        double d16Pi = 0.0d;
        
        double d16S1t = d16Sj(d, 1);
        double d16S4t = d16Sj(d, 4);
        double d16S5t = d16Sj(d, 5);
        double d16S6t = d16Sj(d, 6);
        
        d16Pi = 4.0d*d16S1t - 2.0d*d16S4t - d16S5t - d16S6t;
        
        d16Pi = d16Pi - StrictMath.floor(d16Pi);
        
        StringBuffer sb = new StringBuffer();
        
        Character hexaJegyek[] = {'A', 'B', 'C', 'D', 'E', 'F'};
        
        while(d16Pi != 0.0d) {
            
            int jegy = (int)StrictMath.floor(16.0d*d16Pi);
            System.out.println(jegy);
            if(jegy<10)
                sb.append(jegy);
            else
                sb.append(hexaJegyek[jegy-10]);
            
            d16Pi = (16.0d*d16Pi) - StrictMath.floor(16.0d*d16Pi);
        }
        
        d16PiHexaJegyek = sb.toString();
        System.out.println("S1:"+d16S1t+" "+"S2:"+d16S4t+" "+"S3:"+d16S5t+" "+"S4:"+d16S6t);
    }
          ]]>
        </programlisting>
        <para>
            Mint az elején már mondtam az S1,S4,S5,S6-ot függvénnyel számoljuk ez a következő függvény,2 argumentuma van, a d szám ismét azaz amit megadunk és a j, ami (1,4,5,6):
        </para>
        <programlisting language="java"><![CDATA[
            public double d16Sj(int d, int j) {
        
            double d16Sj = 0.0d;
            
            for(int k=0; k<=d; ++k)
                d16Sj += (double)n16modk(d-k, 8*k + j) / (double)(8*k + j);
                return d16Sj - StrictMath.floor(d16Sj);
            }
          ]]>
        </programlisting>
        <para>
            A d16Sj-nél még egy függvényt használunk,amely szintén 2 paraméteres ezzel számoljuk a 16^n mod k-t.Ugyebár n a kitevő és k a modulus.
        </para>
        <programlisting language="java"><![CDATA[
            public long n16modk(int n, int k) {
        
                int t = 1;
                while(t <= n)
                    t *= 2;
                
                long r = 1;
                
                while(true) {
                    
                    if(n >= t) {
                        r = (16*r) % k;
                        n = n - t;
                    }
                    
                    t = t/2;
                    
                    if(t < 1)
                        break;
                    
                    r = (r*r) % k;
                    
                }
                
                return r;
            }
          ]]>
        </programlisting>
        <para>
            A végeredmény nem lett teljesen jó sajnos.6C65E52CB459350050E4BB1 helyett 6C65E5308 jött ki. A d=1000001 értéknél.
            Az elméletből itt szintén az osztályhasználatot figyelhetjük meg.
        </para>
        <figure>
             <title>Scratch</title>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Scratch.png" scale="200"/>
                </imageobject>
        </mediaobject>
        </figure>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Liskov helyettesítés sértése</title>
        <para>
Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a
megoldásra: jobb OO tervezés.
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (93-99 fólia)
(számos példa szerepel az elv megsértésére az UDPROG repóban, lásd pl. source/binom/Batfai-
Barki/madarak/)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Liskov">https://github.com/Savitar97/Prog2/tree/master/Liskov</link>              
        </para>
        <para>
            A liskov elv arról szól,hogy minden osztályt helyettesíthessen a gyermek osztálya anélkül,
            hogy a program működése megváltozna. Legyen S T-nek egy leszármazottja, ekkor minden T típúsú
            objektum legyen helyettesíthető S objektumokkal. Jelen esetünkben vizsgáljunk meg egy példát:
        </para>
        <programlisting language="java"><![CDATA[
            class Madar{
                void repul(){
                   System.out.println("I belive I can fly");
               }
           }
           
           class Sas extends Madar{
               @Override
               void repul(){
                   System.out.println("A sas repül");
               }
           }
           
           class Pingvin extends Madar{
           
           }
           
           class Liskov{
               public static void main(String[] args) {
                   Madar madar=new Madar();
                   madar.repul();
                   madar=new Sas();
                   madar.repul();
                   madar=new Pingvin();
                   madar.repul();
               }
           }
            ]]>
          </programlisting>
          <figure>
            <title>Liskovsert</title>
        <mediaobject>
               <imageobject>
                   <imagedata fileref="img/Liskovsert.png" scale="200"/>
               </imageobject>
       </mediaobject>
       </figure>
          <para>
              Jelen esetünkben a T az a madár és az S-ek a pingvin és a sas.Mint látható a liskov elv itt sérül ugyanis a program szerint a pingvin képes repülni. A probléma onnan adódik, hogy azt tettük fel, hogy minden madár tud repülni.
              Ezért tévesen a repül metódust a madár osztályba írtuk.Tehát az alap tervezéssel volt a probléma. A megoldás az, ha csinálunk egy külön interface-t, amely a repülés tulajdonságot jelenti,bár ekkor a madár osztályt is interface-ve kell alakítanunk, mivel a többszörös öröklődés nem lehetséges javaban.
              Hasonlót csak az interfacekkel érünk el.
          </para>
          <programlisting language="java"><![CDATA[
            interface Madar{
	 
            }
            
            interface RepuloMadar {
                abstract void repul();
            }
            class Sas  implements RepuloMadar{
                public void repul(){
                    System.out.println("A sas repül");
                }
            }
            
            class Pingvin implements Madar{
            
            }
            
            class Liskovjo{
                public static void main(String[] args) {
                    Sas sas=new Sas();
                    Pingvin pingvin=new Pingvin();
                    sas.repul();
                    pingvin.repul();//hibát fog kiirni mivel itt már nem tud repülni a pingvin
                }
            }
            ]]>
          </programlisting>
        <figure>
            <title>Liskovjo</title>
        <mediaobject>
               <imageobject>
                   <imagedata fileref="img/Liskovjo.png" scale="200"/>
               </imageobject>
       </mediaobject>
       </figure>
          <para>
              A kódokról röviden. A különbség a C++-os és a Javas megvalósításban: Az osztályok létrehozása ugyan úgy a class kulcsszóval történik.
              Amit ezután észrevehetünk, hogy a C++-ban a láthatósági szintek külön részeket alkotnak pl.: public:, míg javaban minden egyes metódus vagy változó előtt jelezve találjuk a láthatóságát.
              Emellett a futás közbeni polimorfizmusra is találunk példát(amelynek része a metódus túlterhelés) még pedig a virtual kulcsszóval jelzett metódust a C++-ban és a Java-s kódban is, amikor Override-ot látunk. Szintúgy megjelenik az öröklődés mindkét esetben.
              Javaban ez az extends kulcsszóval történik míg C++-ban a class gyerekosztály:szülőosztály formában történik. 
          </para>
          <para>
              Ebben a részben az öröklődés témakörét boncolgattuk elméleten emellett az interfaceket. Ezek ebben a feladatban is megjelennek.
              Ugyebár az osztályok végülis a hasonló tulajdonságú és funkciókkal rendelkező objektumok gyűjteménye. Javaban nem létezik a többszörös öröklődés fogalma.
              De valami hasonlót hozhatunk létre az interfacek használatával, tehát ha vannak osztályaink hasonló funkciókkal és tulajdonságokkal például, itt például a sas és a pingvin.
              Mind a kettő madár. Viszont a pingvin nem tud repülni. De a legtöbb madár tud repülni ezért ezt egy interface-el tudjuk megoldani. Hogy a repülés tulajdonságot kitesszük egy interfacebe itt RepülőMadárként.
              És ha az a madár tud repülni akkor implementálja ezt az interface-t.
          </para>
    </section>        

    <section>
        <title>Szülő-gyerek</title>
        <para>
            Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
keresztül csak az ős üzenetei küldhetőek!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (98. fólia)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Szulogyerek">https://github.com/Savitar97/Prog2/tree/master/Szulogyerek</link>              
        </para>
        <para>
            Ebben a feladatunkban megjelenik az öröklődés mint fontos tényező. Az öröklődésnél ugyebár a gyermek hozzáfér a szülő osztály
            definiált metódusaihoz, de fordítva ez nem igaz. Tekintsük meg az alábbi példát:
        </para>
        <programlisting language="java"><![CDATA[
            class Szulo{
                void message(){
                    System.out.println("Szülő üzenete.");
                }
            }
            
            class Pulya extends Szulo{
                @Override
                void message(){
                    System.out.println("Szülő üzenet felülír");
                }
                void message2(){
                    System.out.println("Gyerek üzenete");
                }
            }
            
            class Szulogyerek{
                public static void main(String[] args) {
                    Szulo szulo = new Szulo();
                    szulo.message();
                    szulo=new Pulya();
                    szulo.message();
                    //Itt látható, hogy a szülő nem tudja meghívni a gyerek metódusát.Tehát az ősön keresztül, csak az ős üzenetei küldhetők.A gyermeké nem.
                    //szulo.message2();
                    Pulya gyerek=new Pulya();
                    gyerek.message();
                    gyerek.message2();
            
                }
            }
            ]]>
          </programlisting>
          <figure>
            <title>Szulogyerek</title>
        <mediaobject>
               <imageobject>
                   <imagedata fileref="img/Szulogyerek.png" scale="200"/>
               </imageobject>
       </mediaobject>
       </figure>
       <para>
           Ha a kikommentelt részt kiszedjük akkor errort kapunk.
       </para>
       <para>
           Na tehát van egy <classname>Szulo</classname> osztályunk, és egy <classname>Pulya</classname> osztályunk, amelyet a szülőből származtatunk.A származtatást a extends jelöli.
           A szülőnek van egy metódusa a message. A gyerek ezt override-olja(polimorfizmus) és ezen kívül van még egy message2 metódusa. Majd jön a példányosítás. Elsőnek is példányosítunk
           egy szülő típúsú objektumot ez a következő képpen zajlik Osztálynév amit követ az objektum neve ezt egy =-jel követi, aztán jön a new szó a példányosításhoz végül pedig a konstruktorja az osztálynak, amiben lehet inicializáció. Majd kiirassuk vele a metódusát.
           Majd a szülőn keresztül példányosítunk egy pulya osztályt. És meghívjuk a message-t. Mi történik? Az Overrideolt metódus fut le a szülő metódusa helyett.
       </para>
       <para>
           Most próbáljuk meg meghívni a message2-t. Azt várnánk, hogy lefog futni a függvény mivel az Overrideolt függvény lefut.De ez nem következik be, hanem errort kapunk.
           Mi lehet a probléma? Az, hogy a message-t a <classname>Pulya</classname> a szülőtől örökölte tehát a szülőn keresztül is képes elérni. Míg a message2-t a szülőosztály nem ismeri, mivel nincs a hatókörében.
           Viszont, ha példányosítunk egy Pulya osztálytípúsú objektumot, akkor az már ismerni fogja a message2-t. Ezen kívül egy kis plusz megjegyzés, ha leszármaztatunk egy osztályt és nem hozunk létre saját konstruktort akkor a szülő osztály paraméter nélküli konstruktorát fogja örökölni.
           Ezen kívül C++-ban támogatott a többszörös öröklődés tehát ott minden szülő osztály paraméter nélküli konstruktorát átveszi a gyermek.
       </para>
       <figure>
        <title>Szulogyerek</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/CPPSzulogyerek.png" scale="200"/>
                </imageobject>
            </mediaobject>
        </figure>
    <para>Itt az elméletből szintén az öröklődés témáját tárgyaltuk és annak menetének szabályait.Amely már belecsúszik a láthatósági szintekbe is.</para>
    </section>        
    <section>
        <title>Anti OO</title>
        <para>
            A BBP algoritmussal 4 a Pi hexadecimális kifejtésének a 0. pozíciótól számított 10^6, 10^7, 10^8 darab
jegyét határozzuk meg C, C++, Java és C# nyelveken és vessük össze a futási időket!

        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html#id561066">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html#id561066</link>
            <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/AntiOO">https://github.com/Savitar97/Prog2/tree/master/AntiOO</link>       
        </para>
        <para>
        A következő táblázat tartalmazza a mérési eredményeinket:
        </para>
        <table border="1">
                <caption>Eredmények</caption>
                <thead align="left" valign="middle">
                   <tr>
                       <td>0xJegy</td>
                       <td>C[sec]</td>
                       <td>C++[sec]</td>
                       <td>C#[sec]</td>
                       <td>Java[sec]</td>
                   </tr>
                 </thead>
                <tbody align="left" valign="middle">
                   <tr>
                     <td>10<superscript>6</superscript></td>
                     <td>1.879098</td>
                     <td>1.901872</td>
                     <td>2,064295</td>
                     <td>1.69</td>
                     </tr>
                     <tr>
                     <td>10<superscript>7</superscript></td>
                     <td>21.816081</td>
                     <td>21.985074</td>
                     <td>23,2984408</td>
                     <td>19.672</td>
                     </tr>
                     <tr>
                     <td>10<superscript>8</superscript></td>
                     <td>250.840815</td>
                     <td>251.886862</td>
                     <td>264,5961322</td>
                     <td>224.895</td>
                     </tr>
                </tbody>
            </table>
    <para>
        A BBP algoritmust az előző fejezetben már létrehoztuk és kitárgyaltuk. A programkódban viszont változások keletkeztek.
        Ennek az oka, hogy a C nem objektum orientált programozási nyelv.Míg a másik 3 igen.Bár java és C#-nál teljesen nem tudjuk eltüntetni az
        objektum orientáltságot. Az eredmények megszületéséhez ugyebár, mindig a for ciklusban lévő d-t kell megváltoztatnunk.
    </para>
    <programlisting language="java"><![CDATA[
        for(int d=100000000; d<100000001; ++d) {
            
            d16Pi = 0.0d;
            
            d16S1t = d16Sj(d, 1);
            d16S4t = d16Sj(d, 4);
            d16S5t = d16Sj(d, 5);
            d16S6t = d16Sj(d, 6);
            
            d16Pi = 4.0d*d16S1t - 2.0d*d16S4t - d16S5t - d16S6t;
            
            d16Pi = d16Pi - Math.floor(d16Pi);
            
            jegy = (int)Math.floor(16.0d*d16Pi);
            
        }
        ]]>
      </programlisting>
    <para>
        A C#-os kód futtatásához a visual studio code-ot használtam. Ezen kívül szükséges volt még a 
        <command>sudo apt-get install dotnet-sdk-3.0</command> telepítése. Ezután Visual Studio Code terminálba <command>dotnet new console</command>
        majd <command>dotnet build</command> végül <command>run</command>. A build abba a mappába, amelyikben éppen vagyunk létrehoz egy új c# projektet.
        A projekt alapból egy helloworld program lesz.
    </para>
    <para>
        De visszakanyarodva a mérési eredményekhez. A java toronymagasan az első. Az interpreter úgy tűnik gyorsabb mint a compiler.
        Második helyen végzett a C és minimálisan lemaradva a C++. Utolsó helyen végzett a C# ez lehetséges kompatibilitási okokból is.(Windowson futtatva valószínüleg más eredményt produkált volna)
        A gép konfigja, amivel a teszt készült: A processzor egy i5-7200U, amely egy 2 mag 4 szálas processzor 2.5GHz-es alapórajellel és 3.1GHz Turbo Boost-al.
        A VGA egy Geforce 940MX 2gb ddr5 ös dedikált videó kártya. Ezen kívül 4 gb ddr4 es 2133MHz es RAM-mal van felszerelve a gép.
    </para>
    </section>
    <section>
        <title>Hello Android!</title>
        <para>
            Élesszük fel az SMNIST for Humans projektet!
https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main
Apró módosításokat eszközölj benne, pl. színvilág.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/smnist-master/forHumans/androidhuman">https://github.com/Savitar97/Prog2/tree/master/smnist-master/forHumans/androidhuman</link>               
        </para>
        <caution>
            <title>
                Tutorált
            </title>
            <para>Ebben a feladatban tutorált Racs Tamás.</para>
        </caution>
        <para>
            A feladatunk, hogy megváltoztassuk például a színvilágát az smnist android alkalmazásnak. Ehez először lekellett szednünk az android stúdiót. Én az ubuntu szoftverekből kerestem ki és telepítettem.
        </para>
        <para>
            Az android stúdió telepítése egyszerűen ment. A program felélesztése már kevésbé. Kezdetben importálni próbáltam.
            Hát ez nem jött össze sajnos, ugyanis a gradle fájlok és még rengeteg dolog hiányzott.
        </para>
        <para>
            Ezután új projekttel próbálkoztam kezdetben nagyon nem akart sikerülni. De végül csak feléledt.Ugyebár létrehoztam az üres projektet majd a kellő helyre bemásoltam a fileokat.
            De ettől még mindig hibát írt ki. Elsőnek is átkellett írni a package neveket a sajátomra. De ezután is hibába ütköztem.
            Két megoldást is találtam a hiba elhárítására kezdetben az volt a problémája, hogy a <command>android.support.v7.app.AppCompatActivity</command>
            nem találta. Erre a megoldás az volt, hogy a build.gradle-ben, a compile sdk verziót csökkentettem 27-re. A másikban Racs Tamás segített.
        </para>
        <programlisting language="java"><![CDATA[
            import androidx.appcompat.app.AppCompatActivity;
            public class SMNISTE3Activity extends AppCompatActivity 
            ]]>
          </programlisting>
          <para>
              Az SMNISTE3Activity.java-ban kellet a fent lévő módosításokat elvégezni. Ezen kívül beleütköztem abba a hibába is, hogy a program nem találta az R könyvtárát.
          </para>
          <programlisting language="java"><![CDATA[
            import com.example.androidhuman.R;
            ]]>
          </programlisting>
          <para>
              Ekkor egyszerűen importáltuk az R-t. A com.example.androidhuman helyére az aktuális package-et kell írni.
          </para>
          <para>
              De még ígysem működött. Ugyanis valamiért nem látta a program az SMNISTE3Activity osztályt. Ez azért volt mert egy helyen relatívan volt megadva az elérési út, ezt abszolútra javítva már indult is a program.
              Azaz még teljesen nem mert a kompatibilitási hibákat javítani kellett az android 8.1 előtti verziókhoz.
          </para>
          <para>
              Na de térjünk vissza a kódhoz. Ugyebár a színvilágot akarjuk módosítani. Ezt úgy tehetjük meg, hogy a SurfaceViewben találunk egy bg color nevű tömböt amelynek két eleme van.
              Ezek lesznek a villogó háttér színei RGB-ben megadva.
          </para>
          <para>
              A többi színt a cinit metódusban találjuk. A textpaint a körökben lévő szöveg színét módosítja. Az msgpaint a lent lévő értékeket jelöli, az elért teljesítményt leíró szöveg színét változtatja.
              A dotpaint logikusan a pont színét változtatja meg. A borderpaint a keret színét változtatja. Végül a fillPaint a pont és szöveg mögötti hátteret tölti ki az adott színnel.A módosítás eredménye lent látható a képen.
          </para>
          <para>
              Ha az elején felugró licence-et akarjuk módosítani akkor azt az Activityben tehetjük meg. Az android.alertdialog.builder-nél.
          </para>
        <figure>
                <title>Smnist</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/Android.png" scale="100"/>
                        </imageobject>
                    </mediaobject>
        </figure>
        <para>A feladat az elmélethez a metódus túlterhelésben,öröklődésben nyilvánul meg.</para>
    </section>
    <section>
        <title>Ciklomatikus komplexitás</title>
        <para>
            Számoljuk ki valamelyik programunk függvényeinek ciklomatikus komplexitását! Lásd a fogalom
tekintetében a https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_2.pdf (77-79
fóliát)!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Komplexit%C3%A1s">https://github.com/Savitar97/Prog2/tree/master/Komplexit%C3%A1s</link>                
        </para>
        <para>
            A ciklomatikus komplexitás a program összetettségét vizsgálja. Megszálmolja a programban az metódusok, feltételes elágazások,
            ciklusok,try catch-ek, a logikai operátorok, a ?: operátorok és a ?. operátorok számát és ez alapján kalkulálja ki az értéket, amelyet McCabe értéknek is neveznek. A komplexitás számolásához a gráf
            elméletet használják fel. A ciklomatikus komplexitás az:
            M = E − N + 2P képlettel számolható ki, ahol M a McCabe érték, amely egyenlő az élek-csomópontok + az összefüggő komponensek száma.
        </para>
        <para>
            A ciklomatikus komplexitás kiszámításához egy maven plugint használtam a már megírt binfa servleten.
        </para>
        <programlisting language="java"><![CDATA[
            <plugin>
                    <groupId>org.codehaus.mojo</groupId>
                    <artifactId>javancss-maven-plugin</artifactId>
                    <version>2.1</version>
                </plugin>
            ]]>
          </programlisting>
        <para>
            Ha a maven pom.xml ünkbe a pluginok közé beírjuk az alábbi kódcsipetet, majd a <command>mvn site</command> és <command>mvn javancss:report</command> futtatásával a projekt könyvtárában a
            target/site mappában megtaláljuk a plugin által kiszámolt komplexitást és egyéb információkat, amelyet egy html oldal formájában tekinthetünk meg. 
        </para>
        <figure>
                <title>Ciklomatikus Komplexitás</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/CykloComplex.png" scale="35"/>
                        </imageobject>
                    </mediaobject>
        </figure>
        <figure>
                <title>Maven</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/maven.png" scale="200"/>
                        </imageobject>
                    </mediaobject>
        </figure>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>

	<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Reverse engineering UML osztálydiagram</title>
        <para>
			UML osztálydiagram rajzolása az első védési C++ programhoz. Az osztálydiagramot a forrásokból
			generáljuk (pl. Argo UML, Umbrello, Eclipse UML) Mutassunk rá a kompozíció és aggregáció
			kapcsolatára a forráskódban és a diagramon, lásd még: https://youtu.be/Td_nlERlEOs.
			https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_6.pdf (28-32 fólia)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Ez a fejezet a diagramm készítésről fog szólni. Minden feladatban érintjük az elméletben felsoroltakat.
        </para>
        <para>
         A diagrammot ugyebár a binfás védési programunkról csináltuk, amelyet még prog1-en használtunk.
        </para>
        
        <para>
        	Asszociáció: Egyetlen vonallal jelöljük és középre írjuk az asszociáció nevét.Példa: A foglalás és a szállás. A foglalás lefoglalja a szállást. Tehát itt az asszociáció neve a lefoglal. És kis nyíl fejjel jelöljük az irányt. Ezen kívül szerepneveket is megadhatunk, hogy hogyan vesz részt a kapcsolatban a két fél. Példa egy cégnél a személy munkavállalóként vesz részt a kapcsoaltban, míg a cég munkáltatóként. Itt is ugyan úgy jelölhetünk multiplicitást. Például egy cég több alkalmazottat is foglalkoztat általában mivel van egy kötelező létszám amit megkell haladnia. És lehet olyan, hogy azzal nem muszály foglalkoznunk a modellünkben, hogy a munkavállalónknak van -e több munkahelye.
        	Az asszociációnak van két speciális fajtája a kompozíció és az aggregáció.
        	Aggregáció:az aggregáció jele az üres rombusz. Az aggregáció tartalmazást jelöl. Tehát a rombuszt a tartalmazó oldalára tesszük. Például egy vállalatnak lehet egy vagy több részlege. Sokan semmitmondónak tekintik és nem ajánlják a használatát.
       		Kompozíció: Jelölése fekete tömött rombusz.Kompozíció esetén két lényeges fogalom van. Az első az, hogy a tartalmazott objektum pontosan egy tartalmazó objektumhoz tartozik. Vagyis egy tartalmazott objektumot nem tartalmazhat több objektum, tehát nincs megosztás. A másik pedig az, hogy a tartalmazott és a tartalmazó együtt jön létre és együtt is szűnik meg. A kompozíciót ugyan úgy implementáljuk, mint az asszociációt, csak ilyenkor a destruktorban megkell írnunk a felszabadító kódot és a konstruktorban a létrehozó kódrészeletet.
        </para>
        <para>
            Tehát a közös közöttük, hogy mindekettő az asszociáció egy speciális esete és, hogy mindkettő tartalmazást jelöl. Az ábránkon két kompozíciót látunk. Ez azt jelenti, hogy a tartalmazott önmagában nem tud létezni, csak valaminek a részeként. Tehát a csomópont csak a binfa részeként létezhet. És mivel a nyíl átvan húzva, így ez nem navigáló asszociáció.Ez azt jelenti, hogy a binfából mindig képezhető csomópont, de csomópontból nem állítható vissza a binfa.
        </para>
        <figure>
            <title>UML Vedes</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/UMLVedes.png" scale="200"/>
                    </imageobject>
                </mediaobject>
        </figure>
    </section>        

    <section>
        <title>Forward engineering UML osztálydiagram</title>
        <para>
           UML-ben tervezzünk osztályokat és generáljunk belőle forrást! 
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/uml-regenerate">https://github.com/Savitar97/Prog2/tree/master/uml-regenerate</link>              
        </para>
        <para>
            Az általam elkészített egyszerű osztály:
        </para>
        <figure>
            <title>Példa</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/pelda.png" scale="200"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            A forward engineering az, amikor nem a kész kódból generálunk UML diagrammot hanem fordítva. Tehát először elkészítjük a diagrammot majd képesek vagyunk belőle kódot generálni.
            Én a Visual Paradigmot használtam ehhez.
        </para>
        <figure>
            <title>Generate java</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/generatejava.png" scale="50"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            A generálás könnyen megy amint a fenti kép is mutatja. A példában csak öröklődések szerepelnek. Viszont ha az egyik osztályból felhasználnék egy másik osztálybeli változót mondjuk akkor már asszociáció is lenne az osztályok között.
        </para>
        <figure>
            <title>Visszafordit</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/vegeredmeny.png" scale="50"/>
                    </imageobject>
                </mediaobject>
        </figure>
      <para>
          Láthatjuk,hogy elég jól visszagenerálta kivéve ugyebár a függvények törzsét. Habár azt honnan tudná vissza generálni? Ez csak egy vázlatból készített kód.
          De ezzel látható, hogy kiindulhatunk innen is, hogy UML-ben tervezzük meg az osztályt.
      </para>
    </section>        
    <section>
        <title>Egy esettan</title>
        <para>
            A BME-s C++ tankönyv 14. fejezetét (427-444 elmélet, 445-469 az esettan) dolgozzuk fel!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Az UML jelentősége, hogy jelenleg a szoftverfejlesztés egyetlen szabványos modellező nyelve.Főként az UML osztálydiagrammot használjuk. Mivel ez írja le az osztályokat, interfészeket és a típusukat. Ezenkívül ezek kapcsolatait.
            Az UML modellező nyelvben a diagrammok dobozokból, vonalakból, ikonokból és szöveges információkból állnak.
            Az UML diagrammok legfontosabb elemei az osztályok, amelyet téglalappal jelölünk. A téglalapot 3 különböző részre osztjuk. Az első rész az osztály nevét adja meg. A második részbe kerülnek a változók és ezek típúsai. Az utolsó és egyben 3. részben az osztály metódusait soroljuk fel. Az attribútumok szintaxisa a következőképpen alakul:elsőként a láthatóság, amelyet követ a változó neve. Ezt követően jön a típusa és multiplicitása, amelyet egy = jel követ. Az = jel után adjuk meg a változó értékét ha van. A legvégén pedig a tulajdonságait írhatjuk fel {}-be zárva. A tulajdonság lehet például az, hogy a változó csak olvasható. Ez jelenti azt,hogy konstans változóról van szó.Ha egy attribútum statikus akkor azt aláhúzással jelöljük.Ha egy taggfüggvény a konstans akkor a query tulajdonsággal adjuk meg.
        </para>
        <para>
        	Beszéljünk a láthatósági szintek jelöléséről:
        	A + jelenti a publicot, a - a private és a # a protected.Ezen kívül van még egy a package, amelyet a ~ jelöl.Ez C++-ban nincs, de javaban már igen.
        </para>
        <para>
        	Az virtuális vagy másnéven absztrakt műveleteket dőlt betűvel vagy {absztrakt} tulajdonsággal látjuk el.Ha minden művelet absztrakt vagy nincs attribútuma az osztálynak akkor azt az osztály névszakaszában az interface kulcsszóval jelöljük.
        </para>
        <para>
        	Kapcsolatok:
        </para>
        <para>
        	Asszociáció: Egyetlen vonallal jelöljük és középre írjuk az asszociáció nevét.Példa: A foglalás és a szállás. A foglalás lefoglalja a szállást. Tehát itt az asszociáció neve a lefoglal. És kis nyíl fejjel jelöljük az irányt. Ezen kívül szerepneveket is megadhatunk, hogy hogyan vesz részt a kapcsolatban a két fél. Példa egy cégnél a személy munkavállalóként vesz részt a kapcsoaltban, míg a cég munkáltatóként. Itt is ugyan úgy jelölhetünk multiplicitást. Például egy cég több alkalmazottat is foglalkoztat általában mivel van egy kötelező létszám amit megkell haladnia. És lehet olyan, hogy azzal nem muszály foglalkoznunk a modellünkben, hogy a munkavállalónknak van -e több munkahelye.
        	Az asszociációnak van két speciális fajtája a kompozíció és az aggregáció.
        </para>
        <para>
        	Aggregáció:az aggregáció jele az üres rombusz. Az aggregáció tartalmazást jelöl. Tehát a rombuszt a tartalmazó oldalára tesszük. Például egy vállalatnak lehet egy vagy több részlege. Sokan semmitmondónak tekintik és nem ajánlják a használatát.
       	</para>
       	<para>
       		Kompozíció: Jelölése fekete tömött rombusz.Kompozíció esetén két lényeges fogalom van. Az első az, hogy a tartalmazott objektum pontosan egy tartalmazó objektumhoz tartozik. Vagyis egy tartalmazott objektumot nem tartalmazhat több objektum, tehát nincs megosztás. A másik pedig az, hogy a tartalmazott és a tartalmazó együtt jön létre és együtt is szűnik meg. A kompozíciót ugyan úgy implementáljuk, mint az asszociációt, csak ilyenkor a destruktorban megkell írnunk a felszabadító kódot és a konstruktorban a létrehozó kódrészeletet.
        </para>
        <para>
            Esettanulmány:
        </para>
        <para>
            A feladat egy számítógépek és komponenseinek eladásával foglalkozó kereskedés számára, egy olyan alkalmazás elkészítése,
            amely nyilvántartja a kereskedésben lévő alkatrészeket és konfigurációkat. A programunknak tartalmaznia kell a termékek áruból való betöltését,
            ezek képernyőre történő listázását, valamint állományba való kiírását és ezen kívül az árak kialakítását. A rendszert úgy kell kiépítenünk, hogy a jövőbeli termékcsaládokat is támogassa. Ezt úgy érjük el, hogy megvalósítunk egy keretrendszert osztálykönyvtár formában.
            Az erre vonatkozó követelmények a következők:
        </para>  
        <simplelist>
            <member>A keretrendszernek ne kelljen kiadni a forráskódját és úgy lehessen felhasználni.</member>
            <member>Támogatnia kell az adatfolyamból való feltöltését és kiirását a termékeknek.</member>
            <member>A termékek fontos attribútumai:beszerzési ár,beszerzési dátum, név és típus.Az aktuális ár függvénnyel számolandó. </member>
            <member>Egy termék lehet elemi vagy összetett.Ha összetett akkor több termékből épül fel.</member>
        </simplelist>
        <para>
            A támogatott termékek a következők(zárójelben a tulajdonságaikkal):kijelzők,merevlemez,konfigurációk. A konfigok összetett termékek.
        </para>
        <para>
            A keretrendszer osztályait egy ProductInvertoryLib osztálykönyvtárba fogjuk össze. Kiterjesztése .lib.
            A termékek reprezentálása: létrehozunk egy Product osztályt, amelybe összegyűjtsük a termékek közös tulajdonságait, mivel majd minden terméket ebből származtatunk le.
            Amint a könyvben lévő ábrán is lássuk minden osztály asszociációval kapcsolódik a Product osztályhoz. A Product osztály a tartalmazó osztály tehát ide kerül az üres rombusz.
            A product osztályban 3 tagváltozó van ezek protected láthatósági szinttel rendelkeznek. Ezek a következők beszerzési dátum, beszerzési ár, név. Ezek más környezetben("külvilág") számára csak olvashatók. Ezt a get metódusok segítségével érjük el. Emellett vannak metódusaink a termék árának kiszámítására és a termék korának megállapítására.
            Viszont az ár kiszámítása termékfüggő, ezért ezt csak virtualként definiáljuk, amelyet a leszármaztatott osztályok majd felül definiálnak. Emellett minden tagosztály tartalmaz egy típusnevet és egy egy karakterből álló kódot ezek lekérdezésére a Product osztály szintén tartalmaz metódust. Emellett tartalmaz egy Print metódust, amely a kiiratásért felelős, ez a termék adatait jeleníti meg a kimeneten.
        </para>
        <para>
            A termékek nyilvántartásához létrehozunk egy productinvertory osztályt a nyilvántartott termékekre egységesen termékként hivatkozik. Tehát ezt egy nyíllal jelöljük, amely fölé felé írjuk a hivatkozás nevét. És a kapcsolat típusa egy a többhöz azaz az invertoryba több termék kapcsolódik. Létrehozunk ezután egy ProductFactory és egy ComputerProductFactory osztályt. A productfactory és a product között szintén egy a többhöz kapcsolat van. A computer productfactory pedig a productfactoryval van aggregációban. A productfactory-t használjuk arra, hogy biztosítsa a keretrendszerünk általánosságát. Azaz, hogy úgy hozzunk létre specifikus terméket, hogy nevüket nem szerepeltetjük a keretrendszer kódjában.
            Az esettanulmány UML ábrája:
        </para>
        <figure>
            <title>UML Esettanulmány a könyvből</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/Esettanulmany.png" scale="200"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <figure>
          <title>UML Esettanulmány a könyvből futtatva</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/Esettan2.png" scale="200"/>
                  </imageobject>
              </mediaobject>
      </figure>
    </section>
    <section>
        <title>BPMN</title>
        <para>
            Rajzoljunk le egy tevékenységet BPMN-ben!
			https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_7.pdf (34-47 fólia)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A BPMN= Business Process Management Notation. Az eseményeket körrel jelöljük. Események lehetnek a start és a stop. A tevékenységeket lekerekített téglalappal jelöljük.
            Ezek lehetnek atomiak és összetettek. Az átjárókat rombusszal jelöljük. Az átjárók logikai kapuk.
        </para>
        <para>
            Összeköttetések:
            Nyilakkal jelöljük őket. A sima fekete nyíl jelöli a tevékenység folyamatot. Tehát, hogy a tevékenységek milyen sorrendben hajtódnak végre.
            Az üzenetet a szaggatott nyíl jelöli ez információ csere két független folyamat között. Az asszociációt pontozott nyíllal jelöljük. Ez jelöli az adat,szöveg stb. hozzárendeléseket.
        </para>
        <para>
            A tagolás: Pool:A résztvevőket jelöli. Jele egy nagy téglalap és szerepel benne a résztvevő megnevezése. Ebbe tesszük a résztvevő cselekvési folyamatát.
            Sáv: A tevékenységek csoportosítása.
        </para>
        <para>
            Artifact:Adat objektum:jele egy mappa.Szimbolikus token.
            Csoport:tevékenységek csoportosítása jele: a szaggatott lekerekített téglalap.
        </para>
        <figure>
            <title>BPMN</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/BPMN.png" scale="200"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            Az ábra létrehozásához a Visual Paradigm-ot használtam. Az esettanon a betegség esetén való háziorvoshoz fordulás látható.
        </para>
        <para>
            Ugyebár minden ott kezdődik, hogy betegek leszünk aztán elmegyünk az orvoshoz. Az orvos egyessével szólítja a betegeket, tehát várunk addig amíg sorra nem kerülünk.
            Ha minket szólít az orvos akkor bemegyünk. Majd a vizsgálat következik. Ugyebár az orvos és a beteg ilyenkor kommunikál ezért messagek vannak az orvos és beteg között.
            Az ábrát bonyolítani lehetne azzal, hogy az háziorvosoknak általában van asszisztensük. Ekkor létrehoztunk volna egy sávot és bele két pool-t. Majd a betegek behívását nem az orvos végezné,hanem az asszisztens.
        </para>
    </section>
    
    <section>
        <title>TeX UML</title>
        <para>
            Valamilyen TeX-es csomag felhasználásával készíts szép diagramokat az OOCWC projektről (pl.
use case és class diagramokat).
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Latex">https://github.com/Savitar97/Prog2/tree/master/Latex</link>               
        </para>
        <para>
            A feladat megoldásához a visual paradigm-ot használtam arra, hogy egy vázlatot készítsek, amelyet majd texben megvalósítok.
            A TeX-es oldalról a tikzuml-t használtam. A használatának a leírását a következő linken találjuk:<link xlink:href="https://perso.ensta-paristech.fr/~kielbasi/tikzuml/var/files/doc/tikzumlmanual.pdf">https://perso.ensta-paristech.fr/~kielbasi/tikzuml/var/files/doc/tikzumlmanual.pdf</link>.
            Igazából a feladat nagy része a pepecs munkával telt. Beigazítani az osztály blokkokat és beméretezni őket. Viszont én például aki alig használt eddig latexet elég sokat tanultam belőle.
        </para>
        <programlisting language="java"><![CDATA[
          \usepackage{tikz-uml}
          ]]>
        </programlisting>
        <para>
          A fent lévő packaget kell behúznunk.
          Osztály létrehozásának szintaxisa a következő:
        </para>
        <programlisting language="java"><![CDATA[
          \umlclass[tulajdonságok például a típusleírás vagy x és y]{class név}
          {
            változók blokkja
            pl.: x:int és mindig "\\"-el választjuk el. 
            Arra figyeljünk oda, hogy az underscore használatához használnunk kell a következő packaget:\usepackage{underscore}
            a destruktor jelénél a \~{}-t az &-eknél a \&-t a #-nél szintén a \#-t.
          }
          {metódusok blokkja}
          ]]>
        </programlisting>
        <para>
          A kapcsolatoknál aggregáció, asszociáció stb használata a következő:
        </para>
        <programlisting language="java"><![CDATA[
          Nyíl nélküli irányítatlan asszociáció  pl:\umlassoc{CarType}{Car}
          Nyilazott asszociáció \umluniassoc{CarType}{Car}
          Agregáció:\umlaggreg {ShmClient}{MyShmClient} A tartalmazó osztályt írjuk először majd utána a tartalmazottat.Fehér rombusz a jele a tartalmazó felől.
          Öröklődés \umlinherit {ShmClient}{MyShmClient} Az UML-ben általánosításként ismerjük. Jele egy kitöletetlen, zárt nyílvégű nyíl.Amely a leszármaztatottól mutat az ős felé.
          ]]>
        </programlisting>
        <figure>
          <title>Latex OOCWC diag</title>
              <mediaobject>
                  <imageobject>
                      <imagedata fileref="img/Latexdiag.png" scale="200"/>
                  </imageobject>
              </mediaobject>
      </figure>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter> 

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>Encoding</title>
        <para>
Fordítsuk le és futtassuk a Javat tanítok könyv MandelbrotHalmazNagyító.java forrását úgy, hogy a
fájl nevekben és a forrásokban is meghagyjuk az ékezetes betűket!
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Encoding">https://github.com/Savitar97/Prog2/tree/master/Encoding</link>               
        </para>
        <para>
            A mandelbrot nagyítós feladattal már találkoztunk a Prog1-es kurzuson. Most ezt kellett magyar ékezetes karakterekkel megírni és lefordítani. Kezdezben ez nem sikerült, de az interpreter hamar segített rájönni, hogy a kódolással van gondja a fordítás közben.
            A Java a C++ és C-vel ellentétben már támogatja az ékezetes betűket tartalmazó osztály neveket,változóneveket stb.-t. A programunk fordításához az ISO-8859-2 azaz a Latin-2-es karakterkészletet használtuk.
            Mivel ez tartalmazza a magyar ékezetes betűket. De ezen kívül használhatjuk a Windows-1252 kódolást is.
            Ezt a következőképpen érjük el:
        </para>
        <programlisting language="java"><![CDATA[
            javac -encoding ISO-8859-2 MandelbrotHalmazNagyító.java
            ]]>
          </programlisting>
          <figure>
                <title>MandelbrotHalmazError</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/MandelError.png" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        <para>
            Alapból fordítva a következő hibaüzenet vár minket. Amiből látszik, hogy utf8-as karakterek szükségesek.
        </para>
        <para>
            A fordítónak a -encoding kapcsolóval adjuk meg, hogy milyen karakterkódolást használjon.
        </para>
        <para>
            A nagyítónk nem változott maradt a Prog1-ben megismert Java-s nagyító annyi különbséggel, hogy ékezetes karaktereket használunk a deklarációban.
        </para>
        <programlisting language="java"><![CDATA[
            public MandelbrotHalmazNagyító(double a, double b, double c, double d,
            int szélesség, int iterációsHatár) {
        // Az õs osztály konstruktorának hívása
        super(a, b, c, d, szélesség, iterációsHatár);
        setTitle("A Mandelbrot halmaz nagyításai");
        // Egér kattintó események feldolgozása:
        addMouseListener(new java.awt.event.MouseAdapter() {
            // Egér kattintással jelöljük ki a nagyítandó területet
            // bal felsõ sarkát vagy ugyancsak egér kattintással
            // vizsgáljuk egy adott pont iterációit:
            public void mousePressed(java.awt.event.MouseEvent m) {
                // Az egérmutató pozíciója
                x = m.getX();
                y = m.getY();
                // Az 1. egér gombbal a nagyítandó terület kijelölését
                // végezzük:
                if(m.getButton() == java.awt.event.MouseEvent.BUTTON1 ) {
                    // A nagyítandó kijelölt területet bal felsõ sarka: (x,y)
                    // és szélessége (majd a vonszolás növeli)
                    mx = 0;
                    my = 0;
                    repaint();
                } else {
                    // Nem az 1. egér gombbal az egérmutató mutatta c
                    // komplex számból indított iterációkat vizsgálhatjuk
                    MandelbrotIterációk iterációk =
                            new MandelbrotIterációk(
                            MandelbrotHalmazNagyító.this, 50);
                    new Thread(iterációk).start();
                }
            }
            // Vonszolva kijelölünk egy területet...
            // Ha felengedjük, akkor a kijelölt terület
            // újraszámítása indul:
            public void mouseReleased(java.awt.event.MouseEvent m) {
                if(m.getButton() == java.awt.event.MouseEvent.BUTTON1 ) {
                    double dx = (MandelbrotHalmazNagyító.this.b
                            - MandelbrotHalmazNagyító.this.a)
                            /MandelbrotHalmazNagyító.this.szélesség;
                    double dy = (MandelbrotHalmazNagyító.this.d
                            - MandelbrotHalmazNagyító.this.c)
                            /MandelbrotHalmazNagyító.this.magasság;
                    // Az új Mandelbrot nagyító objektum elkészítése:
                    new MandelbrotHalmazNagyító(
                            MandelbrotHalmazNagyító.this.a+x*dx,
                            MandelbrotHalmazNagyító.this.a+x*dx+mx*dx,
                            MandelbrotHalmazNagyító.this.d-y*dy-my*dy,
                            MandelbrotHalmazNagyító.this.d-y*dy,
                            600,
                            MandelbrotHalmazNagyító.this.iterációsHatár);
                }
            }
        });
        // Egér mozgás események feldolgozása:
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            // Vonszolással jelöljük ki a négyzetet:
            public void mouseDragged(java.awt.event.MouseEvent m) {
                // A nagyítandó kijelölt terület szélessége és magassága:
                mx = m.getX() - x;
                my = m.getY() - y;
                repaint();
            }
        });
    }
            ]]>
          </programlisting>
        <figure>
                <title>MandelbrotHalmazNagyító</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/Nagyító.png" scale="40"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        <para>
            Ez a feladat szorosan kapcsolódik az elmélethez. Főleg a karakterkészlet szerepe játsza a kulcsszerepet ebben a feladatban.
            De ugyanúgy a java nyelv lexikális elemei is megjelennek benne természetesen. És a kifejezések és utasításokat is használjuk.
            De logikusan nem tudunk úgy programot írni, hogy ezeket ne használnánk.
        </para>
    </section>        

    <section>
        <title>OOCWC Lexer</title>
        <caution>
                <title>
                    Tutorált
                </title>
                <para>Ebben a feladatban tutorált Racs Tamás.</para>
        </caution>
        <para>
          Izzítsuk
be
az
OOCWC-t
és
vázoljuk
a
https://github.com/nbatfai/robocar-
emulator/blob/master/justine/rcemu/src/carlexer.ll lexert és kapcsolását a programunk OO
struktúrájába!  
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/robocar-emulator">https://github.com/Savitar97/Prog2/tree/master/robocar-emulator</link>             
        </para>
        <para>
            A lexer egy lexikális elemző, amely a szövegek feldolgozását segíti elő. A lexert már prog1-en is használtuk a leet programunk megírásához.
            Ott az volt a feladata, hogy a bemenő szöveg karaktereit felismerje majd cserélje ki másikra. Most megfigyelhetjük, hogy a file kiterjesztése nem .l hanem .ll.
        </para>
        <para>
            Ugyebár itt a részeket két százalékjel választja el egymástól. Az első ilyen rész tuti, hogy bekerül a programba. Itt adjuk meg a definíciókat két  százalékjel és kapcsoszárójel közé téve. Ezt követik a konstansok inicializálása.   
        </para>
        <programlisting language="java"><![CDATA[
            %option c++
%option noyywrap

%{
#define YY_DECL int justine::robocar::CarLexer::yylex()
#include "carlexer.hpp"
#include <cstdio>
#include <limits>
%}

INIT	"<init"
INITG	"<init guided"
WS	[ \t]*
WORD	[^-:\n \t()]{2,}
INT	[0123456789]+
FLOAT	[-.0123456789]+
ROUTE	"<route"
CAR	"<car"
POS	"<pos"
GANGSTERS	"<gangsters"
STAT	"<stat"
DISP	"<disp>"
            ]]>
          </programlisting>
          <para>
              Itt olvashatunk olyan kulcsszavakat mint a route azaz az útvonal, pozíció, gangstrek, pozíció. Tehát valószínüleg a programban ezeknek az adatoknak a feldolgozására használjuk fel majd a lexert.
              Tehát az autók irányítása azzal történhet, hogy a generált koordinátákat beolvassa a lexer feldolgozásra.
          </para>
          <para>Majd ezt követik azok a szabályok, amiket elfogad a lexerünk. Tehát a jó bemenetek definiálása.</para>
          <programlisting language="java"><![CDATA[
            %% 
{DISP}					{
					  m_cmd = 0;
					}
{POS}{WS}{INT}{WS}{INT}{WS}{INT}	{
					  std::sscanf(yytext, "<pos %d %u %u", &m_id, &from, &to);
					  m_cmd = 10001;
					}
{CAR}{WS}{INT}				{
					  std::sscanf(yytext, "<car %d", &m_id);
					  m_cmd = 1001;
					}
{STAT}{WS}{INT}				{
					  std::sscanf(yytext, "<stat %d", &m_id);
					  m_cmd = 1003;
					}
{GANGSTERS}{WS}{INT}			{
					  std::sscanf(yytext, "<gangsters %d", &m_id);
					  m_cmd = 1002;
					}
{ROUTE}{WS}{INT}{WS}{INT}({WS}{INT})*	{
				  int size{0};
				  int ss{0};
				  int sn{0};				  
				  
				  std::sscanf(yytext, "<route %d %d%n", &size, &m_id, &sn);
				  ss += sn;
				  for(int i{0}; i<size; ++i)
				  {
				    unsigned int u{0u};
				    std::sscanf(yytext+ss, "%u%n", &u, &sn);
				    route.push_back(u);
				    ss += sn; 				    
				  }
				  m_cmd = 101;
				}
{INIT}{WS}{WORD}{WS}("c"|"g")	{
				  std::sscanf(yytext, "<init %s %c>", name, &role);
				  num = 1;
				  m_cmd = 0;
				}
{INIT}{WS}{WORD}{WS}{INT}{WS}("c"|"g")	{
				  std::sscanf(yytext, "<init %s %d %c>", name, &num, &role);
				  if(num >200)
				  {
				    m_errnumber = 1;
				    num = 200;
				  }
				  m_cmd = 1;
				}				
{INITG}{WS}{WORD}{WS}("c"|"g")	{
				  std::sscanf(yytext, "<init guided %s %c>", name, &role);
				  num = 1;
				  m_guided = true;
				  m_cmd = 3;
				}
{INITG}{WS}{WORD}{WS}{INT}{WS}("c"|"g")	{				  
				  std::sscanf(yytext, "<init guided %s %d %c>", name, &num, &role);
				  if(num >200)
				  {
				    m_errnumber = 1;
				    num = 200;
				  }
				  m_guided = true;
				  m_cmd = 2;
				}								
.				{;}
%%
            ]]>
          </programlisting>
  <para>
      Mint látható ezt két százalékjel válaszja el tehát egy új programrészhez érkeztünk. A kapcsoszárójelek közé írjuk sorba a szavakat. Tehát például a Car nál elfogadja azt, ami úgy kezdődik, ahogy a Carban definiáljuk.
      Majd követi egy whitespace vagy egy tabulátor és egy int szám. Ugyebár fent behívjuk a CarLexer header file-t, ami a CarLexer osztályunkat tartalmazza amit a yyFlexLexerből származtatunk.
      Emellett van egy operátor túlterhelésünk. És a privát változóink amelyeket itt használunk. Tehát amiben tároljuk a feldolgozott értékeinket.
      Ez a megadási mód hasonló, ahhoz mint amikor formális nyelvek és automaták tantárgynál egy automatának felírjuk kifejezéssel, hogy milyen nyelvet kell elfogadnia. Az sscanfel pakoljuk be a megfelelő változóba az értékeket.
  </para>
  <para>
      A program felélesztésében Racs Tamás segített.
  </para>
  <programlisting language="java"><![CDATA[
    A program futtatásának lépései:
    rcemu:
    1.src/smartcity --node2gps=../lmap.txt
    Ezzel előkészíti a debrecen térképet.
    2.src/traffic
    Futtatja a forgalom szervert.
    rcwin:
    3.java -jar target/site/justine-rcwin-0.0.16-jar-with-dependencies.jar ../lmap.txt
    Ezzel már fut is a programunk. Igaz még csak sima autók lesznek rajta.
    4.src/samplemyshmclient --team=Police
    Hozzáadja a rendőröket.
    5.(sleep 1; echo "<init Norbi 100 g>"; sleep 1)|telnet localhost 10007
    Hozzáadja a Gangstereket.
    ]]>
  </programlisting>
  <figure>
        <title>Valószínüleg ezt dolgozza fel a lexer</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/policeroute.png" scale="30"/>
                </imageobject>
            </mediaobject>
    </figure>
    <figure>
            <title>Fut a program</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/programrun.png" scale="30"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <figure>
                <title>Ha nem adunk meg Gangstereket a program figyelmeztet!</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/teampolice.png" scale="30"/>
                        </imageobject>
                    </mediaobject>
            </figure>
    <para>
        A lexer mint ahogy már a neve is sejti a lexikális egységekre van kihegyezve főleg. Ugyanis ez képes stringeket feldolgozni.
        Csak itt a lexer saját lexikális egységeiről és nem a C++ vagy Javajéról van szó.
    </para>
    </section>
    <section>         
        <title>l334d1c4 5</title>
        <caution>
                <title>
                    Tutor
                </title>
                <para>Ebben a feladatban tutoráltam Ádám Petra,Kun Anettet.</para>
        </caution>
        <para>
Írj olyan OO Java vagy C++ osztályt, amely leet cipherként működik, azaz megvalósítja ezt a betű
helyettesítést: https://simple.wikipedia.org/wiki/Leet (Ha ez első részben nem tetted meg, akkor írasd
ki és magyarázd meg a használt struktúratömb memóriafoglalását!)
        </para>
        <para>
                Megoldás videó:
            </para>
            <para>
                Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/LexerSajatJava">https://github.com/Savitar97/Prog2/tree/master/LexerSajatJava</link>              
            </para>
        <para>
            A saját java lexer megvalósításánál, a java Scanner osztályát használtam, hogy a standard inputról kérjek be adatot a felhasználótól. Mindezt egy végtelen ciklusba tettem, ami addig megy amíg üres szót nem adunk meg. Majd példányosítottam a lexer osztályom lex néven. Úgy, hogy a konstruktorába átadom a bemenő stringet.
        </para>
        <programlisting language="java"><![CDATA[
            class Program{
                public static void main(String[] args) {
                    while(true){
                        Scanner in = new Scanner(System.in);
                        String s = in.nextLine();
                        if(s.length()<1){
                            break;
                        }
                        System.out.println();
                        Lexer lex=new Lexer(s);
                        System.out.println(lex.Lextext());
                        System.out.println();
                           }
                }
                }
                
            ]]>
          </programlisting>
        <para>
            Ezt a bemenő stringet a konstruktorba kisbetűs stringre alakítom. Ezen kívül az osztályom tartalmaz egy többdimenziós tömböt a lexert, ami azt tartalmazza, hogy mivé kell átalakítani a karaktert.
        </para>
        <programlisting language="java"><![CDATA[
    private String text;

	public Lexer(String text)
	{
		this.text=text.toLowerCase();
	}

    private String[][] lexer=
	{
		{"α", "4", "@", "/-\\"},//a
		{"ß", "8", "|3", "|}"},//b
		{"©", "€", "¢", "{"},//c
		{"d", "|)", "|]", "|}"},//d
		...

	};
            ]]>
          </programlisting>
        <para>
        Majd létrehoztam egy metódust lextext néven, amely egy stringet fog vissza adni. A lexerezés megoldásához a StringBuilder osztályt használom.
            Mivel a dinamikusan változó szövegnek itt nagy hasznát veszem.Egy for ciklussal, amit itt én inkább foreach ciklusnak neveznék bejárom a karaktertömbbé alakított bevitt szöveget karakterenként. Majd megvizsgálom milyen a karakter egy switch-el és ez alapján választom ki,hogy a tömb melyik sorából kell kivennem a helyettesítő karaktert.
            A 4 variáció közül a random ciklus segít a programnak választani, hogy mit helyettesítsen be. Ezen kívül megadtam egy default ágat, ha esetleg olyan karaktert írna be, ami nem szerepel a helyettesítési tömbben akkor ugyan azt a karaktert adja vissza mint amit bemenetként kapott. Majd ennek a végén a stringbuildert stringgé alakítom és newtextként térek vissza vele.
        </para>
        <programlisting language="java"><![CDATA[
            public String Lextext(){
                StringBuilder sb=new StringBuilder();
                String newtext;
                for(char c:text.toCharArray()){
                    Random rand = new Random();
                    int random = rand.nextInt(4);
                    switch(c){
                        case 'a':sb.append(lexer[0][random]);
                        break;
                        case 'b':sb.append(lexer[1][random]);
                        break;
                        case 'c':sb.append(lexer[2][random]);
                        break;
                        case 'd':sb.append(lexer[3][random]);
                        break;
                        case 'e':sb.append(lexer[4][random]);
                        break;
                        case 'f':sb.append(lexer[5][random]);
                        break;
                        case 'g':sb.append(lexer[6][random]);
                        break;
                        case 'h':sb.append(lexer[7][random]);
                        break;
                        case 'i':sb.append(lexer[8][random]);
                        break;
                        case 'j':sb.append(lexer[9][random]);
                        break;
                        case 'k':sb.append(lexer[10][random]);
                        break;
                        case 'l':sb.append(lexer[11][random]);
                        break;
                        case 'n':sb.append(lexer[12][random]);
                        break;
                        case 'm':sb.append(lexer[13][random]);
                        break;
                        case 'o':sb.append(lexer[14][random]);
                        break;
                        case 'p':sb.append(lexer[15][random]);
                        break;
                        case 'q':sb.append(lexer[16][random]);
                        break;
                        case 'r':sb.append(lexer[17][random]);
                        break;
                        case 's':sb.append(lexer[18][random]);
                        break;
                        case 't':sb.append(lexer[19][random]);
                        break;
                        case 'u':sb.append(lexer[20][random]);
                        break;
                        case 'v':sb.append(lexer[21][random]);
                        break;
                        case 'w':sb.append(lexer[22][random]);
                        break;
                        case 'x':sb.append(lexer[23][random]);
                        break;
                        case 'y':sb.append(lexer[24][random]);
                        break;
                        case 'z':sb.append(lexer[25][random]);
                        break;
                        case '0':sb.append(lexer[26][random]);
                        break;
                        case '1':sb.append(lexer[27][random]);
                        break;
                        case '2':sb.append(lexer[28][random]);
                        break;
                        case '3':sb.append(lexer[29][random]);
                        break;
                        case '4':sb.append(lexer[30][random]);
                        break;
                        case '5':sb.append(lexer[31][random]);
                        break;
                        case '6':sb.append(lexer[32][random]);
                        break;
                        case '7':sb.append(lexer[33][random]);
                        break;
                        case '8':sb.append(lexer[34][random]);
                        break;
                        case '9':sb.append(lexer[35][random]);
                        break;
                        default: sb.append(c);
                    }
                }
                newtext=sb.toString();
                return newtext;
                
            }
            ]]>
          </programlisting>
          <para>
              Ezt átírva map használatával. Kisebb módosításokat kellett eszközölni.
          </para>
          <programlisting language="java"><![CDATA[
            class Lexer{
                private String text;
                public Lexer()
                {
                    
                }
             
                public static Map<String, String[]> lexer = new HashMap<String, String[]>();
            
            
            
                public String Lextext(String text){
                    this.text=text.toLowerCase();
                    Random rand = new Random();
                    for (Map.Entry<String, String[]> peldany : lexer.entrySet()) {
            
                        int random = rand.nextInt(4);
                        String kulcs = peldany.getKey();
                        String[] ertek = peldany.getValue();
                        text= text.replace(kulcs, ertek[random]);
                    }
                    return text;
                    
                }
                
                
            }
            ]]>
          </programlisting>
          <para>
              Így néz ki az új osztályunk. Kicseréltük a multidimenziós tömbünket egy hasító táblára. Ami kulcs érték párokkal dolgozik.
              Mostmár fölösleges volt a string builder tehát csak argumentumként közvetlenül átadom a bemenő szöveget.Így a toLowerCase is átkerült ide.
              A forciklusban most a hash táblánkat járjuk és ahol a hash tábla kulcsa megegyezik a szövegben lévő karakterrel ott kicseréljük a karaktert valamelyikre az értékek string tömbből.
              Ugyebár ha a kulcsok között nem szerepel az érték például most az ékezetes betűk akkor ott ugyan azt adja vissza. Legvégül a függvényünk visszaadja a lexerezett szöveget.
          </para>
          <programlisting language="java"><![CDATA[
            //pár példa, hogy hogyan adunk hozzá kulcs érték párokat
            lex.lexer.put("a",new String[] {"α", "4", "@", "/-\\"});
            lex.lexer.put("b",new String[] {"ß", "8", "|3", "|}"});
            lex.lexer.put("c",new String[] {"©", "€", "¢", "{"});
            ]]>
          </programlisting>
          <para>
              Ugye mivel itt saját lexert írunk ezért itt is a lexikális egységeké a kulcsszerep az elméleti részből.
          </para>
    </section>
    <section>
        <title>Full screen</title>
        <para>
                Készítsünk egy teljes képernyős Java programot!
                Tipp: https://www.tankonyvtar.hu/en/tartalom/tkt/javat-tanitok-javat/ch03.html#labirintus_jatek
        </para>
        <para>
            <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/FullScreen">https://github.com/Savitar97/Prog2/tree/master/FullScreen</link>
        </para>
        <para>
            A teljes képernyős alkalmazáshoz javafx-et használta. Ez volt az első javafx alkalmazásom.
            Tehát egy kis fun-alkalmazást csináltam.
        </para>
        <para>
            A futtatáshoz érdemes a javafx-sdk-13-as verzióját használni. Máskülönben olyan errort kapunk a MediaPlayer létrehozására amire megoldást sehol nem találunk.(Tapasztalat)
        </para>
        <para>
            A program futtatásakor a következő kép fogad minket(vagyis nem pont ez mert egy kis ablakba indul elsőnek a scene):
        </para>
        <figure>
            <title>Alkalmazás indítás</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/fullscreen.png" scale="40"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            Összesen 3 action button-van. A fullscreen logikusan kiteszi teljesképernyősre az alkalmazást a normalscreen pedig vissza ablak módba.
        </para>
        <programlisting language="java"><![CDATA[
            Fullscreen.setOnAction(new EventHandler<ActionEvent>() {
                @Override
                public void handle(ActionEvent actionEvent) {
                    primaryStage.setFullScreen(true);
                }
            });
    
            Normalscreen.setOnAction(new EventHandler<ActionEvent>() {
                @Override
                public void handle(ActionEvent actionEvent) {
                    primaryStage.setFullScreen(false);
                }
            });
            ]]>
          </programlisting>
          <para>
              Ez lényegében ennyi. Míg a Start lejátszik egy hang file-t. Kicseréli a képet és feldob egy alert boxot. A hang file-t sajnos csak azok élvezhetik akik letöltik a programot.
              De itt egy kép a start gomb megnyomása után történő eseményről:
          </para>
          <figure>
            <title>Start megnyomása</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/fullscreenstart.png" scale="40"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            A feladat megoldására az ötlet akkor jött, amikor épp youtuben néztem, hogy a mesterlövész puskák távcsövén is linux operációs rendszer egyik disztrója fut és a videóban épp azt törték fel.
        </para>
        <para>
            Scene létrehozása java fxben a következőképpen történik:
        </para>
        <programlisting language="java"><![CDATA[
            Scene scene = new Scene(bp, 500, 500);
        primaryStage.setScene(scene);
        primaryStage.show();
            ]]>
          </programlisting>
          <para>
              A bp az nekem egy borderpane ez végülis egy csoport szülője. Ugyebár a scane-nél az első argumentum az általában vagy egy csoport vagy egy szülő(root).
              És a szülőből letudunk származtatni a .get childrennel. De végülis a borderpane felelős azért,hogy feltudjam osztani 5 részre a scene-t. A másik két érték az ablak méretét adja meg.
              Emellett 4. értékként megadhatunk neki például színt, hogy a Scene színe milyen legyen.
          </para>
          <para>
              Képet és zenét vagy videót behúzni a következőképpen tudunk:
          </para>
          <programlisting language="java"><![CDATA[
            Image img = new Image("pic1.png",1260,600,false,true);
            Image img1 = new Image("pic2.png",1260,600,false,true);
            ImageView iv=new ImageView(img);

            Media media=new Media(new File("/home/nemesis/IdeaProjects/FullScreen/src/supa.mp3").toURI().toString());
            MediaPlayer player = new MediaPlayer(media);
            ]]>
          </programlisting>
    </section>        
    <section>
        <title>Perceptron osztály</title>
        <para>
          Dolgozzuk be egy külön projektbe a projekt Perceptron osztályát!
Lásd https://youtu.be/XpBnR31BRJY  
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/perceptron">https://github.com/Savitar97/Prog2/tree/master/perceptron</link>              
        </para>
        <para>
            A perceptron osztályt is használtuk már Prog1-en.Ekkor még csak egy értéket számolt. A szigmoid függvénnyel ami 0 és 1 közé lőtt be egy értéket.
        </para>
        <programlisting language="java"><![CDATA[
            return sigmoid ( units[n_layers - 1][0] );
            ]]>
          </programlisting>
          <para>
              Eddig ez volt a visszatérési értékünk. Na mi most egy képet szeretnénk kapni ugyebár. Ezért nem csak egy értéket kell számolnunk. Hanem n_units[n_layers -1], ami ugyebár a kép szélessége szorozva a magassággal. Ez egy 600x600 as képnél 360000.
              És ezek az értékek szintén a szigmoid függvénnyel vannak számolva tehát még mindig maradunk a [0,1] intervallumon.
          </para>
          <programlisting language="java"><![CDATA[
            A sigmoid függvényünk:
            double sigmoid ( double x )
            {
                return 1.0/ ( 1.0 + exp ( -x ) );
            }
            A ciklus amivel a sigmoid értékekkel töltjük fel a tömbünket:
            #pragma omp parallel for
            for ( int j = 0; j < n_units[i]; ++j )
            {
                units[i][j] = 0.0;

                for ( int k = 0; k < n_units[i-1]; ++k )
                {
                    units[i][j] += weights[i-1][j][k] * units[i-1][k];
                }

                units[i][j] = sigmoid ( units[i][j] );

            }
            ]]>
          </programlisting>
          <para>
              De mivel már az operátor függvényünk nem egy értéket hanem egy tömböt ad vissza ugyebár. A képünket konkrétan. Ezért a doublet double*-ra kellett változtatnunk.
              Különben a compiler egy olyan hiba üzenettel fogad hogy a double nem alakítható double*-ra.
          </para>
          <programlisting language="java"><![CDATA[
            for(int i = 0; i < n_units[n_layers -1]; i++){
                image[i] = units[n_layers -1][i];
                }
                return image;
            ]]>
          </programlisting>
          <para>
              Lényegében ennyi módosítást kellett eszközölnünk. A hpp-ben. Most lássuk a cpp kódot.
          </para>
          <programlisting language="java"><![CDATA[
            Perceptron* p = new Perceptron(3, size, 256, size);
            ]]>
          </programlisting>
          <para>
              Mivel már nem egy értéket várunk eredményül ezért a perceptronunk kimenő értékének a számát(konstruktorban az utolsó érték) növelnünk kellett a kép méretére. Ugyebár a perceptronunk konstruktorának várt 4 argumentuma
              az első a bemenő input vagy a layerek száma a második a súlyok száma, harmadik a hidden rétegek száma, és az utolsó a várt outputok száma.
          </para>
          <para>Na és mivel már nem egy számot akarunk kapni ezért a value-t átkell írnunk double* value-ra, hogy egy tömb legyen.</para>
          <para>Majd legvégül végig bekell járnunk a képet és módosítani a pixeleket és kiírni.</para>
          <programlisting language="java"><![CDATA[
            for(int i = 0; i < kep.get_width(); ++i)
            for(int j = 0; j<  kep.get_height(); ++j){
            kep[i][j].blue = value[i*kep.get_height()+j];
            }
            kep.write("visszakep.png");
            ]]>
          </programlisting>
          <figure>
                <title>A kép előtte</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/mandala2.png" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                    <title>A visszadott kép</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="img/visszakep.png" scale="70"/>
                            </imageobject>
                        </mediaobject>
            </figure>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter> 

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>JDK osztályok</title>
        <para>
Írjunk olyan Boost C++ programot (indulj ki például a fénykardból) amely kilistázza a JDK összes
osztályát (miután kicsomagoltuk az src.zip állományt, arra ráengedve)!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Lezerkardosjdk">https://github.com/Savitar97/Prog2/tree/master/Lezerkardosjdk</link>              
        </para>
        <para>
            A feladatban a boost könyvtárakat kellett használnunk és egy olyan programot kellett írnunk, amely végigjárja a könyvtárat és ha java-s fájlt talál akkor kiirja a nevét.
            A boost előnye az, hogy működik minden modern operációs rendszeren, de főként az unix rendszereken felkapott a használata.
        </para>
        <para>
            Ubuntun a telepítéséhez elég volt kiadni a <command>sudo apt-get install libboost-all-dev</command> parancsot a terminálban.
        </para>
        <para>A program megírásánál nagy segítség volt a <link xlink:href="https://www.boost.org/doc/libs/1_68_0/libs/filesystem/doc/tutorial.html">https://www.boost.org/doc/libs/1_68_0/libs/filesystem/doc/tutorial.html</link></para>
        <para>Ezek közül a tut3.cpp az ami lényeges számunkra. Ez egy jó alapot biztosított, amelyet kombinálnunk kellett a fénykardban megírt metódussal.</para>
        <programlisting language="java"><![CDATA[
            int main(int argc, char* argv[])
        {
        if (argc < 2)
        {
            cout << "Kevés argumentum\n";
            return 1;
        }

        path p (argv[1]);

        if (is_directory(p))
            {
                cout << p << " is a directory containing:\n";
                read_acts(p);
                for (auto& x : v)
                { 
                cout << "      " << x.filename() << '\n';
                }

            
                        
            }
            else
            {
                cout<<"Nem mappát adtál meg"<<endl;
                return 2;
            }
            cout<<counter<<endl;


        return 0;
        }
            ]]>
          </programlisting>
        <para>Kezdjük a main-nél a programunk magyarázását. A mainbe elsőnek megvizsgáljuk van -e kellő argumentum ha nem errort dobunk. Ugyanis a mappát, amit vizsgálni akarunk argumentumként adjuk meg a futtatáskor.
            Majd a path metódusnak átadjuk az első argumentumot ami, ugyebár a mappa neve lesz. Ezután rögtön ezután megvizsgáljuk, hogy p azaz a megadott argumentum mappa-e. Ha nem akkor errort dobunk.</para>
        <para>
            Aztán meghívom a readacts metódust (amit a fénykardból használtam fel) a p-re. Beszéljünk most kicsit erről a readact-s metódusról. A readact metódus argumentumként egy boost::filesystem::path típúsú változót vár. A metódus annyit csinál ha az elérési út egy fájl akkor megnézi, hogy a kiterjesztése .java -e. Ezt a vizsgálatot végzi a
            !ext.compare ( boost::filesystem::extension ( path ) ) ) itt azért van a negálás, hogy az ifnek a true ágja fut le ugyanis a compare egyezésnél 0-t adna vissza. Utána megvizsgáljuk, hogy a path mappa-e. Ha mappa akkor rekurzívan bejárjuk. És ugyan úgy ha .java kiterjesztésű fájlt találunk a mappában akkor betesszük a vektorba.
            A végén bejárjuk a vektort és kiiratjuk az eltárolt fileneveket. Természetesen ez a vektor nem szükségszerű, viszont ha rendezni akarjuk a kapott elemeket vagy pedig fel akarjuk használni akkor hasznos.
        </para>
        <programlisting language="java"><![CDATA[
void read_acts ( boost::filesystem::path path )
    {
		
        if ( is_regular_file ( path ) ) {

                std::string ext ( ".java" );
                if ( !ext.compare ( boost::filesystem::extension ( path ) ) ) {
                   counter++;

				v.push_back(path);

                   
                }

        } else if ( is_directory ( path ) )
                for ( boost::filesystem::directory_entry & entry : boost::filesystem::directory_iterator ( path ) ){
                        read_acts ( entry.path());
                    }

    }
            ]]>
          </programlisting>
          <figure>
                <title>Futtatás:</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/JDK.png" scale="30"/>
                        </imageobject>
                    </mediaobject>
            </figure>
    </section>        

    <section>
        <title>Másoló-mozgató szemantika</title>
        <para>
            Kódcsipeteken (copy és move ctor és assign) keresztül vesd össze a C++11 másoló és a mozgató
szemantikáját, a mozgató konstruktort alapozd a mozgató értékadásra!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/MoveCopy">https://github.com/Savitar97/Prog2/tree/master/MoveCopy</link>              
        </para>
        <para>
            A mozgató és másoló konstruktorral már prog 1-en is találkoztunk a binfánál. Így én ezen keresztül mutatnám be.
            Kezdetben tegyük tisztába nagyjából a fogalmat, hogy mit jelent a bal és jobb érték referencia. A bal értékű referenciát
            az =-jelhez köti kapcsolat. Ugyanis ezek olyan kifejezések, amiknek értéket tudunk adni. Ebből következtetve a jobbérték referencia
            minden olyan kifejezés, amit értékül tudunk adni. A másoló konstruktor és értékadás mind a kettő baloldali referenciát,míg a mozgatók jobboldali referenciát várnak paraméterül.
            Az alapértelmezett másoló konstruktor csak a sekély másolást engedélyezi a mélymásolást mindig megkell írni.
        </para>
        <para>
            Kezdjük a másoló konstruktorral:
        </para>
        <programlisting language="java"><![CDATA[
            LZWBinFa ( const LZWBinFa & regi ) {
            std::cout << "LZWBinFa copy ctor called" << std::endl;
            gyoker = masol(regi.gyoker, regi.fa);
             }
             Kisebb programokban elég a 
             *this=regi;
             Meghívása  a mainben:
             LZWBinFa binFa3(binFa);
          ]]>
        </programlisting>
        <para>
            Ez a konstruktor a mélymásolást hívja meg. Tehát lényegében megkettőzzük az objektumunkat. Lefoglaljuk a kellő memória területet, majd
            a binfát átmásoljuk a binfa3-ba. Itt megkettőzzük az elemeket. Nincs erőforrás megosztás.
        </para>
        <para>
            Másoló értékadás:
        </para>
        <programlisting language="java"><![CDATA[
             LZWBinFa& operator= ( const LZWBinFa & regi ) 
            {
                std::cout << "LZWBinFa copy assignment" << std::endl;

                gyoker->balNulla =  masol ( regi.gyoker->balNulla, regi.fa ) ;
                gyoker->jobbEgy =  masol ( regi.gyoker->jobbEgy, regi.fa ) ;

                if ( regi.fa ==  regi.gyoker)
                    fa = gyoker;
                return *this;

            }
            meghívása például
            binfa4=binfa3;
          ]]>
        </programlisting>
        <para>
            Ezt hívjuk sekély másolásnak. A sekély másolás itt azt jelenti, hogy nem kettőzzük az elemeket, hanem most a két objektum megosztja egymás között
            a tárolt adatokat. Vagyis lényegében a másolat pointereit ráállítjuk az eredetinek a pointereire. Tehát ha módosítjuk a másolatot az eredeti is módosul.
        </para>
        <para>Mozgató konstruktor és értékadás:</para>
        <programlisting language="java"><![CDATA[
            LZWBinFa (LZWBinFa && regi ){
            std::cout<<"LZWBinFa move ctor called"<<std::endl;
            gyoker = nullptr;
            
            *this = std::move(regi);

            }
            meghívása mainben például:

            LZWBinFa binfa5(std::move(binfa3));

              LZWBinFa & operator= (LZWBinFa && regi){
      
                std::swap(gyoker, regi.gyoker);
                std::cout << "LZWBinFa move assignment" << std::endl;
                return *this;
            }

            meghívása mainben példa:
            binFa2=std::move(binFa);
          ]]>
        </programlisting>
        <para>
            A másolókkal ellentétben a mozgatás lényege az, hogy az erőforrást átcsoportosítsuk. Tehát így amiből mozgatunk annak kiürül a tartalma
            és az amibe mozgassuk annak pedig megtelik a tartalma a forrás tartalmával. Láthatjuk, hogy a movectorban az std::move-ot hívjuk meg. Míg az értékadásban a swap-et.
            A move az ugyebár "mozgatja" a neki megadott paramétert. Míg a swap felcseréli a neki megadott 2 paramétert.
        </para>
        <figure>
            <title>MozgMasolBinfa</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/mozgmasol.png" scale="40"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <figure>
            A feladat az elméleti részhez úgy kapcsolódik, hogy beleláthattunk milyen a konstruktorok használata és, hogy ezekből több is lehet.
            Illetve a destruktor implementálását használhattuk. Illetve ezen kívül a binfában találkozhatunk operátor túlterheléssel is.
        </figure>
    </section>        
    <section>
        <title>Változó argumentumszámú ctor</title>
        <para>
            Készítsünk olyan példát, amely egy képet tesz az alábbi projekt Perceptron osztályának bemenetére
és a Perceptron ne egy értéket, hanem egy ugyanakkora méretű „képet” adjon vissza. (Lásd még a 4
hét/Perceptron osztály feladatot is.)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/perceptron">https://github.com/Savitar97/Prog2/tree/master/perceptron</link>                
        </para>
        <para>
            Az elmélethez a feladat szintén az osztályok implementálásával kapcsolódik. Találkozhatunk konstruktorral,destruktorral, emellett a láthatósági szinteket is jól szemlélteti a példa, ami egy előző
            elméleti rész volt.
            A perceptron osztályt is használtuk már Prog1-en.Ekkor még csak egy értéket számolt. A szigmoid függvénnyel ami 0 és 1 közé lőtt be egy értéket.
        </para>
        <programlisting language="java"><![CDATA[
            return sigmoid ( units[n_layers - 1][0] );
            ]]>
          </programlisting>
          <para>
              Eddig ez volt a visszatérési értékünk. Na mi most egy képet szeretnénk kapni ugyebár. Ezért nem csak egy értéket kell számolnunk. Hanem n_units[n_layers -1], ami ugyebár a kép szélessége szorozva a magassággal. Ez egy 600x600 as képnél 360000.
              És ezek az értékek szintén a szigmoid függvénnyel vannak számolva tehát még mindig maradunk a [0,1] intervallumon.
          </para>
          <programlisting language="java"><![CDATA[
            A sigmoid függvényünk:
            double sigmoid ( double x )
            {
                return 1.0/ ( 1.0 + exp ( -x ) );
            }
            A ciklus amivel a sigmoid értékekkel töltjük fel a tömbünket:
            #pragma omp parallel for
            for ( int j = 0; j < n_units[i]; ++j )
            {
                units[i][j] = 0.0;

                for ( int k = 0; k < n_units[i-1]; ++k )
                {
                    units[i][j] += weights[i-1][j][k] * units[i-1][k];
                }

                units[i][j] = sigmoid ( units[i][j] );

            }
            ]]>
          </programlisting>
          <para>
              De mivel már az operátor függvényünk nem egy értéket hanem egy tömböt ad vissza ugyebár. A képünket konkrétan. Ezért a doublet double*-ra kellett változtatnunk.
              Különben a compiler egy olyan hiba üzenettel fogad hogy a double nem alakítható double*-ra.
          </para>
          <programlisting language="java"><![CDATA[
            for(int i = 0; i < n_units[n_layers -1]; i++){
                image[i] = units[n_layers -1][i];
                }
                return image;
            ]]>
          </programlisting>
          <para>
              Lényegében ennyi módosítást kellett eszközölnünk. A hpp-ben. Most lássuk a cpp kódot.
          </para>
          <programlisting language="java"><![CDATA[
            Perceptron* p = new Perceptron(3, size, 256, size);
            ]]>
          </programlisting>
          <para>
              Mivel már nem egy értéket várunk eredményül ezért a perceptronunk kimenő értékének a számát(konstruktorban az utolsó érték) növelnünk kellett a kép méretére. Ugyebár a perceptronunk konstruktorának várt 4 argumentuma
              az első a bemenő input vagy a layerek száma a második a súlyok száma, harmadik a hidden rétegek száma, és az utolsó a várt outputok száma.
          </para>
          <para>Na és mivel már nem egy számot akarunk kapni ezért a value-t átkell írnunk double* value-ra, hogy egy tömb legyen.</para>
          <para>Majd legvégül végig bekell járnunk a képet és módosítani a pixeleket és kiírni.</para>
          <programlisting language="java"><![CDATA[
            for(int i = 0; i < kep.get_width(); ++i)
            for(int j = 0; j<  kep.get_height(); ++j){
            kep[i][j].blue = value[i*kep.get_height()+j];
            }
            kep.write("visszakep.png");
            ]]>
          </programlisting>
          <figure>
                <title>A kép előtte</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/mandala2.png" scale="150"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                    <title>A visszadott kép</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="img/visszakep1.png" scale="70"/>
                            </imageobject>
                        </mediaobject>
            </figure>
    </section>
    <section>
        <title>Összefoglaló:Másoló-Mozgató konstruktor,értékadás</title>
        <para>
           Az előző 4 feladat egyikéről írj egy 1 oldalas bemutató „”esszé szöveget! 
        </para>
        <para>
            A javaval ellentétben a C++-ban nagyobb szabadságunk van a memória kezelésére. A C-hez hasonlóan. Viszont emiatt nekünk kell gondoskodnunk a memória felszabadításért is.
            Azért, hogy ne legyen memória elfolyás. Javaban a GarbageCollector megoldja helyettünk.
        </para>
        <para>
            Ejtsünk szót a bal és jobbérték referenciákról. Balérték referenciák azok amik az egyenlőségjel bal oldalán szerepelnek, tehát azok amiknek értéket tudunk adni ezzel szemben a jobb érték referenciák azok amiket értékül tudunk adni.
            Azaz amik az egyenlőségjel jobb oldalán foglalnak helyet.
        </para>
        <programlisting language="java"><![CDATA[
            Példa:
            int a=10;
            int&bal_ref=a;
            int&&jobbertek_ref=42;
          ]]>
        </programlisting>
        <para>
            Alapesetben mikor megírunk egy osztályt létrehozunk egy konstruktort és egy destruktort neki. Minden osztály alapértelmezettként létrehoz magának egy másoló konstruktort.
            De ez csak a sekély másolást biztosítja. Így ha dinamikus adattagunk van akkor vagy megírjuk a mélymásolást, vagy pedig tiltjuk a használatát. Ezt úgy érjük el, hogy privát láthatóságban deklaráljuk.
            Erre találták ki a rule of three-t. Tehát implementálnunk kell a destruktort a másoló konstruktort és a másoló értékadást. Ha ezek nincsenek deklarálva akkor a compiler létrehozza őket magától. A C++11-el bejött a mozgató szemantika.
            Tehát azóta már a rule of five-ról beszélhetünk ugyanis az előző 3-hoz hozzá került még a mozgató konstruktor és a mozgató értékadás.
        </para>
        <para>
            Nemrég említettem, hogy a sekély másolást használja alapból az osztály. Ez veszélyes mivel a sekély másolás lényege az, hogy nem egy új másolatot hoz létre az adott objektumból csak ugyan arra a memória címre fog mutatni az az objektumunk amibe másoltuk a forrást.
            Tehát ilyenkor, ha felszabadítjuk a forrást és sekély másolást hívtunk meg azelőtt rá. Akkor könnyedén hibába ütközhetünk. Mivel a másolat is ugyan oda mutat ahova az eredeti. Tehát ha a forrást nullázzuk akkor a másolat is a felszabadított területre fog mutatni.
            És akár véletlenül 2x is felszabadíthatjuk azt a területet.
        </para>
        <para>
            Az előzőekben a sekély másolásról volt szó most említsük meg a mély másolást is. A mélymásolás az amikor teljesen lemásoljuk a forrást és utána már a másolat nem kapcsolódik az eredetihez.
            Tehát egy külön példány jön létre aminek a módosításával már nem módosítjuk az eredetit. Viszont ez rendkívül erőforrás igényes. Emiatt jó, hogy létrehozták a mozgató szemantikát. Szó volt az előzőekben a jobb és bal érték referenciákról is.
            Ezek úgy kapcsolódnak a történetbe, hogy a másoló szemantika mindig bal oldali referenciát vár, míg a mozgató mindig jobboldalit.
        </para>
        <para>
            A mozgató szemantikánál már nem új példányok létrehozásával foglalkozunk hanem a forrásból való erőforrás átcsoportosításával. Tehát az eredetiből kipakoljuk az adatot és átpakoljuk az újba.
            Erre segítségünkre van az std::move és std::swap parancsok. Míg a swap felcseréli az értékeket addig a move "mozgatja". Itt nem tényleges mozgatásról van szó hanem az eredeti pointert felváltjuk egy másikra de az értékek maradnak a helyükön.
        </para>
        <programlisting language="java"><![CDATA[
            A mozgató és másoló szemantika szignatúrája:
            Mozgató értékadás:
            T& operator=(T&& data)
            Mozgató konstruktor:
            T ( T&& data )
            Másoló értékadás:
            T& operator=(T& other)
            Másoló konstruktor:
            T ( const T& data )
          ]]>
        </programlisting>
        <para>
            Amint látjuk mind a másoló mind a mozgató osztálytípúsú paramétert vár bemenetnek. És a visszatérési értékük is általában *this lesz. Tehát osztálytípúsú a visszatérési értékük is.
            Mozgatáskor érdemes kinullázni az előző pointert, hogy az már ne mutasson a mozgatott értékre mivel mozgatáskor is hasonló dolog történik mint a sekély másoláskor. Az is látható, hogy a jobbérték referenciákat mindig kettős és el jelöljük,
            míg a bal értékreferenciákra a szokásos egy és-sel hivatkozunk. A konstruktorok között a meghívástól függően fog választani a compiler. Ugyebár a paraméterek alapján. Ugyanis itt használjuk az operátor túlterheléseket az = jel operátort terheljük túl és
            használjuk a metódusnevek túlterhelését is. Az operátor túlterhelés hasznos, hogy a saját osztály típúsunkra is érvényes legyen az =-jel például, de más operátorokat is túl lehet terhelni, hogy esetleg mást csináljanak mint alapból.
        </para>
    </section>
    <section>
        <title>String Osztály</title>
        <para>Megoldás forrása:</para>
        <para>A feladat az volt, hogy hozzunk létre saját string osztályt. A feladatot úgy kezdtem, hogy létrehoztam egy char* buffert ami majd a stringre mutat.Kezdetben ez nullpointerként deklarálom. Emellett létrehoztam egy hossz változót ami a string hosszát adja majd meg.
            Ezek kerülnek ugyebár az osztály privát láthatóságába.Ezután kezdhetjük a publikos részt. Itt először is létrehozzuk a konstruktorunkat ami paraméterként megkap egy konstans char* argumentumot.Ezután beállítjuk a buffer és a hossz értékét.Ha jó a bemenet azaz a buffer nem üres akkor bemásoljuk a bufferbe a szöveget.
            Ugyebár a char* szöveg a szöveg első karakterére fog mutatni míg a +hossz megadja az utolsó karakter helyét. És a copy 3. paramétere az output azaz hogy a bufferbe akarjuk berakni a szöveget.
        </para>
        <programlisting language="java"><![CDATA[
            class Osztaly{
            private:
                char* buff=nullptr;
                int hossz=0;
            public:
                Osztaly(const char* szoveg){
                    hossz=std::strlen(szoveg);
                    buff=new char[hossz+1];
                    if(buff!=0)
                    {	
                        //OutputIt copy( InputIt first, InputIt last, OutputIt d_first );
                        std::copy(szoveg,szoveg+hossz, buff);
                    }
                    else
                    {
                        std::cout<<"Hibás"<<std::endl;
                    
                    }
                }
                    ]]>
        </programlisting>
        <para>
            Majd jöhetnek a szokásos másoló és mozgató konstruktorok és értékadások. Ugyanúgy mint a binfás mozgató másoló-s feladatnál. A mozgató konstruktornál move-ot a mozgató értékadásnál swap-et használunk. A visszatérési értékek is a szokásos *this-ek azaz önhivatkozások amelyek erre az objektumra vonatkoznak.
            Ezután jönnek az operátor túltöltések ugyanis szeretnénk, hogy azok a mi osztályunkra is működjenek. Ahhoz, hogy kitudjuk írni a kettős kacsacsőr operátor működését írjuk felül. Ehhez friend függvényként kell meghívnunk.Ezt láthattuk már régebben az LZWBinFánál is.
        </para>
        <programlisting language="java"><![CDATA[
            friend std::ostream & operator<< (std::ostream & os, LZWBinFa & bf)
            {
                bf.kiir (os);
                return os;
            }

            Most nekünk így kell használnunk:
            friend std::ostream& operator<< (std::ostream& os,const Osztaly& szoveg)
            {
                os << szoveg.buff;
                return os;
            }
          ]]>
        </programlisting>
        <para>
            Ezen kívül azt is szeretnénk, hogy a stringünknek egy adott karakterjére lehessen a []- hivatkozni. Ezt a [] operátor túlterhelésével érjük el.
        </para>
        <programlisting language="java"><![CDATA[
        char operator[](int x) const{
                
                if( x > hossz ) { std::cout << "Túlhivatkoztál!" <<std::endl; }
                return (buff[x]);
                }
          ]]>
        </programlisting>
        <para>Ez is egy egyszerű dolog ugyanis a karakter indexekre egész számokkal hivatkozunk ezért ugyebár az argumentum egy int lesz. Ami ha nagyobb mint a szöveg hossza hibát dobunk egyébként meg visszadjuk a szövegnek a megfelelő karakterét, ami ugyebár a bufferben tárolódik.</para>
        <programlisting language="java"><![CDATA[
            void rev() 
		    { 
		    int n = hossz; 
		  
		    
		    for (int i = 0; i < n / 2; i++) 
		        std::swap(buff[i], buff[n - i - 1]); 
		    } 
          ]]>
        </programlisting>
        <para>
            Végül még egy metódus, amely megfordítja a stringünket.
        </para>
        <figure>
                <title>String futtatás</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/MyString.png" scale="40"/>
                        </imageobject>
                    </mediaobject>
            </figure>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>  
    
  <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gödel!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Gengszterek</title>
        <para>
Gengszterek rendezése lambdával a Robotautó Világbajnokságban
https://youtu.be/DL6iQwPx1Yw (8:05-től)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/robocar-emulator">https://github.com/Savitar97/Prog2/tree/master/robocar-emulator</link>               
        </para>
        <para>
            Az elmélethez ugyebár a lambda kifejezéssel kapcsolódik, de ezt a feladat leírásából is tudhattuk előre.
            A lambda kifejezések a C++11 óta részei a nyelvnek. A lambda kifejezések jellemzője, hogy a visszatérési értékük automatikus. A feladat, hogy vizsgáljuk meg a robotautóban
            a gangsterek rendezését. Ugyebár a rendezés alpja a távolság a rendőröktől. Tehát minél közelebb van egy Gangster objektum egy rendőr objektumhoz annál előrébb kerül a listán.
            Ez azért szükséges, hogy a rendőrök mindig a hozzájuk legközelebb eső Gangstert kezdjék el üldözni. Így a lambdába bemenő két Gangster típúsú paraméter az x és y lesz. A paramétereket ()-be tesszük.
            Ugyebár a lambda kifejezés előnye az, hogy lehetővé teszi olyan 1 soros kódcsipetek írását, amely kis terjedelmű és olvasható. Megkímél minket a hosszú kifejezésektől. Rövid tömör és lényegre törő.
            A szintaxisa a következő képpen néz ki:
        </para>
        <programlisting language="java"><![CDATA[
            [ capture clause ] (parameters) -> return-type  
            {   
            definition of method   
            }
            ]]>
          </programlisting>
          <para>
              Itt a return type az, ami elhanyagolható és csak valami komplexebb esetben szükséges. A kocka zárójelbe a capture kerül. A capture lehet érték szerinti ezt az egyenlőség jel jelzi vagy esetleg referencia szerinti ilyenkor az és jelzi
              mint a megszokott referencia szerinti átadásnál. És ezen kívül lehet vegyes. De akár üres is. Ha üres akkor csak a lokális változókhoz fér hozzá. A törzse a lambda kifejezésnek a megszokott kapcsos zárójelek közé kerül. Tehát egy blokkba.
          </para>
          <programlisting language="java"><![CDATA[
            std::sort ( gangsters.begin(), gangsters.end(), [this, cop] ( Gangster x, Gangster y )
            {
                return dst ( cop, x.to ) < dst ( cop, y.to );
            } );
            ]]>
          </programlisting>
          <para>
              Így néz ki a kész kód. Ugyebár mivel rendezünk ezért a sortot fogjuk használni. Ugye mivel nem egyszerű rendezés kell 
              ezért a hosszabb speciális alakját használjuk, amelynek 3 argumentumot kell megadni. A tömb kezdetét,végét és a 3. a rendezés alapját. Azaz egy olyan függvényt, amely a rendezést szolgálja és bool a visszatérési értéke.
              Ugyebár a this szokás szerint magára az adott objektumra vonatkozik. És ezenkívül a cophoz fér még hozzá a capture érték szerint.
          </para>
  
  
    </section>               
    <section>
        <title>STL map érték szerinti rendezése</title>
        <para>
            Például: https://github.com/nbatfai/future/blob/master/cs/F9F2/fenykard.cpp#L180
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Map">https://github.com/Savitar97/Prog2/tree/master/Map</link>           
        </para>
        <para>
            A feladat az elmélethez a Map miatt kapcsolódik ugyebár ez egy kollekció vagyis egy olyan adatszerkezet amely képes különböző típúsú adatokat letárolni.
            Egy map érték szerinti rendezése volt a feladat. A mapok kulcs-érték párok. Nézzük is meg, hogyan lehet deklarálni egy mapot c++-ban és, hogyan tudunk értékeket felvenni benne.
        </para>
        <programlisting language="java"><![CDATA[
            std::map<std::string, int> planetsMap;
                planetsMap.insert(std::make_pair("earth", 4));
                planetsMap.insert(std::make_pair("moon", 2));
                planetsMap.insert(std::make_pair("jupiter", 10));
                planetsMap.insert(std::make_pair("mars", 7));
                planetsMap.insert(std::make_pair("saturnus", 9));
            ]]>
          </programlisting>
          <para>
            Mint látható az insertel tudunk értékeket felvenni a mapunkba és az értékek ugyebár kulcs érték párok, amiket a make_pairrel vagyunk képesek képezni.
            Na és most nézzük meg, hogyan tudjuk kiiratni ezeket az értékeket:
          </para>
          <programlisting language="java"><![CDATA[
            std::map<std::string, int>::iterator it = planetsMap.begin();
            while(it != planetsMap.end())
            {
                std::cout<<it->first<<" :: "<<it->second<<std::endl;
                it++;
            }
            ]]>
          </programlisting>
          <para>
              A fenti kódban látható, hogy az it-et ráállítjuk a map első értékére, ezt a .begin el érjük el. Majd egy while ciklussal bejárjuk a mapot.
              Addig míg az it nem az utolsó elemre fog referálni. És kiiratjuk a first el a kulcsot és a seconddal az értéket.
          </para>
          <para>
              Most nézzük a rendezésünket:
          </para>
          <programlisting language="java"><![CDATA[
            std::vector<std::pair<std::string, int>> rendezMap ( std::map <std::string, int> &rank )
            {
                    std::vector<std::pair<std::string, int>> rendezett;

                    for ( auto & i : rank ) {
                            if ( i.second ) {
                                    std::pair<std::string, int> p {i.first, i.second};
                                    rendezett.push_back ( p );
                            }
                    };

                    std::sort (
                            std::begin ( rendezett ), std::end ( rendezett ),
                    [ = ] ( auto && p1, auto && p2 ) {
                        std::cout<<p1.second<<std::endl;
                        std::cout<<p2.second<<std::endl;
                        std::cout<<"**************"<<std::endl;
                            return p1.second > p2.second;
                    }
                    );

                    return rendezett;
            }
            ]]>
          </programlisting>
          <para>
              Na tehát nézzük a függvényünket. Ugyebár a paramétert referenciaként adjuk át ezt jelöli az és jel. Létrehozunk egy új vektort a függvényen belül a neve az lesz, hogy rendezett.
              Majd egy foreach ciklussal bejárjuk a mapunkat és a rendezetthez adjuk az elemket. Majd jön egy lamdakifejezés, amivel rendezzük érték szerint a mapot. Ugyebár végig megyünk a vektoron és megvizsgáljuk, hogy a p1 nagyobb-e mint p2 ha nem akkor elkezdünk végig menni az értékeken hátulról és a megfelelő helyre beszúrni.
              Majd a végén vissza térünk a rendezett mappal. A dokumentációból látható a következő a sort-ra:
          </para>
          <programlisting language="java"><![CDATA[
            default (1)	

            template <class RandomAccessIterator>
            void sort (RandomAccessIterator first, RandomAccessIterator last);

            custom (2)	

            template <class RandomAccessIterator, class Compare>
            void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
                        ]]>
          </programlisting>
          <para>
              Ugyebár itt a custom fog lefutni és a compare comp lesz a lambda kifejezésünk. Aminek a visszatérési értéke bool típúsú lesz.
          </para>
          <figure>
                <title>Map rendezés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/map1.png" scale="35"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                    <title>Map rendezés</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="img/map2.png" scale="35"/>
                            </imageobject>
                        </mediaobject>
                </figure>
    </section>
    <section>
        <title>Alternatív tabella rendezése</title>
        <para>
            Mutassuk be a https://progpater.blog.hu/2011/03/11/alternativ_tabella a programban a java.lang
Interface Comparable szerepét!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Tabella">https://github.com/Savitar97/Prog2/tree/master/Tabella</link>                
        </para>
        <para>
            Itt az elmélet az interfacek használatára világít rá ezen kívül szintén ismerkedhettünk a Java-s source kódokokkal.Ezen kívül az absztrakt fogalom is megjelenik. És láthatjuk ennek felhasználási módját.
        </para>
        <para>
            A Comparable interface szerepére kellett rávilágítanunk ebben a feladatban. Ezt az interface-t meghívó objektumok listáit vagy tömbjeit képesek vagyunk automatikusan rendezni az array.sort-al vagy
            a Collections.sort al. Azok az objektumok, amelyek ezt az interface-t használják ezen kívül használhatók kulcsként rendezett map-okban vagy egy rendezett halmaz elemeiként anélkül, hogy lenne specifikált összehasonlító algoritmusuk.
            A specifikált algoritmus alatt azt értem, hogy külön osztályt hozunk létre az objektum bizonyos tulajdonság szerinti rendezésére. Például itt létrehozhatnánk külön név szerinti rendezést, pont szerinti rendezést stb. Ezt Comperatornak nevezzük.
            A compareto ugyebár úgy működik, hogy egyet ad vissza ha a vizsgált objektumunk nagyobb a megadott objektumnál. -1 el tér vissza ha kisebb a megadott objektumnál és 0 ha egyenlő a két objektum. A Comparable interface lényege, hogy ezt a vizsgálódást kiterjesszük
            az általunk megadott típúsokra is.
            A kódban ez így jelenik meg:
        </para>
        <programlisting language="java"><![CDATA[
        class Csapat implements Comparable<Csapat> {

        protected String nev;
        protected double ertek;

        public Csapat(String nev, double ertek) {
            this.nev = nev;
            this.ertek = ertek;
        }

        public int compareTo(Csapat csapat) {
            if (this.ertek < csapat.ertek) {
            return -1;
            } else if (this.ertek > csapat.ertek) {
            return 1;
            } else {
            return 0;
            }
        }
        }
          ]]>
        </programlisting>
        <para>
            Itt látható, hogy a csapat osztályunkra implementáljuk a Comparable interface-t ugyebár a kacsacsőrök közé a T- típust kell megadni.
            Ugyebár létrehoztunk 2 változót a csapat nevét és a pontját. A konstruktorban csak azt definiáltuk, hogy a paraméterként bejövő értékeket táruljuk le
            a változóinkba. Majd megírjuk az összehasonlító metódust.Itt lényegében érték szerint növekvőbe rendezzük az értékeket. De mivel a csapatokat abc-szerint redezzük.
            Ezért majd a kódban ennek az ellentetjét azaz a reverse-t kell vennünk. Hogy az értékek a jó csapathoz kerüljenek.
        </para>
        <programlisting language="java"><![CDATA[
            java.util.List<Csapat> rendezettCsapatok = java.util.Arrays.asList(csapatok);
            java.util.Collections.sort(rendezettCsapatok);
            java.util.Collections.reverse(rendezettCsapatok);
          ]]>
        </programlisting>
        <para>
            Itt látható a mainben szereplő lényeg ugyebár mint az elején említettem megtudjuk rá hívni a collections.sort-ot.Ez itt látszik is.
        </para>
        <para>
            Nézzük meg kicsit a java forrás fájlokat is, ugyebár a sort az utilban van definiálva azon belül is a collectionsba. Itt láthatjuk, hogy a T típusnak implementálnia kell a Comparable interfacet. Itt extends el szerepel a Comparable. Ezt osztályoknál leszármaztatáskor szoktuk alkalmazni.
            És látható, hogy a list.sort null-t kap meg paraméterül.
        </para>
        <figure>
            <title>Collections</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/javacollection.png" scale="35"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <para>    
            Majd mivel a rendezett csapatok ugyebár listában vannak. Tehát keressük ki a javában a lista sort metódusát. Itt már kicsit több információt kapunk.
        </para>
        <figure>
            <title>Lista</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/javalist.png" scale="35"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            Ez tovább vezet minket az Array.sort-hoz, keressük is ki.
        </para>
        <figure>
            <title>Arrays</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/javaarrays.png" scale="35"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            De sajnos kalandozásunk a forrásokban itt még mindig nem ért a végére. Ugyanis itt látható, hogy a ComparableTimSort osztály sort ját fogja felhasználni.
        </para>
        <figure>
            <title>TimSort</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/javatimsort.png" scale="35"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            A timsort osztályunkban megtalálva a számunkra szükséges sortot látszik, hogy az osztálynak a binarysort metódusa fog meghívódni.
        </para>
        <figure>
            <title>Binarysort</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/javabinarysort.png" scale="35"/>
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            Végére érve látjuk, hogy a binary sortban Comparable típusra kényszerítés történik az objektumunkra.
        </para>
    </section>
    <section>
        <title>Prolog családfa</title>
        <para>
            Ágyazd be a Prolog családfa programot C++ vagy Java programba! Lásd para_prog_guide.pdf!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Family1">https://github.com/Savitar97/Prog2/tree/master/Family1</link>                
        </para>
        <para>
            A prolog családfához felkell használnunk a swi prolog kiegészítőt. Ezt úgy tudjuk telepíteni ubuntun, hogy <command>sudo apt-get install swi-prolog</command>
            és <command>sudo apt-get install swi-prolog-java</command>. A programunkhoz ezen kívül megkell írnunk a prolog pl kiterjesztésű fájlunkat, amely a kifejezéseket és
            a változóink definiálását végzi. Mivel a prolog elsőrendű logikát használ, ezért a logika tárgyon tanultak nagy segítségünkre van. Tehát itt definiáljuk a családi kapcsolatokat,
            amelyet majd vizsgálunk. Például felvesszük, hogy kik a férfiak a családban,de például egy kicsivel bonyolultabb apa az, aki férfi és van gyereke ez a következőképp néz ki a kódban: 
        </para>
        <programlisting language="java"><![CDATA[
            apa(X) :- férfi(X), gyereke(_Y, X).
            ]]>
          </programlisting>
          <para>
              Aztán nézzük magát a kódot. Kezdetben bekell importálni magát a könyvtárat, hogy lássa az org.jpl-t. Ez netbeans projektben könnyű. Csak rámegyünk a projektnél, hogy libraries jobb klikk és add library.
              Aztán Create és megkell adni az elérési útját <command>/usr/lib/swi-prolog/lib/jpl.jar</command>. Aztán be is importálhatjuk a szükséges osztályokat.
          </para>
          <programlisting language="java"><![CDATA[

            import java.util.Map;

            import org.jpl7.JPL;
            import org.jpl7.Query;
            import org.jpl7.Term;
            ]]>
          </programlisting>
          <para> Ezután jöhet maga a program rész. Mielőtt bármihez is neki kezdenénk bekell húznunk a prolog fájlunkat, ugyanis ez alapján dolgozunk.Ez a következőképpen lehetséges:</para>
          <programlisting language="java"><![CDATA[
            String s = "consult('family.pl')";
            Query q = new Query(s);
            System.out.println(s + " " + (Query.hasSolution(s) ? "succeeded" : "failed"));
            ]]>
          </programlisting>
          <para>
              Tehát a forma az h egy stringbe megadjuk a consult függvénybe a fájl nevet. Majd létrehozunk egy query objektumot. Majd rátesztelünk, hogy működik -e vagy nem.
          </para>
          <para>
              Majd jöhetnek a tesztek. Kezdetben nézzük meg, hogy edit apa -e?
          </para>
          <programlisting language="java"><![CDATA[
            String term = "apa(edit)";
            System.out.println(term + " is " + (Query.hasSolution(term) ? "provable" : "not provable"));
            ]]>
          </programlisting>
          <para>
              Természetesen a visszakapott érték a not provable lesz ugyanis apa csak az lehet aki férfi és van gyereke. Itt a println nél a ? operátort használtuk, amely az ifhez hasonló.
              Ha igaz a kifejezés akkor a ?-utáni rész kerül kiértékelésre. Ha hamis akkor a : utáni. Na ezután nézzünk meg egy kicsit nehezebbet.
          </para>
          <para>A következőben nézzük meg ki a nagyapám:</para>
          <programlisting language="java"><![CDATA[
            String term1 = "nagyapja(X, attila)";
            System.out.println("A formula megoldásai: " + term1);
            Query q1 = new Query(term1);
            while (q1.hasMoreSolutions()) {
                Map<String, Term> str = q1.nextSolution();
                System.out.println("X = " + str.get("X"));
            } 
            ]]>
          </programlisting>
          <para>
              Ugyebár a nagyapa az a szüleim szülője. És hát mivel az embernek két szülője van ezért itt több érték lesz. Itt jön képbe a hasmoresolution azaz, hogy van még más jó megoldás is.
              Mivel itt már több érték lesz ezért mapot fogunk használni. A kulcs érték párok itt kapóra jönnek. Mivel érték párokkal dolgozunk. A következő kép szemlélteti a futtatást:
          </para>
          <figure>
                <title>Családfa</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/csaladfa.png" scale="35"/>
                        </imageobject>
                    </mediaobject>
            </figure>
  
  

  
    </section>
	<section>
        <title>GIMP Scheme hack</title>
        <para>
            Ha az előző félévben nem dolgoztad fel a témát (például a mandalás vagy a króm szöveges
dobozosat) akkor itt az alkalom!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
        <para>
            Ebben a gimp scriptben ugyan úgy mint az előzőnél az elején definiáljuk az új képünket és layereinket. A gimp-image-new függvény létrehoz egy listát, mivel minden gimpfüggvény egy listát ad vissza. A lista elemeihez a car-al férünk hozzá, ami kiveszi a lista első elemét. A legfontosabb rész itt a forgatások mivel a mandala úgy készül, hogy a szöveget körbe forgatjuk egy pontban és így a betűk keresztezik majd egymást. A forgatást a gimp-item-transform-rotate-simple függvénnyel érjük el.A változók értékét a set-el tudjuk beállítani.
            Mivel a betűknek a mérete változó szövegtípúsonként ezért függvényt használunk ezeknek az értékeknek a kezelésére ez a text-wh függvény. Ez konkrétan lekéri a fonttípusnak a méreteit és azt tároljuk a szélességben és a magasságban.
            A forgatások után a plug-in-autocrop-layer törli az üres szegélyeket. Majd megadjuk a szélesség és magasságnak a kirajzolható méreteket a drawable-el ez a függvény a kirajzolható pixelekkel tér vissza. Majd ez alapján újraméretezzük a layert a resize- al. Az ecset méreteit a gimp-context-set-brush-size-al tudjuk módosítani ez pixelben adja meg a méreteket. Ezzel adjuk meg majd a mandala keretének a vastagságát, amelyet az gimp-image-select-ellipse-el hozunk létre. Ebből 2 van az egyik a külső körív a vastagabb 22 pixel míg a véknyabb 8 pixel vastag.
            Párbeszéd ablakokat a gimp-message-el tudunk készíteni. Az elkészített képet a gimp-display-new-al jelenítsük meg új ablakban.Majd ki cleareljük a képet gimp-image-clean-all.
            Futtatáskor a kép méretét tudjuk beállítani a betűtípust és a betűméretet. Ezen kívül a színt és színskálát.
        </para>
        <figure>
             <title>Név mandala</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandala.png" scale="100"/>
                </imageobject>
        </mediaobject>
        </figure>
        <figure>
             <title>Név mandala2</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/NemesisR.png" scale="100"/>
                </imageobject>
        </mediaobject>
        </figure>      
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, !</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>FUTURE tevékenység editor</title>
        <para>
        Javítsunk valamit a ActivityEditor.java JavaFX programon!
        https://github.com/nbatfai/future/tree/master/cs/F6
        Itt láthatjuk működésben az alapot: https://www.twitch.tv/videos/222879467
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/nbatfai/future/tree/master/cs/F6">https://github.com/nbatfai/future/tree/master/cs/F6</link>                
        </para>
        <para>
            A feladatunk az volt, hogy keressünk bugokat és javítsuk azokat.Kezdjük magával az applikáció beüzemelésével. Én az intellj idea-t használtam a futtatáshoz.
            A beüzemeléshez szükségünk van arra, hogy letöltsük a javafx-et. Én a 13-ast használom amit innen tölthettek le:<link xlink:href="https://openjfx.io/openjfx-docs/">https://openjfx.io/openjfx-docs/</link>.
            Majd indítsuk el az intellij-t és file/new/project from existing source. Majd behúzzuk az F6-ot. Ezután könyvtárként behúzzuk a javafx library-t. Amit a file/project structure-ban tudunk megtenni.
        </para>
        <para>
            A feladat az elmélethez úgy kapcsolódik, hogy maga a program a funkcionalitását az IO-val nyeri el. Ugyanis tevékenységeket veszünk fel adatokat írunk és mentünk le.
            Ez mind-mind adatfolyamokkal lehetséges.
        </para>
        <figure>
                <title>JavaFx</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/javafxlibrary.png" scale="30"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        <para>
            Ezután bekell állítanunk a debug konfigot ezt a kis zöld kalapács mellett tudjuk hozzá adni application-t kell választanunk.
            Main class-nak az ActivityEditor-t válasszuk. VM options: <command>--module-path /home/user/Asztal/javafx-sdk-13/lib --add-modules javafx.controls,javafx.fxml,javafx.graphics,javafx.media,java.desktop</command>.
            Majd a program argumentek:<command>--city=Debrecen --props=me.props,gaming.props,programming.props</command>. A feladathoz még kell a tree amit a <command>sudo apt-get install tree</command>-vel tudunk feltelepíteni.
        </para>
        <figure>
                <title>Config</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/configuration.png" scale="30"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        <para>
            Az első bug amit találtam azaz volt, hogyha több új tevékenységet hoztunk létre
            akkor hiába láttunk a programban több file-t valójában csak egy volt. Ezért ha bezártuk a programunkat akkor eltűntek. A létrehozott file-ok.
        </para>
        <figure>
                <title>Bug1</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/bug1.png" scale="30"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                    <title>Bug1</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="img/bug1_2.png" scale="30"/>
                            </imageobject>
                        </mediaobject>
                </figure>
        <para>
            Ez azért lehetséges mivel egy mappában nem lehet 2 ugyan olyan kiterjesztésű ugyan olyan nevű file.
            Erre azt a megoldást próbáltam kigondolni, hogy elkezdtem számolni a létrehozandó file-okat. Ez sem tökéletes
            mert még bekéne járni a jelenlegi mappát, hogy milyen nevű fileok vannak a mappában. Amúgy alapból nem számít annyira bugnak
            mivel a create new file csak akkor hozzá létre a file-t ha az még nem létezik.
        </para>
        <programlisting language="java"><![CDATA[
            java.io.File f = new java.io.File(file.getPath() + System.getProperty("file.separator") + "Új altevékenység tulajdonságok"+String.format("%d",counter));
                counter++;
            ]]>
          </programlisting>
          <para>
              A másik hiba amit találtam, ha létrehozunk egy fájlt és azt átnevezzük akkor nem tényleges átnevezés történik, hanem létrejön egy újfile az átnevezett névvel.
          </para>
          <figure>
                <title>Bug2</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/bug2_1.png" scale="30"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                    <title>Bug2</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="img/bug2_2.png" scale="30"/>
                            </imageobject>
                        </mediaobject>
                </figure>
            <para>
                Ennek megoldására a rename-to függvényt használtam a new file helyett.
            </para>
            <programlisting language="java"><![CDATA[
                try {
                    if (oldf.isDirectory()) {
                        oldf.renameTo(newf);
                    } else {
                        oldf.renameTo(newf);
                    }
                } catch (Exception e) {

                    System.err.println(e.getMessage());

                }
                ]]>
              </programlisting>
      
    </section>        

    <section>
        <title>OOCWC Boost ASIO hálózatkezelése</title>
        <para>
            Mutassunk rá a scanf szerepére és használatára! https://github.com/nbatfai/robocar-
emulator/blob/master/justine/rcemu/src/carlexer.ll
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/robocar-             emulator/blob/master/justine/rcemu/src/carlexer.ll">https://github.com/nbatfai/robocar-
            emulator/blob/master/justine/rcemu/src/carlexer.ll</link>                 
        </para>
        <para>
            Az sscanf szerepe, hogy megadott formájú stringet olvassunk be és itt az a lényeg, hogy a hálózatról megkapott adatokat 
            a megfelelő változóba táruljuk el. 
        </para>
        <para>
            Az elmélethez az IO adat feldolgozása és az sscanf szerepe ebben szerepel.És a lexer adatfeldolgozása jelenik még meg. Mindemellett 
            nagyon jól láthatjuk, hogy hogyan képes a program feldolgozni a saját maga által standard input-ra generált adatot.
        </para>
        <programlisting language="java"><![CDATA[
            std::vector<justine::sampleclient::MyShmClient::Gangster> justine::sampleclient::MyShmClient::gangsters ( boost::asio::ip::tcp::socket & socket, int id,
            osmium::unsigned_object_id_type cop )



            while ( std::sscanf ( data+nn, "<OK %d %u %u %u>%n", &idd, &f, &t, &s, &n ) == 4 )
                {
                  nn += n;
                  gangsters.push_back ( Gangster {idd, f, t, s} );
                }
            
            ]]>
          </programlisting>
          <para>
              A hálózatról jövő adatok TCP-n keresztül érkeznek, ez látszik az első kódcsipetből. Ugyebár a TCP az a szállítási rétegben helyezkedik el.
              Főbb jellemzője, hogy megbízható kapcsolatot épít ki az állomások között. Tehát ha egy üzenetet nem sikerül elküldeni akkor annak újraküldése kezdődik meg.
              A fogadó mindig nyugtázza a küldőnek, hogy megkapta -e az üzenetet.
          </para>
          <para>
              A scanfnél a whilera azért van szükségünk mert nem tudjuk, hogy mennyi adatot fogunk kezelni. De tudjuk, hogy a string alakja kacsacsőr OK és 4 érték.
              Azért használhatjuk a whileban az sscanf==4 et mivel a scanf értéke a beolvasott adatok számát jelöli. Tehát addig ameddig 4 et sikerül beolvasni nem fog megállni a ciklusunk.
              A %n nem az inputhoz fog kapcsolódni ugyanis ez tartja számon ,hogy hány adat jött be épp. Az eddig bejövő összes adat számát az nn-ben tároljuk.
              De mivel a data egy karakter tömb és ugyebár mi minden futáskor olyan adatot szeretnénk olvasni ami még nem volt. Tehát ezért kell eltolnunk a tömböt az összes beolvasott elem számával.
              Ez a data+nn. 
          </para>
  
    </section>        
    <section>
        <title>SamuCam</title>
        <para>
            Mutassunk rá a webcam (pl. Androidos mobilod) kezelésére ebben a projektben:
https://github.com/nbatfai/SamuCam
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/SamuCam">https://github.com/nbatfai/SamuCam</link>                 
        </para>
        <para>
            A SamuCam ugyebár Qt-t használ tehát a futtatáshoz telepítenünk kell a Qt-t. Majd kiadnunk a következő parancsot
            <command>~/Qt/5.12.2/gcc_64/bin/qmake SamuLife.pro</command>. Ezután a <command>make</command>-et és már futtathatjuk is a SamuCamunkat.
        </para>
        <para>
            A program az elmélethez most is az IO és a streammel kapcsolódik csak most a bemeneti adatunk nem egy szöveg vagy egy fájl hanem real life adatokkal dolgozunk. Mégpedig folyamatosan változó adatokkal.

        </para>
        <para>
            A samucam futtatása a következő paranccsal történik <command>./SamuCam --ip http://127.0.0.1:8081/ 2&gt;out</command> mivel ugyebár argumentumként várja az ipcamunk címét.
            Ahonnan majd TCP-vel kéri le az adatot. Én az ipcamera dolgot motionnal oldottam meg. Ez egy hasznos progi ugyanis a laptopom webkameráját használhatom vele ip kameraként.
            Ugyebár linuxban ahhoz, hogy megtaláljuk az elérhető webkamerákat kikell adnunk a <command>ls /dev/|grep video</command> parancsot. Ugyebár nekem mivel a laptopot használok
            a video0-ra volt szükségem. USB-n csatlakoztatott kameráknál azt hiszem a video1-et kell használnunk. Fontos ezen kívül, hogy bekonfiguráljuk a motionunkat.
            Ezt a <command>sudo nano /etc/motion/motion.conf</command> -val tehetjük meg. Itt a frameratet érdemes 100-ra állítani. A videodevice-t ha usb-s webkamerát használunk akkor, ahogy már írtam
            video1-re átírni.Ezen kívül a width és height beállítása is fontos lehet.Ugyanis a samu cam a középen lévő arcot ismeri fel minél nagyobb a kamera felbontása úgy vettem észre annál jobb az eredmény.
            Ugyebár mivel tcpvel kérjük le az adatokat ezért a tcpt onra kell állítani,de ez elvileg default. A protot a streamport-nál tudjuk beállítani a default a 8081. 
        </para>
        <para>
            Mivel a camera használat érdekel minket ezért a samuCam forrást kell vizsgálnunk. Kezdjük a header file-al.
            Ennek a tartalma elég rövid tehát lássuk a kódot:
        </para>
        <programlisting language="java"><![CDATA[
            class SamuCam : public QThread
            {
                Q_OBJECT

            public:
                SamuCam ( std::string videoStream, int width, int height );
                ~SamuCam();

                void openVideoStream();
                void run();

            private:
                std::string videoStream;
                cv::VideoCapture videoCapture;
                int width;
                int height;
                int fps;

            signals:
                void faceChanged ( QImage * );
                void webcamChanged ( QImage * );
            };
            ]]>
          </programlisting>
          <para>
              Az osztály definíció után kapásból látunk egy Q_Objectet ez egy macro. Ugyebár a meta object compiler az ami kezeli a qt-s c++ kiterjesztéseket.
              Ez olvassa el a header fileokat és ha több osztály tartalmazza ezt a macrot akkor előállít egy olyan forrást, amely ezeknek tartalmazza a metaobjektum kódját.
              Egyébként ez a metaobjektum kód szükséges a jel(signal) és a slot mechanizmushoz. Mindemellett a futási időben eldöntött típusinformációkhoz.
          </para>
          <para>
              Ezen kívül láthatjuk, hogy az osztály konstruktora egy stringet vár értékként, amely a kamera ipcíme lesz. Ezen kívül a szélességet és magasságot. Emellett tartalmazza a publik rész a
              futtatáshoz szükséges metódust és a video stream megnyitásának metódusát. Privateban fontos az ip cím és a cv::VideoCapture, amely inicializálja a kamerát, vagyis meghívja a konstruktorát ennek az osztálynak.
              Az fps-t is tároljuk a kiiratáshoz. Emellett egy érdekesség a signals láthatóság, ami azt figyeli történt -e változás. Megváltozott -e a kép vagy a másik metódus, amely a kamerát figyeli.
          </para>
          <para>
              Nézzük most a cpp és a main file-t. 
          </para>
          <programlisting language="java"><![CDATA[
            std::string videoStream = parser.value ( webcamipOption ).toStdString();

            SamuLife samulife ( videoStream, 176, 144 ); 
            ]]>
          </programlisting>
          <para>
              Itt láthatjuk az osztály példányosítását.
          </para>
          <programlisting language="java"><![CDATA[
            SamuCam::SamuCam ( std::string videoStream, int width = 176, int height = 144 )
            : videoStream ( videoStream ), width ( width ), height ( height )
            {
            openVideoStream();
            }

            ]]>
          </programlisting>
          <para>
              Na akkor kezdjük vizsgálni a cpp-t. Itt látható már az inicializált konstruktor. Láthatjuk, hogy rendelkezik paraméter listával ezt a : után írtak foglalják magukba amit átadunk a headerben lévő private-tagoknak.
              És látható, hogy egy metódust hívünk a konstruktor törzsében. A nevéből látható, hogy ezzel nyitjuk meg a video streamot.
          </para>
          <programlisting language="java"><![CDATA[
            void SamuCam::openVideoStream()
            {
            videoCapture.open ( videoStream );

            videoCapture.set ( CV_CAP_PROP_FRAME_WIDTH, width );
            videoCapture.set ( CV_CAP_PROP_FRAME_HEIGHT, height );
            videoCapture.set ( CV_CAP_PROP_FPS, 10 );
            }
            ]]>
          </programlisting>
          <para>
              Az itt inicializált .open még a headerben látott videocapturera vonatkozik. Ezzel nyitja meg a megadott kamerát. Majd beállítjuk
              Az alkalmazás által használt kamera beállításokat szélesség, magasság,fps. Majd nézzük meg a futást.
          </para>
          <programlisting language="java"><![CDATA[
            cv::CascadeClassifier faceClassifier;

            std::string faceXML = "lbpcascade_frontalface.xml"; // https://github.com/Itseez/opencv/tree/master/data/lbpcascades

            if ( !faceClassifier.load ( faceXML ) )
                {
                qDebug() << "error: cannot found" << faceXML.c_str();
                return;
                }
            ]]>
          </programlisting>
          <para>
            Mielőtt megkezdenénk a futást egy cascadeclassifiert hívunk meg, amely képes a képeken objektumokat felismerni. Az észlelt objektum téglalpok egy listájával tér vissza.
            Ennek adjuk át egy arcról készült xml fájlt. Ehhez fogja hasonlítani a mi észlelt arcunkat, hogy képes legyen felismerni.
          </para>
          <programlisting language="java"><![CDATA[
                    while ( videoCapture.isOpened() )
            {

            QThread::msleep ( 50 );
            while ( videoCapture.read ( frame ) )
                {

                if ( !frame.empty() )
                    {

                    cv::resize ( frame, frame, cv::Size ( 176, 144 ), 0, 0, cv::INTER_CUBIC );

                    std::vector<cv::Rect> faces;
                    cv::Mat grayFrame;

                    cv::cvtColor ( frame, grayFrame, cv::COLOR_BGR2GRAY );
                    cv::equalizeHist ( grayFrame, grayFrame );

                    faceClassifier.detectMultiScale ( grayFrame, faces, 1.1, 3, 0, cv::Size ( 60, 60 ) );

                    if ( faces.size() > 0 )
                        {

                        cv::Mat onlyFace = frame ( faces[0] ).clone();

                        QImage* face = new QImage ( onlyFace.data,
                                                    onlyFace.cols,
                                                    onlyFace.rows,
                                                    onlyFace.step,
                                                    QImage::Format_RGB888 );

                        cv::Point x ( faces[0].x-1, faces[0].y-1 );
                        cv::Point y ( faces[0].x + faces[0].width+2, faces[0].y + faces[0].height+2 );
                        cv::rectangle ( frame, x, y, cv::Scalar ( 240, 230, 200 ) );


                        emit  faceChanged ( face );
                        }

                    QImage*  webcam = new QImage ( frame.data,
                                                    frame.cols,
                                                    frame.rows,
                                                    frame.step,
                                                    QImage::Format_RGB888 );

                    emit  webcamChanged ( webcam );

                    }

                QThread::msleep ( 80 );

                }

            if ( ! videoCapture.isOpened() )
                {
                openVideoStream();
                }

            }
            ]]>
          </programlisting>
          <para>
              A következő ciklusunk addig fut ameddig fut a webkamera szerver tehát adatokat tudunk fogadni tőle. Majd jön egy 50 miliseces késleltetés.
              Majd elkezdjük beolvasni a képkockákat tehát ez addig fut ameddig vannak küldött képkockáink. Ha nem üres képkocka jött be akkor feldolgozzuk.
              Csak az arcra vagyunk kíváncsi tehát csak azt próbáljuk kiszűrni. És ugye a feldolgozott képkockákból egy új képet alkotunk. És az emittel kezeljük azt, ha
              a webkameránk változna. És 80 milisecenként dolgozunk fel egy képkockát.
          </para>
          <figure>
            <title>SamuCam</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/SamuCam.png" scale="30"/>
                    </imageobject>
                </mediaobject>
        </figure>
    </section>
    <section>
        <title>BrainB</title>
        <para>
           Mutassuk be a Qt slot-signal mechanizmust ebben a projektben: https://github.com/nbatfai/esport-
talent-search 
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog1/tree/master/BrainBbench">https://github.com/Savitar97/Prog1/tree/master/BrainBbench</link>               
        </para>
        <para>
            Elméleti téren a BrainB a fájlba írásával kapcsolódik az anyaghoz. Ugyanis amikor letelik az idő a save függvény lefutásával kimenti az eredményünket illetve egy képet.
        </para>
        <para>
            A BrainB benchmark egy felmérés. Amely főleg az mmorpgvel játszó játékosokat képes mérni. Mégpedig azt, hogy mennyire képesek követni a karakterüket a tömegbe. A lényeg,hogy az egérmutatót a karakterünkön samun tartsuk a játék pedig egyre több hőst generál a karakterünk köré és 10 percen keresztül nem szabad elveszteni a karakterünk nyomát.Majd a benchmark ad egy eredményt, amely számosítja a teljesítményét a játékosnak. Ez alapján készíthetünk esetleg egy táblázatot, hogy meghatározzuk sávokban is a pontszámokat, így megtudjuk ki a jobb képességű.A moba területen is hasznos lehet a játék ugyanis a teamfightokban a sok effekt között könnyen eveszíthetjük a karakterünket vagy épp a focusolandó enemy játékosét.
            Ezzel a programmal lehetséges, mérni az egyén teljesítőképességét és kiválogatni azokat akik sokkal jobbak az átlagtól és akár a csapatok meghatározhatnának egy minimális pontszámot, amit elkell érni a jelentkezéshez.Viszont a 10 perc szerintem elég sok idő. Mármint jó a koncentráció képességet próbára tesszük. De akkor is elég unalmas végig ülni, amíg a teszt lefut.
        </para>            
        <para>
            És most beszéljünk kicsit a programról a BrainBThread.cpp-ben hozzuk létre a hős osztályunkat és itt hozzuk létre(deklaráljuk) a hősünket Samut.A hős osztály konstruktorában. A mozgását az ablakban randommal számoljuk. A Qthread-ban határozzuk meg az eventeket.Ilyen  a pause. És magát, hogy a hőst hogyan jelnítse meg, hogy írja ki a nevét stb.A BrainBWin-ben vannak meghatározva a presd eventek vagyis, hogy az egérgomb levan -e nyomva vagy nincs és hogy az S el mentse el az eredményt a P-vel pause-oljon az ESC-el vagy Q-val pedig lépjen ki.Ha az egérgombot lenyomjuk akkor kezdődik a mérés.Az ifben vizsgáljuk, hogy az egér a hősünkön van -e ha igen akkor létrehozunk egy new entropyt ez a incCompban van a BrainBThread.h-ban és növeljük a hősünk agilityjét 2 vel ha nincs rajta akkor kiszedünk a vektorból egy entropyt és csökkentjük a hősünk agilityjét.
        </para>
        <para>
            Most pedig jöhet maga a slot signal mechanizmus. A slot-signal mechanizmussal az előző samucamos feladatban is találkoztunk. A signal mechanizmust megint az osztályoknál kell keresni a Q_Objectet, ami egy meta.
            Ugyebár a meta object compiler az ami kezeli a qt-s c++ kiterjesztéseket.
            Ez olvassa el a header fileokat és ha több osztály tartalmazza ezt a macrot akkor előállít egy olyan forrást, amely ezeknek tartalmazza a metaobjektum kódját.
            Egyébként ez a metaobjektum kód szükséges a jel(signal) és a slot mechanizmushoz. Mindemellett a futási időben eldöntött típusinformációkhoz.
            Most a signaloknál 2 függényt találunk:
        </para>
        <programlisting language="java"><![CDATA[
            void heroesChanged ( const QImage &image, const int &x, const int &y );
            void endAndStats ( const int &t );
            ]]>
          </programlisting>
          <para>
              A metódus nevekből már következtethetünk, hogy mikor fognak lefutni ezek a signalok. Az első ugyebár az objektumok mozgásakor azaz amikor az entropyk koordinátája változik.
              A másodikban pedig az eredmény kiiratására a futás végén. De nézzük meg a cpp-ben ezek hívására. Ha signalt hívunk akkor az emit kulcsszót fogjuk alkalmazni így könnyen kikereshető.
          </para>
          <para>
              A heroesChanged-et a thread headerben találjuk a kirajzolásnál. Míg az end statot a futtatásnál a thread cpp-ben.
          </para>
          <programlisting language="java"><![CDATA[
            emit heroesChanged ( dest, heroes[0].x, heroes[0].y );
            emit endAndStats ( endTime );

            ]]>
          </programlisting>
          <para>
              A signalok kapcsolása a connect-el történik a slotokhoz. A slotokat akkor kell meghívni ha egy signal bekövetkezik. Ezzel elkerülhetjük, hogy ne kelljen egy másik osztály függvényét meghívni.
            A connecteket a win.cpp-ben találjuk. A signalok és a slotok felépítésének megkell egyezni, ahogy látszik a következő kódcsipetben:
          </para>
          <programlisting language="java"><![CDATA[
            connect ( brainBThread, SIGNAL ( heroesChanged ( QImage, int, int ) ),
                  this, SLOT ( updateHeroes ( QImage, int, int ) ) );

        connect ( brainBThread, SIGNAL ( endAndStats ( int ) ),
                  this, SLOT ( endAndStats ( int ) ) );

            ]]>
          </programlisting>
        <figure>
             <title>BrainB benchmark</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/BrainB.png" scale="30"/>
                </imageobject>
        </mediaobject>
        </figure>
        <para>
            A fenti slot signal mechanizmus már elavult, de még támogatott. De ehelyett már létezik egy újabb, amelynél már lambda kifejezéseket is alkalmazhatunk.
        </para>
        <programlisting language="java"><![CDATA[
            connect(
                sender, &Sender::valueChanged,
                receiver, &Receiver::updateValue
            );
            connect(
                sender, &Sender::valueChanged,
                [=]( const QString &newValue ) { receiver->updateValue( "senderValue", newValue ); }
            );
            ]]>
          </programlisting>
          <para>
              Az új szintaxis előnye, hogy fordítási időben ellenőrzi, hogy létezik -e a slot vagy a signal hozzá. És jelez ha esetleg a QObjectünk hiányzik.
              Az argumentumok már lehetnek típusdefiníciók vagy különböző névterekben definiáltak. Emellett lehetőséget nyújt automatikus típus kasztolásra. Ha ez implicit konverzió.
              Ezen kívül lehetőség van kapcsolni bármilyen tag függvényt a Qobjekthez, nem csak slotokat.
          </para>
  
    </section>
    <section>
        <title>OSM térképre rajzolása 6</title>
        <para>
            Debrecen térképre dobjunk rá cuccokat, ennek mintájára, ahol én az országba helyeztem el a DEAC
hekkereket: https://www.twitch.tv/videos/182262537 (de az OOCWC Java Swinges
megjelenítőjéből:
https://github.com/nbatfai/robocar-emulator/tree/master/justine/rcwin
is
kiindulhatsz, mondjuk az komplexebb, mert ott időfejlődés is van...)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/GPS">https://github.com/Savitar97/Prog2/tree/master/GPS</link>                
        </para>
        <para>
            Megint a streameké a főszerep. Most a gps koordinátákat kell kezelnünk. Bár az android stúdió rengeteg segítő kezet ad hozzá. A samu camhez hasonlóan szintén real life változó adatokkal kell dolgoznunk.
            Csak annyi a különbség, hogy míg ott webkamera képpel dolgoztunk itt csak számokkal.
        </para>
        <para>
            A feladatnál a GPS trackert próbáltam megvalósítani. Ehhez az android stúdiót használtam. Ahol lehetséges Google Maps Activity project létrehozása.
            A feladathoz szükségünk van egy Google Maps Api keyre ezt a google_maps_api.xml fileban található link segítségével igényelhetünk a legkönnyebben.
            Majd az androidmanifest.xml-ben megkell adnunk, a permissionokat. Amik a következők:
        </para>
        <programlisting language="xml"><![CDATA[
            <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
            <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
            <uses-permission android:name="android.permission.INTERNET"/>
            ]]>
          </programlisting>
          <para>
              Mielőtt neki kezdenénk az egésznek nézzük meg az ActivityLifeCycle-t.
          </para>
          <figure>
            <title>Activity life cycle</title>
       <mediaobject>
               <imageobject>
                   <imagedata fileref="img/activity_lifecycle.png" scale="30"/>
               </imageobject>
       </mediaobject>
       </figure>
       <para><link xlink:href="https://developer.android.com/guide/components/activities/activity-lifecycle#java">Forrás innen</link></para>
       <para>
           Innen nekünk az onStop és az onCreate a szükséges. Arról, hogy mit kell ide írnunk a képnél lévő link bővebb információt nyújt azt most nem tárgyalnám.
           Röviden annyi, hogy az onCreatebe írunk minden olyan kódot ami az activity létrehozásához kell. Indító logika stb. Az onStopba írjuk mi történjen amikor leáll az applikáció
           vagy befejezi a futását.
       </para>
       <para>
           Kezdjük a permission kéréséhez a jelenlegi helyzetünkhöz.
       </para>
       <programlisting language="java"><![CDATA[
        if (ActivityCompat.checkSelfPermission(this,
                Manifest.permission.ACCESS_FINE_LOCATION)
                != PackageManager.PERMISSION_GRANTED) {
            // Permission is not granted
            // Should we show an explanation?
            if (ActivityCompat.shouldShowRequestPermissionRationale(this,
                    Manifest.permission.ACCESS_FINE_LOCATION)) {
                // Show an explanation to the user *asynchronously* -- don't block
                // this thread waiting for the user's response! After the user
                // sees the explanation, try again to request the permission.
                Toast.makeText(getApplicationContext(),
                    "Application will not run without location services!", Toast.LENGTH_SHORT).show();
            } else {
                // No explanation needed; request the permission
                ActivityCompat.requestPermissions(this,
                        new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
                        REQUEST_LOCATION_PERMISSION);

                // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an
                // app-defined int constant. The callback method gets the
                // result of the request.
            }
        } else {
            // Permission has already been granted
        }
        ]]>
      </programlisting>
      <para>
          Ugyebár megvizsgáljuk van -e jogosultságunk, hogy elérjük a locationt. Ha nincs akkor kérjük, hogy adja meg az engedélyt a felhasználó.
          Ha nem adta meg az elején akkor elmagyarázzuk miért szükséges az engedély és újra kérjük.
      </para>
      <para>
          Ugyebár az elején meghívtuk a location managert, amely hozzáférét biztosít az eszköz pontos helyéhez. A location listenert használjuk, hogy
          értesítéseket fogadjunk a managertől ha változik a koordináta. Nézzük meg, hogy definiáljuk a location listener.
      </para>
      <programlisting language="java"><![CDATA[
        locationListener = new LocationListener() {
            
            public void onLocationChanged(Location location) {
                LatLng latLng = new LatLng(location.getLatitude(), location.getLongitude());
                if (marker != null){
                    mMap.addPolyline(new PolylineOptions()
                            .add(marker.getPosition(), latLng)
                            .width(10)
                            .color(Color.BLUE));

                    marker.remove();

                    marker = mMap.addMarker(new MarkerOptions().position(latLng).title("MyPosition:" + location.getLatitude() + ":" + location.getLongitude()));
                    mMap.setMaxZoomPreference(30);
                    mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLng, mMap.getCameraPosition().zoom));
                }
                else {
                    marker = mMap.addMarker(new MarkerOptions().position(latLng).title("MyPosition:" + location.getLatitude() + ":" + location.getLongitude()));
                    mMap.setMaxZoomPreference(30);
                    mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLng, 18.0f));
                }
            }

            @Override
            public void onStatusChanged(String provider, int status, Bundle extras) {

            }

            @Override
            public void onProviderEnabled(String provider) {

            }

            @Override
            public void onProviderDisabled(String provider) {

            }
        };
        ]]>
      </programlisting>
      <para>
          Ugyebár mikor meghívjuk a new location listenert a következő ovverride függvény részeket létrehozza. Nekünk az onLocationChangedre van szükségünk
          ugyanis GPS trackert hozunk létre. Létrehozunk egy latitude longitude osztályú objektumot. Ami paraméterként 2 értéket kap a lekérdezett szélességi és hosszúsági fok információkat.
          Majd vizsgáljuk a marker objektumunkat. Ha még nem létezik akkor leteszünk egyet a térképre a jelenlegi szélességi és hosszúsági fokra a térképen.
          Ha már van markunk akkor az if true ága fut le. Azaz létrehozunk egy vonalat a jelenlegi pontig aztán ledobunk egy új markot a vonal végére végülis és ezzel együtt mindig mozgatjuk a kamerát
          a jelenlegi pozíciónkra.
      </para>

    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>  

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Schwarzenegger!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Port scan</title>
        <para>
Mutassunk rá ebben a port szkennelő forrásban a kivételkezelés szerepére!
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#id527287
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/Portscan">https://github.com/Savitar97/Prog2/tree/master/Portscan</link>                  
        </para>
        <para>
            A feladat az volt, mutassunk rá a kivételkezelés szerepére a fenti programban. Ugyebár a kivételkezelés a javaban is try-catch szerkezettel történik.
            Így kapcsolódik az elmélethez is a feladat. A kivételkezelés egy egyedi felhasználási módját láthatjuk.
        </para>
        <programlisting language="java"><![CDATA[
            public static void main(String[] args) {
        
                for(int i=0; i<1024; ++i)
                    
                    try {
                        
                        java.net.Socket socket = new java.net.Socket(args[0], i);
                        
                        System.out.println(i + " figyeli");
                        
                        socket.close();
                        
                    } catch (Exception e) {
                        
                        System.out.println(i + " nem figyeli");
                        
                    }
            }
            ]]>
          </programlisting>
          <para>
              A program argumentumként egy címet vár. Mi localhosttal fogjuk használni. Mivel ez akár a támadható portok felderítésére is alkalmazható lenne.
          </para>
          <figure>
            <title>Port scan</title>
       <mediaobject>
               <imageobject>
                   <imagedata fileref="img/portscan.png" scale="30"/>
               </imageobject>
       </mediaobject>
       </figure>
          <para>
              Végig zongorázzuk 1024 ig a portokat ha sikerül kapcsolatot létrehozni az adott porton akkor ott van egy szerver folyamat. Ekkor lényegében nem csinálunk semmit
              csak bezárjuk a socketet. Ha nem sikerül kapcsolatot létesíteni akkor azt a hibakezelő kapja el. 
          </para>
          <figure>
            <title>Scan Exception</title>
       <mediaobject>
               <imageobject>
                   <imagedata fileref="img/socket.png" scale="30"/>
               </imageobject>
       </mediaobject>
       </figure>
    </section>        

    <section>
        <title>AOP</title>
        <para>
            Szőj bele egy átszövő vonatkozást az első védési programod Java átiratába! (Sztenderd védési
feladat volt korábban.)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/AspectJ">https://github.com/Savitar97/Prog2/tree/master/AspectJ</link>               
        </para>
        <para>
            A feladat az elmélethez a kódgenerálást támogató nyelvi elemmel kapcsolódik. Az aspectj egy aspektus orientált programozási nyelv. Segítségével a programban töréspontokat hozhatunk létre.
            És beszúrhatunk egy adott elem lefutása elé mögé más utasítást,de akár egy függvény tartalmát is kicserélhetjük.
        </para>
        <para>
            A feladat elkezdéséhez telepítenünk kell az aspect j-t. Ubuntun ezt a következőképpen tudjuk megcsinálni: <command>sudo apt install aspectj</command>.
            Majd a következő paranccsal kell fordítanunk:<command>ajc LZWBinFa.java Aspect.aj</command>.Az aspect előnye annyi, hogy úgy írhatunk a kódunkba,hogy lényegébe abba nem kell belenyúlnunk.
            Emellett a nyomkövetést is segíti. Számomra elég bonyolultnak tűnt a használata főleg ha már osztályból kellett adatot kiszedni. Egy másfajta szemléletmódot igényel szerintem. Néhány alap fogalom
            A csatlakozási pont vagy joint pont egy olyan pont a programban amikor valami történik. Ilyen például amikor egy metódus meghívódik vagy egy kivételt throwolunk,inicializálunk egy objektumot stb.
            A pointcutnak van egy jobb és bal oldala kettőspont választja el a kettőt.Bal oldalon a pointcut neve és paraméterei állnak. Az paraméterekben az elérhető adatokhoz férhetünk hozzá ha lefut a metódus.
            A jobboldalt maga a pointcut szerepel. Ez általában a call vagy az execution. Ebben írjuk meg, hogy mire utal a pointcut a valódi osztályunkban.
        </para>
        <para>
            Advice-ok lényegében a before, after és around. Tehát, hogy a metódus hívása előtt,után vagy közben esetleg helyett fusson le. A within paranccsal mondhatjuk meg,hogy melyik osztályból akarjuk használni.
            A target az a java objektum ami a metódust hívja.Argumentumok azok az értékek amiket a metódusban hívunk.
        </para>
        <programlisting language="java"><![CDATA[
            private long egyes = 0;
            private long nullas = 0;
            pointcut pushback() : execution(public void push_back(char));
            before(char ch): pushback() && args(ch){
            if(ch == '1'){
            egyes++;
            } else {
            nullas++;
            }
            }
            pointcut main() : execution(public static void main(String[]));
            after() : main(){
            System.out.println("Egyesek száma: " + egyes);
            System.out.println("Nullások száma: " + nullas);
            }
            ]]>
          </programlisting>
          <para>
              Vegyük elsőnek példának az egyesek és nullások megszámlálását. Ugyebár deklarálunk és inicializálunk 2 változót amibe majd tároljuk
              a megszámolt értékeket. Aztán jön a pointcutunk aminek a neve pushback lesz. A jobb oldala maga a point cut. Tehát oda tesszük a pointcutot 
              ahol lefut a fő program push_back(char) függvénye. Aztán mielőtt ez lefut az argumentum karakterjét átadjuk és megnézzük egyes-e vagy nulla.
              Majd létrehozunk egy új pointcutot a mainre. És megmondjuk, hogy miután lefut a main írjuk ki a megszámol egyesek és nullások számát.
          </para>
          <para>
              Most nézzük meg a kiir függvényre való pointcut-unkat:
          </para>
          <programlisting language="java"><![CDATA[
            public pointcut meghiv(LZWBinFa.Csomopont n, PrintWriter os) 
            : call(void LZWBinFa.kiir(LZWBinFa.Csomopont, PrintWriter)) && args(n,os);
            
            after(LZWBinFa.Csomopont n, PrintWriter os) : meghiv(n, os)
            {   
                

                try{
                os=new PrintWriter("preorder.txt");
                preOrder(n,os);
                os.flush();
                }
                catch (FileNotFoundException e) {
                    e.printStackTrace();
                }
                
                depth = 0;
                try{
                os=new PrintWriter("postorder.txt");
                postOrder(n,os);
                os.flush();
                
                }
                catch (FileNotFoundException e) {
                    e.printStackTrace();
                }
                

            }
            
            
            public void preOrder(LZWBinFa.Csomopont n, PrintWriter p) 
            {

                if (n != null)
                {

                    ++depth;
                    for (int i = 0; i < depth; ++i)
                    p.print("---");
                    p.print(n.getBetu () + "(" + depth + ")\n");
                    preOrder (n.getBalNulla (), p);
                    preOrder (n.getJobbEgy (), p);
                    --depth;
                }
            }
            public void postOrder(LZWBinFa.Csomopont n, PrintWriter p) 
            {
                if (n != null)
                {
                    
                    ++depth;
                    postOrder (n.getBalNulla (), p);
                    postOrder (n.getJobbEgy (), p);
                    for (int i = 0; i < depth; ++i)
                        p.print("---");
                    p.print(n.getBetu () + "(" + depth + ")\n");
                    --depth;
                }
            }
            ]]>
          </programlisting>
          <para>
              Na itt a pointcutunkat a kiir függvény hívására tesszük.Argumentumként átvesszük a printwriter és a csomópont n-t.
              Aztán a már megszokott pre és post order bejárásunkat láthatjuk függvényként ez bevprogról már ismerős volt. Ugyebár alapból
              inorder-ben iratjuk ki. Aztán megmondjuk, hogy minden egyes kiir hívás után hajtódjon végre a másik két kiir függvény is.
              Fontos a try-catch szerkezet máskülönben errort kapunk, hogy nincs ami elkapja az exceptiont. Emellett nagyon fontos szerepet játszik
              még az, hogy 2 FileWriter os-t hozok létre. És mind a 2-t flush-ölöm.Ugyebár a flush a bufferben lévő stringet azonnal kiírja.
          </para>
          <figure>
            <title>Pre-post-inorder AspectJ-vel</title>
       <mediaobject>
               <imageobject>
                   <imagedata fileref="img/AspectPreInPost.png" scale="30"/>
               </imageobject>
       </mediaobject>
       </figure>
    </section>        
    <section>
                <title>Android Játék</title>
                <para>
                    Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/PoroSpin">https://github.com/Savitar97/Prog2/tree/master/PoroSpin</link>  
                </para>
                <para>Írjunk egy egyszerű Androidos „játékot”! Építkezzünk például a 2. hét „Helló, Android!” feladatára!</para>
                <para>
                    Androidos játéknak egy üvegpörgetős játékot csináltam kicsit átalakítva a vizualizációt.
                </para>
                <para>
                    Elsőként a felhasznált backgroundot és a képet amit majd pörgetek bele kellett másolnom a drawable-ba. Majd az activity_main.xmlben módosítani a backgroundot és felvenni az image-t.
                </para>
                <programlisting language="java"><![CDATA[
                    <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                    xmlns:tools="http://schemas.android.com/tools"
                    android:layout_width="match_parent"
                    android:layout_height="match_parent"
                    android:background="@drawable/background"
                    tools:context=".MainActivity">

                    <ImageView
                        android:id="@+id/yasu"
                        android:layout_width="800dp"
                        android:layout_height="800dp"
                        android:src="@drawable/yas"
                        android:layout_centerInParent="true"
                        android:onClick="spinToWin"
                        />
                    ]]>
                  </programlisting>
                  <para>
                      Itt ami lényeg nekünk azt a +id amivel hivatkozhatunk majd erre az image-re. És az onClick. Mivel
                      ez fog hivatkozni a pörgetés függvényre.
                  </para>
                  <programlisting language="java"><![CDATA[
                    private ImageView yasuo;
                    private Random random = new Random();
                    private int lastDir;
                    private boolean spinning;

                    @Override
                    protected void onCreate(Bundle savedInstanceState) {
                        super.onCreate(savedInstanceState);
                        setContentView(R.layout.activity_main);

                        yasuo = findViewById(R.id.yasu);
                    }
                    ]]>
                  </programlisting>
                  <para>
                      Kezdetben felvesszük a szükséges változókat. Majd az onCreateben beállítjuk a view-ot. És az imageview-nak a findViewById átadjuk a kép id-ját.
                      Ezért volt nagyon lényeges nekünk az id.
                  </para>
                  <programlisting language="java"><![CDATA[
                    public void spinToWin(View v) {
                        if (!spinning) {
                            int newDir = random.nextInt(3600);
                            float pivotX = yasuo.getWidth() / 2;
                            float pivotY = yasuo.getHeight() / 2;
                
                            Animation rotate = new RotateAnimation(lastDir, newDir, pivotX, pivotY);
                            rotate.setDuration(2500);
                            rotate.setFillAfter(true);
                            rotate.setAnimationListener(new Animation.AnimationListener() {
                                @Override
                                public void onAnimationStart(Animation animation) {
                                    spinning = true;
                                }
                
                                @Override
                                public void onAnimationEnd(Animation animation) {
                                    spinning = false;
                                }
                
                                @Override
                                public void onAnimationRepeat(Animation animation) {
                
                                }
                            });
                
                            lastDir = newDir;
                            yasuo.startAnimation(rotate);
                        }
                    }
                    ]]>
                  </programlisting>
                  <para>
                      Majd jön a függvény amivel pörgetjük az onClick-re. Ugyebár meghívunk egy rotate animation-t. Mert meg akarjuk forgatni.
                      Az új irányt randommal adjuk meg 3600 al számolunk mert azt akarjuk, hogy esetleg többször is körbe tudjon fordulni. A duration-el adjuk meg, hogy mennyi ideig tartson az animáció millisecben.
                      A fill after azt adja meg, hogy az animáció transzformációja az animáció befejeztével történjen. A pivot az az x,y tengely. Majd az animáció listenerben az animáció kezdeténél
                      a forgást true-ra állítjuk. A végeztével false-oljuk. Aztán ugyebár az előző szögnek átadjuk az új szöget.
                  </para>
                  <figure>
                        <title>PoroSpin</title>
                   <mediaobject>
                           <imageobject>
                               <imagedata fileref="img/porospin.jpg" scale="50"/>
                           </imageobject>
                   </mediaobject>
                   </figure>
                  <para>Képek forrása:</para>
                  <para>
                       <link xlink:href="https://en.wikipedia.org/wiki/Thrash_Zone">https://en.wikipedia.org/wiki/Thrash_Zone</link>
                  </para>
                  <para><link xlink:href="https://www.pngkit.com/view/u2t4i1o0y3u2t4t4_project-yasuo-png-league-of-legends-yasuo-pixel/">https://www.pngkit.com/view/u2t4i1o0y3u2t4t4_project-yasuo-png-league-of-legends-yasuo-pixel/</link></para>
        </section>
        <section>
        <title>Junit teszt</title>
        <para>
            A https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat
poszt kézzel számított mélységét és szórását dolgozd be egy Junit tesztbe (sztenderd védési feladat
volt korábban).
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Savitar97/Prog2/tree/master/JavaApplication3">https://github.com/Savitar97/Prog2/tree/master/JavaApplication3</link>              
        </para>
        
        <para>
            A feladat az volt, hogy kézzel számoljuk ki a binfának a szórását, mélységét. Az elmélethez a hibakezelés révén kapcsolódik. Megadhatjuk a várt értékeinket és teszt értékekkel futtathatunk függvényeket a kódunkból. Ezáltal ellenőrizve annak helyes működését.
        </para>
        <para>
            A gép által számított értékek a következők:
        </para>
        <figure>
                <title>Gép által számított értékek</title>
           <mediaobject>
                   <imageobject>
                       <imagedata fileref="img/JunitTeszt.png" scale="30"/>
                   </imageobject>
           </mediaobject>
           </figure>
           <para>
               Majd az általam számított értékek: 
           </para>
           <figure>
                <title>Kézzel számolt értékek</title>
           <mediaobject>
                   <imageobject>
                       <imagedata fileref="img/Junitkezzel.jpg" scale="30"/>
                   </imageobject>
           </mediaobject>
           </figure>
           <para>
               És most tesztelés Junittal.
           </para>
           <programlisting language="java"><![CDATA[
            public class LZWBinFaTest {
                LZWBinFa binfa = new LZWBinFa();
                
                String str = "0111100101100";
                
                @Test
                public void atlagTest() {
                    for(int i = 0; i < str.length(); i++){
                        binfa.push_back(str.charAt(i));
                    }
                    double atlag = binfa.getAtlag();
                    assertEquals(2.25, atlag, 0.001);
                }
                @Test
                public void szorasTest() {
                    for(int i = 0; i < str.length(); i++){
                        binfa.push_back(str.charAt(i));
                    }
                    double szoras = binfa.getSzoras();
                    assertEquals(0.5, szoras, 0.001);
                }
                @Test
                public void melysegTest() {
                    for(int i = 0; i < str.length(); i++){
                    binfa.push_back(str.charAt(i));
                    }
                    double melyseg = binfa.getMelyseg();
                    assertEquals(3, melyseg, 0.001);
                }
            }
            ]]>
          </programlisting>
          <para>
              Ugyebár a stringben megadjuk a bitsorozatot amit várunk. Majd ezt bitenként minden tesztben feldolgozzuk.
              Az assertEqual függvényben megadjuk a várt értéket és átadjuk a program által kiszámolt értéket. Az utolsó érték
              az eltérést adja meg ez természetesen a kerekítésből fakadhat.
          </para>
          <figure>
            <title>Junittal teszt</title>
       <mediaobject>
               <imageobject>
                   <imagedata fileref="img/JunitTESZT.png" scale="30"/>
               </imageobject>
       </mediaobject>
       </figure>
  
    </section>
    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Calvin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>MNIST</title>
        <para>Az alap feladat megoldása, +saját kézzel rajzolt képet is ismerjen fel,
https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol Háttérként ezt vetítsük le:
https://prezi.com/0u8ncvvoabcr/no-programming-programming/
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/j7f9SkJR3oc">https://youtu.be/j7f9SkJR3oc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0">https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0</link> (/tensorflow-0.9.0/tensorflow/examples/tutorials/mnist/), <link xlink:href="https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol">https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol</link>  
        </para>
        <para>
            <link xlink:href="https://github.com/Savitar97/Prog1/blob/master/tensorflow/twicetwo.py">https://github.com/Savitar97/Prog1/blob/master/tensorflow/twicetwo.py</link>
        </para>
        <para>
            Felhasznált irodalom:<link xlink:href="http://biointelligence.hu/pdf/tf_bkp.pdf">http://biointelligence.hu/pdf/tf_bkp.pdf</link>
        </para>
        <para>
           A tensorflowot a google készítette és fejleszti a gépi tanulást segíti, a tervezésben a fejlesztésben és a tanulmányozásban használják főként mivel készít adatáramlási gráfot, amelyben a node-ok a matematikai műveletek és az élek az áramló adatok. A tensorflow-ot import tensorflow ként hívjuk meg. A readimg függvény beolvassa a kép file-t majd dekódolja erre a későbbiekben lesz szükség.A program lényege, hogy a megadott képen szereplő számot felismerje.Ehhez megkell tanítanunk a programunkat. Tehát elsőnek készítünk egy modelt.Majd ezen gyakoroltassuk a programunkat. Majd futtatunk egy teszt kört ahol a program kiirja a becsült pontosságát. Ezután a 42 es tesztkép felismerése következik. Majd végül a beolvasott képünkön teszteljük a program működését.
           A tesztnél a program súlyokat használ ami a W változó, ezzel dönti el a súlyokat,amely alapján dönt hogy benne van -e a kép amit megadtunk a jó halmazban. Az x változó jelenti a bemenő értéket míg az y a számított kimenő érték. Ez hasonló mint a már átvett perceptron és neurális and or xor kapu. A súlyokkal mindig szorzunk a b mint bias mindig egy konstans érték. A tanulási folyamat is a neurális and or xor kapuhoz hasonló, ugyan úgy vannak hidden rétegek és nekik vannak node-jai. X a példa és Y a várt eredmény. A tanulánál ugyan úgy iterációs határt számolunk. Az Y értékét úgy számoljuk mintha egy egyenes egyenletét írnánk fel az Y= x*a súlyjal ami a W és hozzá adjuk a b-t ami a kostants.
           </para>
           <programlisting><![CDATA[
            y = tf.matmul(x, W) + b
       ]]>
        </programlisting>
            <para>
            Ez az egyenes az ami elválasztja a jó megoldásokat a rosszaktól. Vagyis amelyik teljesíti a feltételt és megközelítőleg helyes értéket ad.
            Itt a feladatunkban az elfogadási arányt(iterációs határ,gradient) 50% nál húztuk meg tehát a program hibázhat. A pontosságot minél több hidden réteggel és noda-al tudjuk növelni. Tehát az egész egy valószínűségi értéket figyel ha megüti a meghatározott küszöböt ez az érték és a hiba mértéke kevés akkor a program elfogadja mint megoldást. A programmal 28*28 pixeles képekről döntjük el, hogy milyen szám szerepel a képen. A y_ a loss-t definiáljuk, amely azt számolja,hogy mennyire térünk el a a várt eredményünktől. A GradientDescentOptimizer deriváltakat számít a hibahatárok figyelembe vételével. Ez a minimize.
                
            </para>
            <figure>
             <title>Softmax mnist</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/Softmax.png" scale="30"/>
                </imageobject>
        </mediaobject>
            </figure>
            <para>Az mnistes feladatok úgy kapcsolódnak az elmélethez, hogy összefolyik a python és mnistes paradigma tehát multi paradigmákat használunk bennük. A Malmö hasonló cipőben evez.</para>
    </section>        

    <section>
        <title>Deep MNIST</title>
        <para>
         Mint az előző, de a mély változattal. Segítő ábra, vesd össze a forráskóddal a
https://arato.inf.unideb.hu/batfai.norbert/NEMESPOR/DE/denbatfai2.pdf 8. fóliáját!   
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Savitar97/Prog2/tree/master/tensor">https://github.com/Savitar97/Prog2/tree/master/tensor</link>               
        </para>
        <para>
            Ez nagyon hasonló az előzőhöz. Csak bonyolódik a számítás és nő az iterációk száma. 1000ről 20000-re.A deep mnist forrása szintén a 
            tensorflow git repóban található mégpedig <link xlink:href="https://github.com/tensorflow/tensorflow/blob/r1.4/tensorflow/examples/tutorials/mnist/mnist_deep.py">itt</link>. 
        </para>
        <para>
            A képfeldolgozást átvesszük a soft mnistből. 
        </para>
        <programlisting language="java"><![CDATA[
            def readimg():
            file = tf.read_file("sajat8a.png")
            img = tf.image.decode_png(file, 1)
            return img
            ]]>
          </programlisting>
          <para>
              Ugyebár a readfile-al beolvassuk a képünket majd az img-nek átadjuk dekódolva. Az 1 itt azt jelenti ,hogy az output grayscale img-lesz.
              Majd a függvényünk visszaadja a dekódolt képet.
          </para>
          <para>
              A függvény meghívása a mainben történik.
          </para>
          <programlisting language="java"><![CDATA[
            img = readimg()
            image = img.eval()
            image = image.reshape(28*28)
            matplotlib.pyplot.imshow(image.reshape(28, 28), cmap=matplotlib.pyplot.cm.binary)
            matplotlib.pyplot.savefig("8.png")
            matplotlib.pyplot.show()
            classification = sess.run(tf.argmax(y_conv, 1), feed_dict={x: [image], keep_prob: 1.0})
            print("-- Ezt a halozat ennek ismeri fel: ", classification[0])
            ]]>
          </programlisting>
          <para>
              Ugyebár a readimgből kapott grayscalet az eval funkcióval hívjuk meg. Ez kikalkulálja a visszakapott értékből az új képet.
              Ezt átméretezzük a reshape-el. Majd megmutatjuk a képet. És kimentjük a megadott néven. A classification-el választjuk ki a legjobban passzoló értéket. Vagyis
              azt a képet amit valószínűleg a miénk ábrázol.
          </para>
          <para>
              De lássuk az eredményt. Mondjuk elfelejtettem kiiratni elsőnek a classification-t. Viszont azon is látszik, hogy a számítások itt már bonyolódnak mivel a tanítási idő kb 30-40 percet vesz igénybe.
              Talán még többet is. 
          </para>
          <figure>
            <title>Deep mnist</title>
       <mediaobject>
               <imageobject>
                   <imagedata fileref="img/deepmnist.png" scale="30"/>
               </imageobject>
       </mediaobject>
           </figure>
        <para>
            A feladat megértéséhez találtam egy nagyon jó weboldal linket ami vizuálisan jeleníti meg az egészet szerintem nagyon hasznos és látványos.
            A linket erről <link xlink:href="http://scs.ryerson.ca/~aharley/vis/conv/">Itt</link> találjátok.
        </para>
        <figure>
            <title>Deep mnist viz</title>
       <mediaobject>
               <imageobject>
                   <imagedata fileref="img/deepviz.png" scale="150"/>
               </imageobject>
       </mediaobject>
           </figure>
           <figure>
            <title>Deep mnist viz1</title>
       <mediaobject>
               <imageobject>
                   <imagedata fileref="img/deepviz1.png" scale="150"/>
               </imageobject>
       </mediaobject>
           </figure>
           <para>
               Az oldalon bal oldalt a menüben tudjuk kapcsolgatni a rétegeket.
           </para>
           <para>
               Az első képen legalul található az input réteg. A kép amit megadunk. Amit követ egy CNN Convolutional layer. Ez egy matematikai műveletre a convolution-ra utal.
               Ez csak annyit jelent,hogy a szimpla mátrix szorzást ez a konvolúció helyettesíti. Ez a konvolúció annyit csinál, hogy 2 függvényből létrehoz egy 3.-at. Így lesz az egy képünkből 6 db.
               Ugyanis megnézi mitörténik ha egyik függvényt a másik mellé teszi. Mi lesz ha csak érintik egymást vagy a kettő egybe van. Majd ezt követi egy downsampling layer ami lényegében megcsinálja ennek a képnek a kicsinyített változatát.
               Aztán jön egy újabb konvolúciós réteg. Észrevehető, hogy a 2. konvolúciónál már a 6-ból 16 példány keletkezett.  Ezt újra átméretezzük. Majd ebből megszületik az első teljesen összekapcsolt réteg. Ami már csak egy dimenziós tömb. Aztán ebből csinálunk egy újabb 
               teljesen összekapcsolt réteget. Ebből a rétegből pedig már képesek vagyunk megmondani az eredményt. Tehát ebből lesz egy tömb ami a lehetséges kimeneteket tartalmazza. Itt például 0-9 ig a számok. Látható, hogy az ábrán is a legnagyobb értékűt kapjuk vissza.
               A kódunkban ez lesz a classification[0]. Ezen kívül megfigyelhető,hogy a program lényegében azzal dönti el, hogy mi tartozik az elfogadó pixelbe, hogy számítások végeredménye pozitív vagy negatív lett.
           </para>
           <figure>
            <title>Deepmnist eredmény</title>
       <mediaobject>
               <imageobject>
                   <imagedata fileref="img/deepout.png" scale="150"/>
               </imageobject>
       </mediaobject>
           </figure>
    </section>        
    <section>
        <title>Android telefonra a TF objektum detektálója</title>
        <para>
            Telepítsük fel, próbáljuk ki!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A feladat az volt, hogy töltsük le a tensorflow-os demo-t telefontra.Ezt a gitubjukon találjuk: <link xlink:href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android">Itt!</link>.
            Hát látható, hogy sötétben elég pontatlan. Vicces eredmények születtek. Például szinte mindenre rámondta, hogy az bizony egy macska.
            Még a számítógépes egér perifériára is.Mind a 4 modult kipróbáltam a speech nem ismert fel semmilyen hangot. Az stylizer hát elég érdekes világnézetet ad.
            A Classify és a detectről pedig lent láthatók a képek. A felélesztés viszont könnyen ment android stúdióba új létező projektként behúztam aztán a telefonomat használtam emulátorként.

        </para>
        <para>
            Kipróbálva:
        </para>
        <figure>
            <title>Teszt1</title>
            <mediaobject>
               <imageobject>
                   <imagedata fileref="img/teszt1.jpg" scale="30"/>
               </imageobject>
       </mediaobject>
       </figure>
       <figure>
        <title>Teszt2</title>
        <mediaobject>
           <imageobject>
               <imagedata fileref="img/teszt2.jpg" scale="30"/>
           </imageobject>
   </mediaobject>
   </figure>
   <figure>
    <title>Teszt3</title>
    <mediaobject>
       <imageobject>
           <imagedata fileref="img/teszt3.jpg" scale="30"/>
       </imageobject>
</mediaobject>
</figure>
<figure>
    <title>Teszt4</title>
    <mediaobject>
       <imageobject>
           <imagedata fileref="img/teszt4.jpg" scale="30"/>
       </imageobject>
</mediaobject>
</figure>
<figure>
    <title>Teszt5</title>
    <mediaobject>
       <imageobject>
           <imagedata fileref="img/teszt5.jpg" scale="30"/>
       </imageobject>
</mediaobject>
</figure>
    </section>
    <section>
        <title>SMNIST for Machines</title>
        <para>
            Készíts saját modellt, vagy használj meglévőt, lásd: https://arxiv.org/abs/1906.12213
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
    <section>
        <title>Minecraft MALMO-s példa</title>
        <para>
            A https://github.com/Microsoft/malmo felhasználásával egy ágens példa, lásd pl.:
https://youtu.be/bAPSu3Rndi8, https://bhaxor.blog.hu/2018/11/29/eddig_csaltunk_de_innentol_mi,
https://bhaxor.blog.hu/2018/10/28/minecraft_steve_szemuvege
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/bAPSu3Rndi8">https://youtu.be/bAPSu3Rndi8</link>      
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Microsoft/malmo">https://github.com/Microsoft/malmo</link>                
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://microsoft.github.io/malmo/0.17.0/Python_Examples/Tutorial.pdf">https://microsoft.github.io/malmo/0.17.0/Python_Examples/Tutorial.pdf</link>                
        </para>
        <para>
            Valószínűleg sokan ismerik a MineCraft játékot a kockákból álló világ melynek a főszereplője Steve. A program lényege,hogy Steve egy megadott időintervallumon belül ne akadjon el semmiben. Tehát képes legyen kikerülni a mozgását blokkoló akadályokat.Ezt úgy értük el hogy a steve körül lévő 26 kockát vizsgáljuk mivel ő áll a közepén. Ha nincs szabad út előtt megpróbálja kikerülni ha nem lehetséges akkor ugrik.Azt, hogy épp milyen objektum van Steve előtt a program jelzi. A forgásszámláló counter 8-ban lett meghatározva. Steve egyenesen előre halad mindaddig, amíg valamilyen akadályba nem ütközik. Akadályok lehetnek a víz,levegő,növényzet. A program futása során számoljuk az akadályokat és kiirjuk, hogy steve előtt éppen milyen objektum van.Az akadályok elkerülésének lehetőségei az ugrás, a kitérés vagy az akadály elpusztítása. Az elpusztítás akkor lehet jó lehetőség ha 2 blokk magas fal veszi körül Stevet mert azt már nem tudja átugrani. A programba a cselekvési utasításokat a while world state is mission running ba kell beleírnunk. Az agent alapvető utasításai attack,move,turn,jump,stafe,use ezeknek argumentumként a sebességet adjuk meg 1 a max sebesség tehát 0 és 1 között adhatunk meg argumentumként neki értéket.
        </para>
        <para>
            Sajnos a gyenge gépem miatt a futtatás eléggé haldoklott. De a telepítése az egésznek eléggé egyszerű letöltjük a Malmo-0.37.0-Linux-Ubuntu-18.04-64bit_withBoost_Python3.6 ezt <link xlink:href="https://github.com/Microsoft/malmo/releases">innen</link> tudjuk megtenni.Ezután kicsomagoljuk a főkönyvtárunkba. 
         </para>
         <para>
             Szükségünk van még a következőkre: <command>sudo apt-get install libboost-all-dev libpython3.5 openjdk-8-jdk ffmpeg python-tk python-imaging-tk</command>
             </para>
          <para>
              Majd bemegyünk a malmö mappájába ott megkeressük a Minecraft mappát és ott futtatjuk a <command>./launchClient.sh</command>-t
          </para>
          <para>
              Valószínűleg szükséges lesz kiadni a terminálba egy <command>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/</command> és egy <command>export MALMO_XSD_PATH=~/MalmoPlatform/Schemas</command> parancsot a futtatáshoz.
            </para>
          <para>
              Ez megfog nyitni egy MineCraft játék ablakot. Ezután nyitunk egy újabb terminált és megkeressük a python exmaples-t. És itt tudjuk futtatni a mintákat és ha csinálunk saját küldetést szintén ide kell betennünk. Ha esetleg problémák lennének a futtatással érdemes megnézni, hogy a 10000-res portot nem -e használja más alkalmazás mivel alapértelmezetten ezt használja a malmö. Ha esetleg ütközés lenne a run_mission.py ba megkeressük a client infot is itt tudjuk átírni.
          </para>
          <para>
              Ha fut a küldetésünk az f3-al tudunk bővebb információt kapni például memória használat milyen blokk van előttünk milyen irányba nézünk stb.
          </para>
          <para>Minta egy küldetéses xml-re ahol az időt, a játékmódot, küldetés kezdetén a chatre kiirt szöveget stb-t tudjuk beállítani.</para>
          <programlisting language="xml"><![CDATA[
       missionXML='''<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
            <Mission xmlns="http://ProjectMalmo.microsoft.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
            
              <About>
                <Summary>Misszió leírás</Summary>
              </About>
              
              <ServerSection>
                <ServerHandlers>
                  <FlatWorldGenerator generatorString="3;7,220*1,5*3,2;3;,biome_1"/>
                  <ServerQuitFromTimeUp timeLimitMs="50000"/> //itt állíthatjuk be az időt
                  <ServerQuitWhenAnyAgentFinishes/>
                </ServerHandlers>
              </ServerSection>
              
              <AgentSection mode="Survival">
                <Name>QuitBot</Name>
                <AgentStart/>
                <AgentHandlers>
                  <ObservationFromFullStats/>
                  <ContinuousMovementCommands turnSpeedDegs="180"/>
                  <ChatCommands />
                  <MissionQuitCommands quitDescription="give_up"/>
                  <RewardForMissionEnd>
                    <Reward description="give_up" reward="-1000"/>
                  </RewardForMissionEnd>''' + malmoutils.get_video_xml(agent_host) + '''
                </AgentHandlers>
              </AgentSection>
            </Mission>'''
       ]]>
        </programlisting>
        <para>Egy újabb példa az agent-nek kiadott parancsokhoz</para>
        <programlisting language="python"><![CDATA[
       while world_state.is_mission_running:
    print(".", end="")
    time.sleep(0.5)
    count += 1
    world_state = agent_host.getWorldState()
    for error in world_state.errors:
        print("Error:",error.text)
    for reward in world_state.rewards:
        print("Reward:",reward.getValue())
    agent_host.sendCommand("attack 1")
    agent_host.sendCommand("move 1")
    agent_host.sendCommand("jump 1")
print()
print("Mission ended")
       ]]>
        </programlisting>
        <para>Az agent host gondoskodik a cselekvések elvégzéséről.</para>
     <mediaobject>
                <imageobject>
                    <imagedata fileref="img/malmo.png" scale="30"/>
                </imageobject>
        </mediaobject>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/malmo1.png" scale="30"/>
                </imageobject>
        </mediaobject>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>
</part>                                                              


    <bibliography xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Irodalomjegyzék</title>
    <bibliodiv>
        <title>Általános</title>
        <biblioentry xml:lang="hu">
            <abbrev>MARX</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>György</firstname>
                        <surname>Marx</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Gyorsuló idő</title>
            <publisher>
                <publishername>
                    Typotex
                </publishername>
            </publisher>
            <pubdate>2005</pubdate>
        </biblioentry>  
    </bibliodiv> 
    <bibliodiv>
        <title>C</title>
        <biblioentry>
            <abbrev>KERNIGHANRITCHIE</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Brian W.</firstname>
                        <surname>Kernighan</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Dennis M.</firstname>
                        <surname>Ritchie</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>A C programozási nyelv</title>
            <publisher>
                <publishername>Bp., Műszaki</publishername>
            </publisher>
            <pubdate>1993</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>C++</title>
        <biblioentry>
            <abbrev>BMECPP</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Zoltán</firstname>
                        <surname>Benedek</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Tihamér</firstname>
                        <surname>Levendovszky</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Szoftverfejlesztés C++ nyelven</title>
            <publisher>
                <publishername>Bp., Szak Kiadó</publishername>
            </publisher>
            <pubdate>2013</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>Lisp</title>
        <biblioentry>
            <abbrev>METAMATH</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Gregory</firstname>
                        <surname>Chaitin</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>META MATH! The Quest for Omega</title>
            <publisher>
                <publishername>
                    <link xlink:href="http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf">http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf</link>
                </publishername>
            </publisher>
            <pubdate>2004</pubdate>
        </biblioentry> 
    </bibliodiv>    
</bibliography>     
          
            <acknowledgements xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>
        Köszönet illeti a
        NEMESPOR, <link xlink:href="https://groups.google.com/forum/#!forum/nemespor">https://groups.google.com/forum/#!forum/nemespor</link>, 
        az UDPROG tanulószoba, <link xlink:href="https://www.facebook.com/groups/udprog">https://www.facebook.com/groups/udprog</link>, 
        a DEAC-Hackers előszoba, <link xlink:href="https://www.facebook.com/groups/DEACHackers">https://www.facebook.com/groups/DEACHackers</link> 
        (illetve egyéb alkalmi szerveződésű szakmai csoportok) 
        tagjait inspiráló érdeklődésükért és hasznos észrevételeikért.         
    </para>                 
    <para>
        Ezen túl kiemelt köszönet illeti az említett UDPROG közösséget, mely a Debreceni Egyetem reguláris 
        programozás oktatása tartalmi szervezését támogatja. Sok példa eleve ebben a közösségben született, vagy itt került
        említésre és adott esetekben szerepet kapott, mint oktatási példa.         
    </para>
	<para>
	Mindemellett külön köszönet illeti azokat akik segítették, hogy ez a könyv megvalósulhasson. 
	</para>                
</acknowledgements>     

</book>
