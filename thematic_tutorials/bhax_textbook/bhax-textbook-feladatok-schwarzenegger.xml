<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Schwarzenegger!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Szoftmax Py MNIST</title>
        <para>
            Python
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/j7f9SkJR3oc">https://youtu.be/j7f9SkJR3oc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0">https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0</link> (/tensorflow-0.9.0/tensorflow/examples/tutorials/mnist/), <link xlink:href="https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol">https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol</link>  
        </para>
        <para>
            <link xlink:href="https://github.com/Savitar97/Prog1/blob/master/tensorflow/twicetwo.py">https://github.com/Savitar97/Prog1/blob/master/tensorflow/twicetwo.py</link>
        </para>
        <para>
            Felhasznált irodalom:<link xlink:href="http://biointelligence.hu/pdf/tf_bkp.pdf">http://biointelligence.hu/pdf/tf_bkp.pdf</link>
        </para>
        <para>
           A tensorflowot a google készítette és fejleszti a gépi tanulást segíti, a tervezésben a fejlesztésben és a tanulmányozásban használják főként mivel készít adatáramlási gráfot, amelyben a node-ok a matematikai műveletek és az élek az áramló adatok. A tensorflow-ot import tensorflow ként hívjuk meg. A readimg függvény beolvassa a kép file-t majd dekódolja erre a későbbiekben lesz szükség.A program lényege, hogy a megadott képen szereplő számot felismerje.Ehhez megkell tanítanunk a programunkat. Tehát elsőnek készítünk egy modelt.Majd ezen gyakoroltassuk a programunkat. Majd futtatunk egy teszt kört ahol a program kiirja a becsült pontosságát. Ezután a 42 es tesztkép felismerése következik. Majd végül a beolvasott képünkön teszteljük a program működését.
           A tesztnél a program súlyokat használ ami a W változó, ezzel dönti el a súlyokat,amely alapján dönt hogy benne van -e a kép amit megadtunk a jó halmazban. Az x változó jelenti a bemenő értéket míg az y a számított kimenő érték. Ez hasonló mint a már átvett perceptron és neurális and or xor kapu. A súlyokkal mindig szorzunk a b mint bias mindig egy konstans érték. A tanulási folyamat is a neurális and or xor kapuhoz hasonló, ugyan úgy vannak hidden rétegek és nekik vannak node-jai. X a példa és Y a várt eredmény. A tanulánál ugyan úgy iterációs határt számolunk. Az Y értékét úgy számoljuk mintha egy egyenes egyenletét írnánk fel az Y= x*a súlyjal ami a W és hozzá adjuk a b-t ami a kostants.
           </para>
           <programlisting><![CDATA[
            y = tf.matmul(x, W) + b
       ]]>
        </programlisting>
            <para>
            Ez az egyenes az ami elválasztja a jó megoldásokat a rosszaktól. Vagyis amelyik teljesíti a feltételt és megközelítőleg helyes értéket ad.
            Itt a feladatunkban az elfogadási arányt(iterációs határ,gradient) 50% nál húztuk meg tehát a program hibázhat. A pontosságot minél több hidden réteggel és noda-al tudjuk növelni. Tehát az egész egy valószínűségi értéket figyel ha megüti a meghatározott küszöböt ez az érték és a hiba mértéke kevés akkor a program elfogadja mint megoldást. A programmal 28*28 pixeles képekről döntjük el, hogy milyen szám szerepel a képen. A y_ a loss-t definiáljuk, amely azt számolja,hogy mennyire térünk el a a várt eredményünktől. A GradientDescentOptimizer deriváltakat számít a hibahatárok figyelembe vételével. Ez a minimize.
                
            </para>
        
    </section>        

<!--
    <section>
        <title>Szoftmax R MNIST</title>
        <para>
            R            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->
    
    <section>
        <title>Mély MNIST</title>
        <para>
            Python            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A deep mnist az előző példára épül annyi különbséggel, hogy itt sokkal több a hidden réteg és azokon a node-ok száma. Emellett két súlyjal dolgozunk. Az az 2 layerünk van a 2. layer az első layer által számolt adatokból dolgozik így már pontosabb eredményeket kapunk, azaz ezzel növelhetjük a pontosságát a programnak.Ugyebár a neuronoknak két állapot van vagy aktiválva vannak vagy nem tehát ez olyan mint a boolean vagy igen vagy nem. Mindig csak egy neuronunk lehet aktiválva, ha több van megkell találnunk melyik az amelyik a többi közül közelebb áll az eredményhez. Vagyis megkell találnunk azt a súly és bias párt amelyjel a legjobb pontosságot kapunk. Ezt a hibavisszaterjesztéssel ellenőrizhetjük.Tehát akkor a legpontosabb az eredmény ha a pontosságunk a legnagyobb és a loss a legkisebb. Itt 32x32 képet vizsgálunk és már nem csak számokat képes felismerni hanem bármit amit megadunk az adatbázisba. Itt az adatbázis is egy sokkal nagyobb 100000 kép körüli a, futási idő is nagyon megnövekedett több órára. A reshape a bemeneti 2 dimenziós kép pixeleit átrendezi egy soros listába.Ez azért kell mert a program csak így tudja vizsgálni a pixeleket. A végeredmény ugyan úgy felismeri a képet az adatbázisból.
        </para>
    </section>        
<!--
    <section>
        <title>Deep dream</title>
        <para>
            Keras            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->                  
    <section>
        <title>Minecraft-MALMÖ</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/bAPSu3Rndi8">https://youtu.be/bAPSu3Rndi8</link>      
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Microsoft/malmo">https://github.com/Microsoft/malmo</link>                
        </para>
        <para>
            Valószínűleg sokan ismerik a MineCraft játékot a kockákból álló világ melynek a főszereplője Steve. A program lényege,hogy Steve egy megadott időintervallumon belül ne akadjon el semmiben. Tehát képes legyen kikerülni a mozgását blokkoló akadályokat.Ezt úgy értük el hogy a steve körül lévő 26 kockát vizsgáljuk mivel ő áll a közepén. Ha nincs szabad út előtt megpróbálja kikerülni ha nem lehetséges akkor ugrik.Azt, hogy épp milyen objektum van Steve előtt a program jelzi. A forgásszámláló counter 8-ban lett meghatározva. Steve egyenesen előre halad mindaddig, amíg valamilyen akadályba nem ütközik. Akadályok lehetnek a víz,levegő,növényzet. A program futása során számoljuk az akadályokat és kiirjuk, hogy steve előtt éppen milyen objektum van.Az akadályok elkerülésének lehetőségei az ugrás, a kitérés vagy az akadály elpusztítása. Az elpusztítás akkor lehet jó lehetőség ha 2 blokk magas fal veszi körül Stevet mert azt már nem tudja átugrani.
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
</chapter>                
