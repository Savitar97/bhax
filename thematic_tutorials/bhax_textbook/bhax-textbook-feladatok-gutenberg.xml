<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>
        <para>
            A megírt programokat "forrásszövegnek" nevezzük. A nyelvtani szabályai a forrásszövegeknek a szintaktikai szabályok, míg a tartalmi szabályokat a szemantika adja meg.
            A forrásszöveget a fordítóprogram alakítja gépi kóddá, amelyet a processzor feltud dolgozni. A fordító program végzi tehát a kód szemantikai,szintaktikai,lexikális vizsgálatát és a kód generálását a szemantikai hibát nem mindig veszi észre mivel lehet, hogy olyan hibát vétettünk, amely formailag helyes csak nem a várt eredményt kapjuk.
            A gépi kódból a szerkesztő állít elő futtatható programot. A magas szintű nyelvek közül a C-ben előfordító segítségével generálunk forrásszövegből forrásszöveget.
            Az interpreternek is megvan a saját elemzője viszont itt soronként veszi az utasítást és egyből el is végzi. A programnyelvek szabályai a hivatkozási nyelvek.
            Amikor a programozó programkódot ír akkor algoritmusokat fogalmaz meg, amivel vezérli a processzort. A lefgőbb eszköz a változó, amelyben értékeket tud letárolni, amelyeket az algoritmusok változtatnak.
            
        </para>
        <para>
            Imperatív nyelvek:Eljárásorientált nyelvek,Objektum orientált nyelvek.
         </para>
         <para>
             Dekleratív nyelvek : Funkcionális nyelvek, logikai nyelvek.
         </para>
         <para>
             Az adattípus egy absztrakt programozási eszköz. Az adattípusnak neve van , amely egy azonosító. Egy adattípust három dolog határoz meg: tartomány, műveletek,reprezentáció. A tartomány megmondja milyen értékeket vehet fel a változó. Minden típúsos nyelvnek vannak standard beépített típúsai. Némelyik programozási nyelv megengedi, hogy definiáljunk típúsokat. Vannak olyan típúsok,amelyet úgy kapok, hogy egy másik típús tartományát szűkítem le ők az altípúsok.Adattípúsok csoportja lehet skalár vagy struktúrált.
             Egyszerű típusok: egész,valós, karakteres,logikai.
             Összetett típusok:tömb(értékei csak egyféle típusú lehet kivéve olyan programozási nyelvekben ahol megvan engedve, hogy a tömb összetett adattípusú legyen.A tömb indexei általában egész típúsúak.A tömb nevével a tömb összes elemére képesek vagyunk hivatkozni.).
             Mutató típus:elemei memóriacímek, legfontosabb művelet a memóriacímen lévő érték elérése.
         </para>
         <para>
             Nevesített konstans: mindig deklarálni kell van neve, típusa és értéke. Mindig a nevével hivatkozunk rá és a hozzá rendelt értékre hivatkozik.
         </para>
         <para>
             Utasítások
         </para>
         <para>
             Utasításokkal adjuk meg az algoritmus lépéseit.Kétféle van deklarációs és végrehajtó utasítások.
             A deklarációs utasítások a fordítóprogramnak szólnak, olyan infromációt szolgáltat amelyet a fordítóprogram használ fel majd a tárgykód elkészítéséhez.
             A végrehajtó utasítások csoportosítása a következő szerint zajlik:
                     
          </para>
          <itemizedlist>
          <listitem>
              <para>1. Értékadó utasítás:módosítja vagy beállítja a változó értékeit
          </para>
          </listitem>
          <listitem>
              <para>2. Üres utasítás:főleg az eljárás orientált nyelvekben van rájuk szükség ilyenkor a processzor egy üres utasítást hajt végre
          </para>
          </listitem>
          <listitem>
              <para>3. Ugró utasítás:goto utasítás a program a futását máshonnan folytatja(ahová az ugró utasítás mutat) 
          </para>
          </listitem>
          <listitem>
              <para>4. Elágaztató utasítások:if else szerkezet vagy a többirányú switch szerkezet.Itt tudjuk irányítani, hogy a program futása merre haladjon tovább. Ifnél ha egy utasítás van a zárójel blokkot elhagyhatjuk.Switchnél van default-ág amely akkor hajtódik végre ha egyik lehetőség sem hajtódik végre.
          </para>
          </listitem>
          <listitem>
              <para>5. Ciklusszervezı utasítások:bizonyos utasítások ismétlése. Előírt lépésszámú ciklus for.Elől tesztelős ciklus while, hátul tesztelős do while.Ha egyszersem fut le üres ciklusnak hívjuk a do while mindenképp lefut 1x.Emellett a ciklusok lehetnek végtelenek és összetettek mikor egymásba ágyazzuk őket.
          </para>
          </listitem>
          <listitem>
              <para> 6. Hívó utasítás: 
          </para>
          </listitem>
          <listitem>
              <para>7. Vezérlésátadó utasítások:continue, break,return. A continuevel kitudunk hagyni például ciklusból lépéseket,break-el megtudjuk szakítani a ciklust vagy az utasítást. A returnnel adunk vissza értékeket főképp függvényeknél használjuk őket.
          </para>
          </listitem>
          <listitem>
              <para>8. I/O utasítások
          </para>
          </listitem>
          <listitem>
              <para>9. Egyéb utasítások
          </para>
          <para>
              Programok szerkezete:
          </para>
          <para>
              Az eljárásorientált nyelvekben :alprogram,blokk,csomag,taszk létezik.
          </para>
          <para>
              Az alprogramok az újrafelhasználás eszközei másnéven eljárások vagy függvények.A meghívásukkal aktivizálódnak.Meghívni a deklarált nevükkel tudjuk.Az alprogramoknak van neve, paraméter listája,törzse amiben az utasítások és vezérlések szerepelnek és környezete, amelyben megtudjuk hívni. A függvényeknek mindig van visszatérési értékük,tehát értéket számolnak ez az érték bármilyen típúsú lehet.Az eljárás ezzel szemben valamilyen tevékenységet hajt végre és ahol meghívjuk ennek a tevékenységnek az eredményét akarjuk felhasználni.
          </para>
          <para>
              Függvényt meghívni csak kifejezésben lehet. A függvény akkor fejeződik be szabályosan ha van visszatérési értéke. Nem szabályosan legtöbbször megszakítás vagy goto utasítással való megszakítással.
              Minden programozási nyelvben van egy fő program egység a main. Minden alprogram ennek adja át a vezérlést.
          </para>
          <para>
              A hívási lánc: amikor egy programegység meghív egy másik programegységet.
              Rekurzió lehet közvetlen:Amikor a program önmagát hívja meg rekurzívan vagy lehet közvetett amikor egy már előzőleg meghívottat és lefutott alprogramot újra meghív.Ezek mindig átírhatók iteratív algoritmusokká ami kevesebb memóriát használ.Néhány programozási nyelvben meglehet határozni másodlagos belépési pontokat vagyis, hogy ne a fejtől fusson le a függvény vagy az eljárás.
           </para>
           <para>
               Paraméterkiértékelés:formális paraméterlistából csak egy darab van viszont az aktuális paraméterlisták száma végtelen lehet.
               Paraméterkiértékelés aspektusok:sorrendi kötés vagy név szerinti kötés.
               
           </para>
           <para>
               A blokk: olyan programegység amely más programegység belsejében helyezkedik el.A blokk aktivizációja úgy történik hogy vagy rákerül a vezérlés vagy a goto utasítással a kezdetére ugrunk.
           </para>
          </listitem>
          </itemizedlist>
    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>
        <para>
            3. Fejezet Vezérlési szerkezetek
            
            A C-nyelvben az utasításokat pontos vesszővel zárjuk. Az utasítás blokkokat {}-el jelöljük.
        </para>
        <para>
            3.2
            If-else
            
            Az if szerkezet döntést hozó utasítás. Ha(feltétel) utasítás else utasítás2 , az elsre nem mindig van szükség lehet olyan is, hogy ha történik valami akkor csináljon valamit a program,ha nem akkor ugorja át. Az else ág mindig a hozzá legközelebb lévő else nélküli ifhez fog tartozni. Ha nem így szeretnénk akkor az if hatáskörét {}-jelek közé kell tenni. Az ifnek van egy másik fajtája az else if itt több feltétel egymásba ágyazása történik. Itt a legutolsó else akkor fut le ha egyik feltétel sem teljesül. Amint egy teljesül a feltételek közül a program végrehajtja és kilép az else-if ágról.
        </para>
        
        <para>
            3.3 Switch
            A switchet többirányú programelágazások esetén használjuk itt valamilyen állandó értékhez rendeli az utasítást. A switchben case-eket hozunk létre, amelyek akkor futnak le ha teljesül az állandó, ezen kívül minden case-t break-el kell zárni.Létezik egy default ág, amely akkor fut le ha egyik case feltétele se teljesül.
            </para>
            <para>
                A break el nem csak a switchből tudunk kilépni hanem bármely ciklust képesek vagyunk vele megszakítani.
             </para> 
             <para>
                A for előírt lépésszámú ciklus, amelynek van egy kezdő értéke egy végértéke és egy lépésszáma. 
              </para>
              <para>
                  A while addig fut amíg a ciklusfejben megadott feltétel hamis nem lesz.
               </para>
               <para>
                   A do while utasítás a while-al szemben az, hogy mindenképp lefut egyszer a ciklusban található utasítás.
               </para>
               <para>
                   A continue utasítás segítségével lehetséges, hogy egy ciklusból kihagyjunk lépéseket vagyis,hogy átugorjunk egy egy lefutást. A goto utasítással a megadott címkére ugorhatunk, goto utasítással általában több egymásba ágyazott ciklusból tudunk kilépni mivel a break nem működik ezeknél.
               </para>  
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
        <para>
            A BME-tankönyv második fejezete a C++ újításait veszi szemügyre a C-vel szemben ezek nagyrészt, csak az olvashatóbb kódot szolgálják.
        </para>
        <para>
        Az első változás a függvények paraméterénél van.C++ ban ha egy függvénynek nem adunk paramétert akkor az egy void paraméterrel lesz egyenlő. C-ben ugyanez tetszőleges számú paramétert jelentett,de C++-ban ez a lehetőség már a ...-lett.
        </para>
        <para>
            Ha nem adunk meg visszatérési típust akkor C-nél ez az int lesz viszont C++-nál már hibát ír ki a fordító azaz nincs alapból ilyen definiálva.
        </para>
        <para>
            C++-ban kétféle main függvény van van a sima int main() és létezik az int main(int argc,char** argv). Az argc a bemenő paraméterek számát, míg az argv egy 2 dimenziós tömböt ad vissza magukról a bemenő argumentumokról. És C++-ban már nem kötelező a return 0; ami a sikeres futást jelzi.
        </para>
        <para>
            Ezeken kívül bevezetésre került a bool típus ez megkönnyíti az olvasást két értéke van true és false.
         </para>
         <para>
             Emellett alapértelmezett típus lett a wchar_t amivel több bájtos karaktereket lehet letárolni pl unicode karakterek. 
         </para>
         <para>
             Képesek vagyunk C függvényeket meghívni C++-ból ez az extern "C"-vel lehetséges. Ez a fordítottját is lehetővé teszi,ha a C++-ban definiálunk egy ilyen függvényt akkor C-ből képesek vagyunk C++ függvényt hívni.
         </para>
         <para>
             Emellett adhatunk meg alapértelmezett argumentumokat ezeket arra az esetre hozhatunk létre ha létrejöhet olyan hiba, hogy a felhasználó kevesebb argumentumot ad meg ekkor van rá egy alapértelmezett alternatíva.
          </para>
          <para>
              A változók deklarálása bárhol történhet ahol utasítás lehetséges a C++-ban érdemes mindig azelőtt deklarálni egy változót mielőtt felhasználunk ezzel átláthatóbb a kód.
          </para>
          <para>
             Függvénynevek túlterhelése: A C-ben a függvényeket a neve azonosította, így nem lehetett két ugyan azzal a névvel rendelkező fv.-t létrehozni. De a C++-ban egy fügvényt már a neve és az argumentumai együttesen azonosítja.
           </para>
           <para>
               Paraméter szerinti átadás: A függényben pointert hívunk meg int* valami néven,míg a változó elé egy és jelet teszünk, így a változó memória címét adjuk át a függvénynek tehát ha valamilyen módosítás történik a változóval a függvényben az kihat a mainben deklarált változóra is. C++-ban bevezették a referencia típust.Így elég ha simán átadjuk a változó értékét majd a függvényben adunk és jelet az argumentumnak aztán mint egy sima változó úgy tudunk vele dolgozni.
            </para>
            <para>
                Az és jel ezen kívül még egy egyoperandusú operátor ami a változó címét adja vissza C-ben még nem szerepelhetett deklarációnál,így a C++-ezt felhasználhatta a referencia típushoz.
            </para>
            <para>
                A cím szerinti paraméter átadás főként a nagyméretű adatszerkezetnél hasznos ugyanis nem kell egy másolatot készíteni róluk, hanem közvetlenül használhatjuk az adatszerkezetet és módosítgathatunk benne.
            </para>
            <para>
                A programok egységbe zárás alapelvét nevezik osztálynak.Az osztályoknak lehetnek példányai ezeket objektumoknak nevezzük.Az objektumnak azt a tulajdonságát, hogy a többi program ne férjen hozzá a tulajdonságaihoz adatrejtésnek nevezzük.Öröklődés amikor az egyik osztály örökli a másik osztály bizonyos tulajdonságait.Behelyettesíthetőség a fentebb lévő osztályba mindig behelyettesíthessük az elvontabb osztályokat.Típustámogatás az osztályok támogathatnak operátorokat és típuskonverziót.
                A struktúráknak nem csak tagváltozói, hanem tagfüggvényei is lehetnek.A tagváltozók megnevezése attribútumok, míg a függvényeké metódusok. Ahányszor létrehozunk egy példányát a stuktúrára a tagváltozók annyiszor foglalnak helyet a memóriában.A tagváltozókra az arrow vagy a . operátorokkal hivatkozhatunk.A hatókör operátor vagy scope azt segíti elő ha több osztálynak van ugyan olyan nevű függvénye akkor képes megkülönböztetni őket. A tagváltozókkal ellentétben a tagfüggvényeknek nem történik többszörös helyfoglalás ezek egy példányban jönnek létre.
                Mivel a függvények képesek változtatni a tagváltozókat ezért pointereket használunk a tagfüggvényeknél és láthatatlan első paramétereket alkalmazunk.Ezek a láthatatlan első paraméterek a példányosított osztály mutatója.Ha van egy ugyanolyan nevű tagváltozónk és függvény argumentumunk akkor az argumentumok és lokális változók az erősebbek,ilyenkor általában a this-el hivatkozunk a tagváltozókra.Az adatrejtésnél a public részben lévő tagváltozókat mindenki eléri mint egy globális változót viszont a private részben csak a belső tagfüggvények férnek hozzá,ilyenkor lekérdező függvényeket kell írnunk.
                Ha nem írunk láthatóságot szabályzó kulcsszavakat automatikusan publicot használ viszont az osztály private-t.
                Az osztály az egy típus.Egy osztályt több osztály is felhasználhat ezért a .h-fájlban a #ifndef és #define segítségével érjük el hogy az osztálydefiníció többször is be legyen includeolva egy programba.
                Mivel a csak deklarált változók véletlen értékeket hordoznak ezért szükségünk van a konstruktorokra amelyek inicializálják a tagváltozókat.Ez egy olyan speciális tagfüggvény,amelynek ugyan az a neve mint az osztálynak és minden egyes példányosításkor lefut.
                A függvénynév túlterhelése miatt egy függvénynek lehet különböző paraméterszámú konstruktora.A destruktorok a fölösleges memória használat felszabadítását végzik általában ~-el kezdődnek és ezt az osztály neve követi, nem lehet argumentuma.
                Dinamikus memóriaterület kezelés: a malloc és free függvényekkel lehetséges.A c++-ban a dinamikus memória kezelést a new végzi és a felszabadítást a delete.A new használatával már nem kell számolgatni a tömböknél a lefoglalt hely értékét, mivel magától képes kiszámolni.A tömböknél mindig a szögletes zárójelt használjuk tehát a delet-hez is hozzá kell írni a szögletes zárójelet ha tömböt akarunk felszabadítani.
                Ha Fifo adatszerkezetet akarunk használni akkor ha új elemet akarunk hozzáadni akkor eggyel nagyobb területet kell foglalnunk majd a végére beszúrni az értéket viszont ha ki akarunk értéket szedni akkor az elsőnek betett értéket tudjuk kivenni majd miután kiszedtük az értéket belőle a megmaradt elemeket visszamásolni és a destruktor a fölösleges helyet elpucolja.Másoló konstruktor ez esetében az inicializálás a már meglévő osztály változói alapján történik mivel egy másolatot akarunk létrehozni.
                A fordító a másoló konstruktort hívja meg ha megvan írva ha nem írunk másoló konstruktort akkor alapértelmezetten bitenként másol.A bitenkénti másolás neve a sekély másolás.Ha a dinamikus adattagokat is másoljuk azt mély másolásnak nevezzük.Érték szerinti paraméter átadásnál referencia szerint kell átadni a másolókonstruktor paraméterét.
            </para>
            <para>
                A friend függvénnyel egy osztály feljogosít más osztályokat vagy globális függvényeket, hogy a private részéhez hozzáférjenek.Tagváltozókat a :-al tudjuk inicializálni a konstruktor zárójele után írva.A referencia tagváltozókat kötelező az inicializálási listában inicializálni.Statikus változókat a static kulcsszóval deklarálunk.Ez hasonlít a globális változókhoz, de annyi különbséggel, hogy itt megkell adni melyik osztályból származik a ::-al.Kezdőértéket nem kötelező adni nekik, mivel ekkor 0 lesz a kezdőértékük. A statikus változóknak a program indításakor foglalódik hely és csak a program bezárásával szabadul fel.
                A statikus függvények törzsében nem használhatunk this mutatót mivel nem lenne értelme.
                Az első futtatott kód a program indulásakor nem a main függvény első sora hanem a statikus és globális változók konstruktorai.Beágyazott függvények esetén megkell adni a teljes elérési utat,ha nem az osztálydefinícióban definiált.A beágyazott osztályoknál nem kap speciális jogokat sem a beágyazott sem a tartalmazó osztály.A különböző absztrakt adattípusok miatt megjelent az operátor túlterhelés.A c++-ban az operátorok az argumentumaikon végeznek műveletet,az operátorok különböző számú argumentumot igényelhetnek. A c++-ban az operator kulcsszó.Itt nem az operátorok működésének megváltoztatása a cél, hanem az, hogy a saját magunk által létrehozott típusra is használhassuk.A túlterhelt operátorokat általában tagfüggvényként érdemes definiálni.
            </para>
    </section>        
  
</chapter>                
