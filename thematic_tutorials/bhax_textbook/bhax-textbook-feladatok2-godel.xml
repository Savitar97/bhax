<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gödel!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Gengszterek</title>
        <para>
Gengszterek rendezése lambdával a Robotautó Világbajnokságban
https://youtu.be/DL6iQwPx1Yw (8:05-től)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A lambda kifejezések a C++11 óta részei a nyelvnek. A lambda kifejezések jellemzője, hogy a visszatérési értékük automatikus. A feladat, hogy vizsgáljuk meg a robotautóban
            a gangsterek rendezését. Ugyebár a rendezés alpja a távolság a rendőröktől. Tehát minél közelebb van egy Gangster objektum egy rendőr objektumhoz annál előrébb kerül a listán.
            Ez azért szükséges, hogy a rendőrök mindig a hozzájuk legközelebb eső Gangstert kezdjék el üldözni. Így a lambdába bemenő két Gangster típúsú paraméter az x és y lesz. A paramétereket ()-be tesszük.
            Ugyebár a lambda kifejezés előnye az, hogy lehetővé teszi olyan 1 soros kódcsipetek írását, amely kis terjedelmű és olvasható. Megkímél minket a hosszú kifejezésektől. Rövid tömör és lényegre törő.
            A szintaxisa a következő képpen néz ki:
        </para>
        <programlisting language="java"><![CDATA[
            [ capture clause ] (parameters) -> return-type  
            {   
            definition of method   
            }
            ]]>
          </programlisting>
          <para>
              Itt a return type az, ami elhanyagolható és csak valami komplexebb esetben szükséges. A kocka zárójelbe a capture kerül. A capture lehet érték szerinti ezt az egyenlőség jel jelzi vagy esetleg referencia szerinti ilyenkor az és jelzi
              mint a megszokott referencia szerinti átadásnál. És ezen kívül lehet vegyes. De akár üres is. Ha üres akkor csak a lokális változókhoz fér hozzá. A törzse a lambda kifejezésnek a megszokott kapcsos zárójelek közé kerül. Tehát egy blokkba.
          </para>
          <programlisting language="java"><![CDATA[
            std::sort ( gangsters.begin(), gangsters.end(), [this, cop] ( Gangster x, Gangster y )
            {
                return dst ( cop, x.to ) < dst ( cop, y.to );
            } );
            ]]>
          </programlisting>
          <para>
              Így néz ki a kész kód. Ugyebár mivel rendezünk ezért a sortot fogjuk használni. Ugye mivel nem egyszerű rendezés kell 
              ezért a hosszabb speciális alakját használjuk, amelynek 3 argumentumot kell megadni. A tömb kezdetét,végét és a 3. a rendezés alapját. Azaz egy olyan függvényt, amely a rendezést szolgálja és bool a visszatérési értéke.
              Ugyebár a this szokás szerint magára az adott objektumra vonatkozik. És ezenkívül a cophoz fér még hozzá a capture érték szerint.
          </para>
  
  
    </section>        

    <section>
        <title>C++11 Custom Allocator</title>
        <para>
            https://prezi.com/jvvbytkwgsxj/high-level-programming-languages-2-c11-allocators/ a
CustomAlloc-os példa, lásd C forrást az UDPROG repóban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
    <section>
        <title>STL map érték szerinti rendezése</title>
        <para>
            Például: https://github.com/nbatfai/future/blob/master/cs/F9F2/fenykard.cpp#L180
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Egy map érték szerinti rendezése volt a feladat. A mapok kulcs-érték párok. Nézzük is meg, hogyan lehet deklarálni egy mapot c++-ban és, hogyan tudunk értékeket felvenni benne.
        </para>
        <programlisting language="java"><![CDATA[
            std::map<std::string, int> planetsMap;
                planetsMap.insert(std::make_pair("earth", 4));
                planetsMap.insert(std::make_pair("moon", 2));
                planetsMap.insert(std::make_pair("jupiter", 10));
                planetsMap.insert(std::make_pair("mars", 7));
                planetsMap.insert(std::make_pair("saturnus", 9));
            ]]>
          </programlisting>
          <para>
            Mint látható az insertel tudunk értékeket felvenni a mapunkba és az értékek ugyebár kulcs érték párok, amiket a make_pairrel vagyunk képesek képezni.
            Na és most nézzük meg, hogyan tudjuk kiiratni ezeket az értékeket:
          </para>
          <programlisting language="java"><![CDATA[
            std::map<std::string, int>::iterator it = planetsMap.begin();
            while(it != planetsMap.end())
            {
                std::cout<<it->first<<" :: "<<it->second<<std::endl;
                it++;
            }
            ]]>
          </programlisting>
          <para>
              A fenti kódban látható, hogy az it-et ráállítjuk a map első értékére, ezt a .begin el érjük el. Majd egy while ciklussal bejárjuk a mapot.
              Addig míg az it nem az utolsó elemre fog referálni. És kiiratjuk a first el a kulcsot és a seconddal az értéket.
          </para>
          <para>
              Most nézzük a rendezésünket:
          </para>
          <programlisting language="java"><![CDATA[
            std::vector<std::pair<std::string, int>> rendezMap ( std::map <std::string, int> &rank )
            {
                    std::vector<std::pair<std::string, int>> rendezett;

                    for ( auto & i : rank ) {
                            if ( i.second ) {
                                    std::pair<std::string, int> p {i.first, i.second};
                                    rendezett.push_back ( p );
                            }
                    };

                    std::sort (
                            std::begin ( rendezett ), std::end ( rendezett ),
                    [ = ] ( auto && p1, auto && p2 ) {
                        std::cout<<p1.second<<std::endl;
                        std::cout<<p2.second<<std::endl;
                        std::cout<<"**************"<<std::endl;
                            return p1.second > p2.second;
                    }
                    );

                    return rendezett;
            }
            ]]>
          </programlisting>
          <para>
              Na tehát nézzük a függvényünket. Ugyebár a paramétert referenciaként adjuk át ezt jelöli az és jel. Létrehozunk egy új vektort a függvényen belül a neve az lesz, hogy rendezett.
              Majd egy foreach ciklussal bejárjuk a mapunkat és a rendezetthez adjuk az elemket. Majd jön egy lamdakifejezés, amivel rendezzük érték szerint a mapot. Ugyebár végig megyünk a vektoron és megvizsgáljuk, hogy a p1 nagyobb-e mint p2 ha nem akkor elkezdünk végig menni az értékeken hátulról és a megfelelő helyre beszúrni.
              Majd a végén vissza térünk a rendezett mappal. A dokumentációból látható a következő a sort-ra:
          </para>
          <programlisting language="java"><![CDATA[
            default (1)	

            template <class RandomAccessIterator>
            void sort (RandomAccessIterator first, RandomAccessIterator last);

            custom (2)	

            template <class RandomAccessIterator, class Compare>
            void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
                        ]]>
          </programlisting>
          <para>
              Ugyebár itt a custom fog lefutni és a compare comp lesz a lambda kifejezésünk. Aminek a visszatérési értéke bool típúsú lesz.
          </para>
          <figure>
                <title>Map rendezés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/map1.png" scale="35" />
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                    <title>Map rendezés</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="img/map2.png" scale="35" />
                            </imageobject>
                        </mediaobject>
                </figure>
    </section>
    <section>
        <title>Alternatív tabella rendezése</title>
        <para>
            Mutassuk be a https://progpater.blog.hu/2011/03/11/alternativ_tabella a programban a java.lang
Interface Comparable szerepét!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A Comparable interface szerepére kellett rávilágítanunk ebben a feladatban. Ezt az interface-t meghívó objektumok listáit vagy tömbjeit képesek vagyunk automatikusan rendezni az array.sort-al vagy
            a Collections.sort al. Azok az objektumok, amelyek ezt az interface-t használják ezen kívül használhatók kulcsként rendezett map-okban vagy egy rendezett halmaz elemeiként anélkül, hogy lenne specifikált összehasonlító algoritmusuk.
            A specifikált algoritmus alatt azt értem, hogy külön osztályt hozunk létre az objektum bizonyos tulajdonság szerinti rendezésére. Például itt létrehozhatnánk külön név szerinti rendezést, pont szerinti rendezést stb. Ezt Comperatornak nevezzük.
            A compareto ugyebár úgy működik, hogy egyet ad vissza ha a vizsgált objektumunk nagyobb a megadott objektumnál. -1 el tér vissza ha kisebb a megadott objektumnál és 0 ha egyenlő a két objektum. A Comparable interface lényege, hogy ezt a vizsgálódást kiterjesszük
            az általunk megadott típúsokra is.
            A kódban ez így jelenik meg:
        </para>
        <programlisting language="java"><![CDATA[
        class Csapat implements Comparable<Csapat> {

        protected String nev;
        protected double ertek;

        public Csapat(String nev, double ertek) {
            this.nev = nev;
            this.ertek = ertek;
        }

        public int compareTo(Csapat csapat) {
            if (this.ertek < csapat.ertek) {
            return -1;
            } else if (this.ertek > csapat.ertek) {
            return 1;
            } else {
            return 0;
            }
        }
        }
          ]]>
        </programlisting>
        <para>
            Itt látható, hogy a csapat osztályunkra implementáljuk a Comparable interface-t ugyebár a kacsacsőrök közé a T- típust kell megadni.
            Ugyebár létrehoztunk 2 változót a csapat nevét és a pontját. A konstruktorban csak azt definiáltuk, hogy a paraméterként bejövő értékeket táruljuk le
            a változóinkba. Majd megírjuk az összehasonlító metódust.Itt lényegében érték szerint növekvőbe rendezzük az értékeket. De mivel a csapatokat abc-szerint redezzük.
            Ezért majd a kódban ennek az ellentetjét azaz a reverse-t kell vennünk. Hogy az értékek a jó csapathoz kerüljenek.
        </para>
        <programlisting language="java"><![CDATA[
            java.util.List<Csapat> rendezettCsapatok = java.util.Arrays.asList(csapatok);
            java.util.Collections.sort(rendezettCsapatok);
            java.util.Collections.reverse(rendezettCsapatok);
          ]]>
        </programlisting>
        <para>
            Itt látható a mainben szereplő lényeg ugyebár mint az elején említettem megtudjuk rá hívni a collections.sort-ot.Ez itt látszik is.
        </para>
        <para>
            Nézzük meg kicsit a java forrás fájlokat is, ugyebár a sort az utilban van definiálva azon belül is a collectionsba. Itt láthatjuk, hogy a T típusnak implementálnia kell a Comparable interfacet. Itt extends el szerepel a Comparable. Ezt osztályoknál leszármaztatáskor szoktuk alkalmazni.
            És látható, hogy a list.sort null-t kap meg paraméterül.
        </para>
        <figure>
            <title>Collections</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/javacollection.png" scale="35" />
                    </imageobject>
                </mediaobject>
        </figure>
        <para>    
            Majd mivel a rendezett csapatok ugyebár listában vannak. Tehát keressük ki a javában a lista sort metódusát. Itt már kicsit több információt kapunk.
        </para>
        <figure>
            <title>Lista</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/javalist.png" scale="35" />
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            Ez tovább vezet minket az Array.sort-hoz, keressük is ki.
        </para>
        <figure>
            <title>Arrays</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/javaarrays.png" scale="35" />
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            De sajnos kalandozásunk a forrásokban itt még mindig nem ért a végére. Ugyanis itt látható, hogy a ComparableTimSort osztály sort ját fogja felhasználni.
        </para>
        <figure>
            <title>TimSort</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/javatimsort.png" scale="35" />
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            A timsort osztályunkban megtalálva a számunkra szükséges sortot látszik, hogy az osztálynak a binarysort metódusa fog meghívódni.
        </para>
        <figure>
            <title>Binarysort</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="img/javabinarysort.png" scale="35" />
                    </imageobject>
                </mediaobject>
        </figure>
        <para>
            Végére érve látjuk, hogy a binary sortban Comparable típusra kényszerítés történik az objektumunkra.
        </para>
    </section>
    <section>
        <title>Prolog családfa</title>
        <para>
            Ágyazd be a Prolog családfa programot C++ vagy Java programba! Lásd para_prog_guide.pdf!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A prolog családfához felkell használnunk a swi prolog kiegészítőt. Ezt úgy tudjuk telepíteni ubuntun, hogy <command>sudo apt-get install swi-prolog</command>
            és <command>sudo apt-get install swi-prolog-java</command>. A programunkhoz ezen kívül megkell írnunk a prolog pl kiterjesztésű fájlunkat, amely a kifejezéseket és
            a változóink definiálását végzi. Mivel a prolog elsőrendű logikát használ, ezért a logika tárgyon tanultak nagy segítségünkre van. Tehát itt definiáljuk a családi kapcsolatokat,
            amelyet majd vizsgálunk. Például felvesszük, hogy kik a férfiak a családban,de például egy kicsivel bonyolultabb apa az, aki férfi és van gyereke ez a következőképp néz ki a kódban: 
        </para>
        <programlisting language="java"><![CDATA[
            apa(X) :- férfi(X), gyereke(_Y, X).
            ]]>
          </programlisting>
          <para>
              Aztán nézzük magát a kódot. Kezdetben bekell importálni magát a könyvtárat, hogy lássa az org.jpl-t. Ez netbeans projektben könnyű. Csak rámegyünk a projektnél, hogy libraries jobb klikk és add library.
              Aztán Create és megkell adni az elérési útját <command>/usr/lib/swi-prolog/lib/jpl.jar</command>. Aztán be is importálhatjuk a szükséges osztályokat.
          </para>
          <programlisting language="java"><![CDATA[

            import java.util.Map;

            import org.jpl7.JPL;
            import org.jpl7.Query;
            import org.jpl7.Term;
            ]]>
          </programlisting>
          <para> Ezután jöhet maga a program rész. Mielőtt bármihez is neki kezdenénk bekell húznunk a prolog fájlunkat, ugyanis ez alapján dolgozunk.Ez a következőképpen lehetséges:</para>
          <programlisting language="java"><![CDATA[
            String s = "consult('family.pl')";
            Query q = new Query(s);
            System.out.println(s + " " + (Query.hasSolution(s) ? "succeeded" : "failed"));
            ]]>
          </programlisting>
          <para>
              Tehát a forma az h egy stringbe megadjuk a consult függvénybe a fájl nevet. Majd létrehozunk egy query objektumot. Majd rátesztelünk, hogy működik -e vagy nem.
          </para>
          <para>
              Majd jöhetnek a tesztek. Kezdetben nézzük meg, hogy edit apa -e?
          </para>
          <programlisting language="java"><![CDATA[
            String term = "apa(edit)";
            System.out.println(term + " is " + (Query.hasSolution(term) ? "provable" : "not provable"));
            ]]>
          </programlisting>
          <para>
              Természetesen a visszakapott érték a not provable lesz ugyanis apa csak az lehet aki férfi és van gyereke. Itt a println nél a ? operátort használtuk, amely az ifhez hasonló.
              Ha igaz a kifejezés akkor a ?-utáni rész kerül kiértékelésre. Ha hamis akkor a : utáni. Na ezután nézzünk meg egy kicsit nehezebbet.
          </para>
          <para>A következőben nézzük meg ki a nagyapám:</para>
          <programlisting language="java"><![CDATA[
            String term1 = "nagyapja(X, attila)";
            System.out.println("A formula megoldásai: " + term1);
            Query q1 = new Query(term1);
            while (q1.hasMoreSolutions()) {
                Map<String, Term> str = q1.nextSolution();
                System.out.println("X = " + str.get("X"));
            } 
            ]]>
          </programlisting>
          <para>
              Ugyebár a nagyapa az a szüleim szülője. És hát mivel az embernek két szülője van ezért itt több érték lesz. Itt jön képbe a hasmoresolution azaz, hogy van még más jó megoldás is.
              Mivel itt már több érték lesz ezért mapot fogunk használni. A kulcs érték párok itt kapóra jönnek. Mivel érték párokkal dolgozunk. A következő kép szemlélteti a futtatást:
          </para>
          <figure>
                <title>Családfa</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/csaladfa.png" scale="35" />
                        </imageobject>
                    </mediaobject>
            </figure>
  
  

  
    </section>
	<section>
        <title>GIMP Scheme hack</title>
        <para>
            Ha az előző félévben nem dolgoztad fel a témát (például a mandalás vagy a króm szöveges
dobozosat) akkor itt az alkalom!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
        <para>
            Ebben a gimp scriptben ugyan úgy mint az előzőnél az elején definiáljuk az új képünket és layereinket. A gimp-image-new függvény létrehoz egy listát, mivel minden gimpfüggvény egy listát ad vissza. A lista elemeihez a car-al férünk hozzá, ami kiveszi a lista első elemét. A legfontosabb rész itt a forgatások mivel a mandala úgy készül, hogy a szöveget körbe forgatjuk egy pontban és így a betűk keresztezik majd egymást. A forgatást a gimp-item-transform-rotate-simple függvénnyel érjük el.A változók értékét a set-el tudjuk beállítani.
            Mivel a betűknek a mérete változó szövegtípúsonként ezért függvényt használunk ezeknek az értékeknek a kezelésére ez a text-wh függvény. Ez konkrétan lekéri a fonttípusnak a méreteit és azt tároljuk a szélességben és a magasságban.
            A forgatások után a plug-in-autocrop-layer törli az üres szegélyeket. Majd megadjuk a szélesség és magasságnak a kirajzolható méreteket a drawable-el ez a függvény a kirajzolható pixelekkel tér vissza. Majd ez alapján újraméretezzük a layert a resize- al. Az ecset méreteit a gimp-context-set-brush-size-al tudjuk módosítani ez pixelben adja meg a méreteket. Ezzel adjuk meg majd a mandala keretének a vastagságát, amelyet az gimp-image-select-ellipse-el hozunk létre. Ebből 2 van az egyik a külső körív a vastagabb 22 pixel míg a véknyabb 8 pixel vastag.
            Párbeszéd ablakokat a gimp-message-el tudunk készíteni. Az elkészített képet a gimp-display-new-al jelenítsük meg új ablakban.Majd ki cleareljük a képet gimp-image-clean-all.
            Futtatáskor a kép méretét tudjuk beállítani a betűtípust és a betűméretet. Ezen kívül a színt és színskálát.
        </para>
        <figure>
             <title>Név mandala</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandala.png" scale="100" />
                </imageobject>
        </mediaobject>
        </figure>
        <figure>
             <title>Név mandala2</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/NemesisR.png" scale="100" />
                </imageobject>
        </mediaobject>
        </figure>      
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
