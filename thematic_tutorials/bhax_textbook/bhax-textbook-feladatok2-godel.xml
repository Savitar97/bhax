<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gödel!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Gengszterek</title>
        <para>
Gengszterek rendezése lambdával a Robotautó Világbajnokságban
https://youtu.be/DL6iQwPx1Yw (8:05-től)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A lambda kifejezések a C++11 óta részei a nyelvnek.
        </para>
    </section>        

    <section>
        <title>C++11 Custom Allocator</title>
        <para>
            https://prezi.com/jvvbytkwgsxj/high-level-programming-languages-2-c11-allocators/ a
CustomAlloc-os példa, lásd C forrást az UDPROG repóban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
    <section>
        <title>STL map érték szerinti rendezése</title>
        <para>
            Például: https://github.com/nbatfai/future/blob/master/cs/F9F2/fenykard.cpp#L180
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Egy map érték szerinti rendezése volt a feladat. A mapok kulcs-érték párok. Nézzük is meg, hogyan lehet deklarálni egy mapot c++-ban és, hogyan tudunk értékeket felvenni benne.
        </para>
        <programlisting language="java"><![CDATA[
            std::map<std::string, int> planetsMap;
                planetsMap.insert(std::make_pair("earth", 4));
                planetsMap.insert(std::make_pair("moon", 2));
                planetsMap.insert(std::make_pair("jupiter", 10));
                planetsMap.insert(std::make_pair("mars", 7));
                planetsMap.insert(std::make_pair("saturnus", 9));
            ]]>
          </programlisting>
          <para>
            Mint látható az insertel tudunk értékeket felvenni a mapunkba és az értékek ugyebár kulcs érték párok, amiket a make_pairrel vagyunk képesek képezni.
            Na és most nézzük meg, hogyan tudjuk kiiratni ezeket az értékeket:
          </para>
          <programlisting language="java"><![CDATA[
            std::map<std::string, int>::iterator it = planetsMap.begin();
            while(it != planetsMap.end())
            {
                std::cout<<it->first<<" :: "<<it->second<<std::endl;
                it++;
            }
            ]]>
          </programlisting>
          <para>
              A fenti kódban látható, hogy az it-et ráállítjuk a map első értékére, ezt a .begin el érjük el. Majd egy while ciklussal bejárjuk a mapot.
              Addig míg az it nem az utolsó elemre fog referálni. És kiiratjuk a first el a kulcsot és a seconddal az értéket.
          </para>
          <para>
              Most nézzük a rendezésünket:
          </para>
          <programlisting language="java"><![CDATA[
            std::vector<std::pair<std::string, int>> rendezMap ( std::map <std::string, int> &rank )
            {
                    std::vector<std::pair<std::string, int>> rendezett;

                    for ( auto & i : rank ) {
                            if ( i.second ) {
                                    std::pair<std::string, int> p {i.first, i.second};
                                    rendezett.push_back ( p );
                            }
                    };

                    std::sort (
                            std::begin ( rendezett ), std::end ( rendezett ),
                    [ = ] ( auto && p1, auto && p2 ) {
                        std::cout<<p1.second<<std::endl;
                        std::cout<<p2.second<<std::endl;
                        std::cout<<"**************"<<std::endl;
                            return p1.second > p2.second;
                    }
                    );

                    return rendezett;
            }
            ]]>
          </programlisting>
          <para>
              Na tehát nézzük a függvényünket. Ugyebár a paramétert referenciaként adjuk át ezt jelöli az és jel. Létrehozunk egy új vektort a függvényen belül a neve az lesz, hogy rendezett.
              Majd egy foreach ciklussal bejárjuk a mapunkat és a rendezetthez adjuk az elemket. Majd jön egy lamdakifejezés, amivel rendezzük érték szerint a mapot. Ugyebár végig megyünk a vektoron és megvizsgáljuk, hogy a p1 nagyobb-e mint p2 ha nem akkor elkezdünk végig menni az értékeken hátulról és a megfelelő helyre beszúrni.
              Majd a végén vissza térünk a rendezett mappal.
          </para>
          <figure>
                <title>Map rendezés</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="img/map1.png" scale="35" />
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                    <title>Map rendezés</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="img/map2.png" scale="35" />
                            </imageobject>
                        </mediaobject>
                </figure>
    </section>
    <section>
        <title>Alternatív tabella rendezése</title>
        <para>
            Mutassuk be a https://progpater.blog.hu/2011/03/11/alternativ_tabella a programban a java.lang
Interface Comparable szerepét!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A Comparable interface szerepére kellett rávilágítanunk ebben a feladatban. Ezt az interface-t meghívó objektumok listáit vagy tömbjeit képesek vagyunk automatikusan rendezni az array.sort-al vagy
            a Collections.sort al. Azok az objektumok, amelyek ezt az interface-t használják ezen kívül használhatók kulcsként rendezett map-okban vagy egy rendezett halmaz elemeiként anélkül, hogy lenne specifikált összehasonlító algoritmusuk.
            A specifikált algoritmus alatt azt értem, hogy külön osztályt hozunk létre az objektum bizonyos tulajdonság szerinti rendezésére. Például itt létrehozhatnánk külön név szerinti rendezést, pont szerinti rendezést stb. Ezt Comperatornak nevezzük.
            A compareto ugyebár úgy működik, hogy egyet ad vissza ha a vizsgált objektumunk nagyobb a megadott objektumnál. -1 el tér vissza ha kisebb a megadott objektumnál és 0 ha egyenlő a két objektum. A Comparable interface lényege, hogy ezt a vizsgálódást kiterjesszük
            az általunk megadott típúsokra is.
            A kódban ez így jelenik meg:
        </para>
        <programlisting language="java"><![CDATA[
        class Csapat implements Comparable<Csapat> {

        protected String nev;
        protected double ertek;

        public Csapat(String nev, double ertek) {
            this.nev = nev;
            this.ertek = ertek;
        }

        public int compareTo(Csapat csapat) {
            if (this.ertek < csapat.ertek) {
            return -1;
            } else if (this.ertek > csapat.ertek) {
            return 1;
            } else {
            return 0;
            }
        }
        }
          ]]>
        </programlisting>
        <para>
            Itt látható, hogy a csapat osztályunkra implementáljuk a Comparable interface-t ugyebár a kacsacsőrök közé a T- típust kell megadni.
            Ugyebár létrehoztunk 2 változót a csapat nevét és a pontját. A konstruktorban csak azt definiáltuk, hogy a paraméterként bejövő értékeket táruljuk le
            a változóinkba. Majd megírjuk az összehasonlító metódust.Itt lényegében érték szerint növekvőbe rendezzük az értékeket. De mivel a csapatokat abc-szerint redezzük.
            Ezért majd a kódban ennek az ellentetjét azaz a reverse-t kell vennünk. Hogy az értékek a jó csapathoz kerüljenek.
        </para>
        <programlisting language="java"><![CDATA[
            java.util.List<Csapat> rendezettCsapatok = java.util.Arrays.asList(csapatok);
            java.util.Collections.sort(rendezettCsapatok);
            java.util.Collections.reverse(rendezettCsapatok);
          ]]>
        </programlisting>
        <para>
            Itt látható a mainben szereplő lényeg ugyebár mint az elején említettem megtudjuk rá hívni a collections.sort-ot.Ez itt látszik is.
        </para>
    </section>
    <section>
        <title>Prolog családfa</title>
        <para>
            Ágyazd be a Prolog családfa programot C++ vagy Java programba! Lásd para_prog_guide.pdf!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
	<section>
        <title>GIMP Scheme hack</title>
        <para>
            Ha az előző félévben nem dolgoztad fel a témát (például a mandalás vagy a króm szöveges
dobozosat) akkor itt az alkalom!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
        <para>
            Ebben a gimp scriptben ugyan úgy mint az előzőnél az elején definiáljuk az új képünket és layereinket. A gimp-image-new függvény létrehoz egy listát, mivel minden gimpfüggvény egy listát ad vissza. A lista elemeihez a car-al férünk hozzá, ami kiveszi a lista első elemét. A legfontosabb rész itt a forgatások mivel a mandala úgy készül, hogy a szöveget körbe forgatjuk egy pontban és így a betűk keresztezik majd egymást. A forgatást a gimp-item-transform-rotate-simple függvénnyel érjük el.A változók értékét a set-el tudjuk beállítani.
            Mivel a betűknek a mérete változó szövegtípúsonként ezért függvényt használunk ezeknek az értékeknek a kezelésére ez a text-wh függvény. Ez konkrétan lekéri a fonttípusnak a méreteit és azt tároljuk a szélességben és a magasságban.
            A forgatások után a plug-in-autocrop-layer törli az üres szegélyeket. Majd megadjuk a szélesség és magasságnak a kirajzolható méreteket a drawable-el ez a függvény a kirajzolható pixelekkel tér vissza. Majd ez alapján újraméretezzük a layert a resize- al. Az ecset méreteit a gimp-context-set-brush-size-al tudjuk módosítani ez pixelben adja meg a méreteket. Ezzel adjuk meg majd a mandala keretének a vastagságát, amelyet az gimp-image-select-ellipse-el hozunk létre. Ebből 2 van az egyik a külső körív a vastagabb 22 pixel míg a véknyabb 8 pixel vastag.
            Párbeszéd ablakokat a gimp-message-el tudunk készíteni. Az elkészített képet a gimp-display-new-al jelenítsük meg új ablakban.Majd ki cleareljük a képet gimp-image-clean-all.
            Futtatáskor a kép méretét tudjuk beállítani a betűtípust és a betűméretet. Ezen kívül a színt és színskálát.
        </para>
        <figure>
             <title>Név mandala</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandala.png" scale="100" />
                </imageobject>
        </mediaobject>
        </figure>
        <figure>
             <title>Név mandala2</title>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/NemesisR.png" scale="100" />
                </imageobject>
        </mediaobject>
        </figure>      
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
