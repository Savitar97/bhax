<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Liskov helyettesítés sértése</title>
        <para>
Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a
megoldásra: jobb OO tervezés.
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (93-99 fólia)
(számos példa szerepel az elv megsértésére az UDPROG repóban, lásd pl. source/binom/Batfai-
Barki/madarak/)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            A liskov elv arról szól,hogy minden osztályt helyettesíthessen a gyermek osztálya anélkül,
            hogy a program működése megváltozna. Legyen S T-nek egy leszármazottja, ekkor minden T típúsú
            objektum legyen helyettesíthető S objektumokkal. Jelen esetünkben vizsgáljunk meg egy példát:
        </para>
        <programlisting language="java"><![CDATA[
            class Madar{
                void repul(){
                   System.out.println("I belive I can fly");
               }
           }
           
           class Sas extends Madar{
               @Override
               void repul(){
                   System.out.println("A sas repül");
               }
           }
           
           class Pingvin extends Madar{
           
           }
           
           class Liskov{
               public static void main(String[] args) {
                   Madar madar=new Madar();
                   madar.repul();
                   madar=new Sas();
                   madar.repul();
                   madar=new Pingvin();
                   madar.repul();
               }
           }
            ]]>
          </programlisting>
          <para>
              Mint látható a liskov elv itt sérül ugyanis a program szerint a pingvin képes repülni. A probléma onnan adódik, hogy azt tettük fel, hogy minden madár tud repülni.
              Ezért tévesen a repül metódust a madár osztályba írtuk.Tehát az alap tervezéssel volt a probléma. A megoldás az, ha csinálunk egy külön interface-t, amely a repülés tulajdonságot jelenti,bár ekkor a madár osztályt is interface-ve kell alakítanunk, mivel a többszörös öröklődés nem lehetséges javaban.
              Hasonlót csak az interfacekkel érünk el.
          </para>
          <programlisting language="java"><![CDATA[
            interface Madar{
	 
            }
            
            interface RepuloMadar {
                abstract void repul();
            }
            class Sas  implements RepuloMadar{
                public void repul(){
                    System.out.println("A sas repül");
                }
            }
            
            class Pingvin implements Madar{
            
            }
            
            class Liskovjo{
                public static void main(String[] args) {
                    Sas sas=new Sas();
                    Pingvin pingvin=new Pingvin();
                    sas.repul();
                    pingvin.repul();
                }
            }
            ]]>
          </programlisting>
    </section>        

    <section>
        <title>Szülő-gyerek</title>
        <para>
            Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön
keresztül csak az ős üzenetei küldhetőek!
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (98. fólia)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
    <section>
        <title>Anti OO</title>
        <para>
            A BBP algoritmussal 4 a Pi hexadecimális kifejtésének a 0. pozíciótól számított 10 6, 107, 108 darab
jegyét határozzuk meg C, C++, Java és C# nyelveken és vessük össze a futási időket!
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html#id561066
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
    <section>
        <title>Hello Android!</title>
        <para>
            Élesszük fel az SMNIST for Humans projektet!
https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main
Apró módosításokat eszközölj benne, pl. színvilág.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
    <section>
        <title>Ciklomatikus komplexitás</title>
        <para>
            Számoljuk ki valamelyik programunk függvényeinek ciklomatikus komplexitását! Lásd a fogalom
tekintetében a https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_2.pdf (77-79
fóliát)!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
